# Customize Output

**Learning Outcome:** Control file paths, naming conventions, and code formatting.

## File Path Configuration

Configure where generated files are written:

```typescript
// base.ts
import { toModelBase } from "@skmtc/core"

export const MyBase = toModelBase({
  id: "my-generator",
  
  toExportPath(refName: RefName): string {
    const { name } = this.toIdentifier(refName)
    
    // Customize the output directory and file naming
    return `src/generated/types/${name}.ts`
  }
})
```

## Naming Convention Control

Customize how schema names become identifiers:

```typescript
// base.ts
import { toModelBase, Identifier, capitalize, camelCase, kebabCase } from "@skmtc/core"

export const MyBase = toModelBase({
  id: "my-generator",
  
  toIdentifier(refName: RefName): Identifier {
    // Different naming strategies:
    
    // PascalCase for types
    const pascalCase = capitalize(camelCase(refName))
    return Identifier.createType(pascalCase)
    
    // camelCase for values
    // const camelCased = camelCase(refName)
    // return Identifier.createValue(camelCased)
    
    // kebab-case for files
    // const kebabCased = kebabCase(refName)
    // return Identifier.createValue(kebabCased)
    
    // Custom prefix/suffix
    // const withPrefix = `API${pascalCase}`
    // return Identifier.createType(withPrefix)
  }
})
```

## Directory Structure

Organize files into custom directory structures:

```typescript
// base.ts
export const MyBase = toModelBase({
  id: "my-generator",
  
  toExportPath(refName: RefName): string {
    const { name } = this.toIdentifier(refName)
    
    // Group by schema type
    if (refName.includes('Request')) {
      return `src/types/requests/${name}.ts`
    }
    
    if (refName.includes('Response')) {
      return `src/types/responses/${name}.ts`
    }
    
    // Default location
    return `src/types/models/${name}.ts`
  }
})
```

## Custom File Extensions

Control file extensions and formats:

```typescript
// base.ts
export const MyBase = toModelBase({
  id: "my-generator",
  
  toExportPath(refName: RefName): string {
    const { name } = this.toIdentifier(refName)
    
    // Different extensions for different purposes
    return `types/${name}.generated.d.ts`  // Type definitions only
    // return `types/${name}.js`             // Plain JavaScript
    // return `types/${name}.mjs`            // ES modules
    // return `types/${name}.ts`             // TypeScript
  }
})
```

## Code Formatting

Control code style and formatting:

```typescript
// MyGenerator.ts
export class MyGenerator extends ModelBase {
  override toString(): string {
    const { name } = this.identifier
    const properties = this.generateProperties()
    
    // Custom indentation and formatting
    return this.formatCode(`
interface ${name} {
${properties}
}`)
  }
  
  private formatCode(code: string): string {
    // Custom formatting logic
    return code
      .split('\n')
      .map(line => line.trim() ? `  ${line}` : line)  // 2-space indent
      .join('\n')
      .trim()
  }
  
  private generateProperties(): string {
    return this.schema.properties
      ?.map(prop => {
        const optional = prop.required ? '' : '?'
        const comment = prop.description ? ` // ${prop.description}` : ''
        
        return `${prop.name}${optional}: ${prop.type}${comment}`
      })
      .join('\n') || ''
  }
}
```

## Prettier Integration

Use Prettier for consistent formatting:

```typescript
// MyGenerator.ts
import { format } from "prettier"

export class MyGenerator extends ModelBase {
  override toString(): string {
    const code = this.generateRawCode()
    
    // Format with Prettier
    return format(code, {
      parser: "typescript",
      semi: false,
      singleQuote: true,
      trailingComma: "es5",
      tabWidth: 2
    })
  }
  
  private generateRawCode(): string {
    // Generate unformatted code
    return `interface ${this.identifier.name} { /* properties */ }`
  }
}
```

## Template-Based Generation

Use templates for consistent output:

```typescript
// MyGenerator.ts
export class MyGenerator extends ModelBase {
  override toString(): string {
    const template = `
/**
 * Generated interface for ${this.schema.name}
 * @generated by ${this.constructor.name}
 */
export interface {{name}} {
{{properties}}
}

export const {{name}}Schema = {
  type: 'object',
  properties: {
{{schemaProperties}}
  }
}
`
    
    return this.renderTemplate(template, {
      name: this.identifier.name,
      properties: this.generateProperties(),
      schemaProperties: this.generateSchemaProperties()
    })
  }
  
  private renderTemplate(template: string, vars: Record<string, string>): string {
    return Object.entries(vars).reduce(
      (result, [key, value]) => result.replaceAll(`{{${key}}}`, value),
      template
    )
  }
}
```

## Import Management

Control import statements and dependencies:

```typescript
// MyGenerator.ts
export class MyGenerator extends ModelBase {
  override toString(): string {
    const imports = this.generateImports()
    const interface_ = this.generateInterface()
    
    return `${imports}\n\n${interface_}`
  }
  
  private generateImports(): string {
    const imports = []
    
    // Add conditional imports based on schema properties
    if (this.schema.properties?.some(p => p.type === 'Date')) {
      imports.push("import { DateTime } from 'luxon'")
    }
    
    if (this.schema.properties?.some(p => p.format === 'uuid')) {
      imports.push("import { UUID } from './types/uuid'")
    }
    
    return imports.join('\n')
  }
}
```

## What You Learned

- `toExportPath()` controls where files are written
- `toIdentifier()` controls naming conventions  
- File extensions and directory structure are customizable
- Code formatting can be controlled at the generator level
- Templates provide consistent output formatting
- Import statements can be generated conditionally

## What's Next

- **[Handle Complex Schemas →](handle-complex-schemas.md)** - Deal with allOf, references, and validation
- **[Test Generators →](test-generators.md)** - Write unit tests for your generators