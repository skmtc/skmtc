{
  "src/sections/Applicants/tables/ApplicantsTable.generated.tsx": "import { useGetApiApplicants } from '@/sections/Applicants/services/useGetApiApplicants.generated.ts'\nimport { useState } from 'react'\nimport { TextFormatter } from '@/formatters/TextFormatter.tsx'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\nimport { useNavigate } from 'react-router-dom'\n\nexport type UseApplicantsTableArgs = {sortBy?: (string) | null | undefined, embed?: (Array<'appointments' | 'areas' | 'department' | 'documents' | 'negotiators' | 'offers' | 'offices' | 'solicitor' | 'source'>) | null | undefined, id?: (Array<string>) | null | undefined, age?: (Array<'period' | 'new' | 'modern' | 'old'>) | null | undefined, contactDetail?: (Array<string>) | null | undefined, emailAddresses?: (Array<string>) | null | undefined, furnishing?: (Array<'furnished' | 'unfurnished' | 'partFurnished'>) | null | undefined, locality?: (Array<'rural' | 'village' | 'townCity'>) | null | undefined, negotiatorId?: (Array<string>) | null | undefined, officeId?: (Array<string>) | null | undefined, parking?: (Array<'residents' | 'offStreet' | 'secure' | 'underground' | 'garage' | 'doubleGarage' | 'tripleGarage' | 'carport'>) | null | undefined, situation?: (Array<'garden' | 'land' | 'patio' | 'roofTerrace' | 'conservatory' | 'balcony' | 'communalGardens' | 'outsideSpace'>) | null | undefined, style?: (Array<'terraced' | 'endTerrace' | 'detached' | 'semiDetached' | 'linkDetached' | 'mews' | 'basement' | 'lowerGroundFloor' | 'groundFloor' | 'firstFloor' | 'upperFloor' | 'upperFloorWithLift' | 'penthouse' | 'duplex'>) | null | undefined, type?: (Array<'house' | 'bungalow' | 'flatApartment' | 'maisonette' | 'land' | 'farm' | 'cottage' | 'studio' | 'townhouse' | 'developmentPlot'>) | null | undefined, market?: (Array<'local' | 'openA' | 'openB' | 'openC' | 'openD'>) | null | undefined, address?: (string) | null | undefined, departmentId?: (string) | null | undefined, marketingMode?: (Array<'buying' | 'renting'>) | null | undefined, name?: (string) | null | undefined, nameType?: (Array<'surname' | 'initials' | 'full' | 'companyName'>) | null | undefined, priceFrom?: (number) | null | undefined, priceTo?: (number) | null | undefined, rentFrom?: (number) | null | undefined, rentTo?: (number) | null | undefined, rentFrequency?: (Array<'weekly' | 'monthly' | 'annually'>) | null | undefined, bedroomsFrom?: (number) | null | undefined, bedroomsTo?: (number) | null | undefined, active?: (boolean) | null | undefined, fromArchive?: (boolean) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, hasLastCall?: (boolean) | null | undefined, lastCallFrom?: (Date) | null | undefined, lastCallTo?: (Date) | null | undefined, nextCallFrom?: (Date) | null | undefined, nextCallTo?: (Date) | null | undefined, hasNextCall?: (boolean) | null | undefined, metadata?: (Array<string>) | null | undefined, locationOptions?: (string) | null | undefined};\nexport const useApplicantsTable = (args: UseApplicantsTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiApplicants({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const ApplicantsTable = () => {\n  \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useApplicantsTable({}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Applicants',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New applicantsTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/applicants/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [{\n      label: 'Notes',\n      value: <TextFormatter value={value} />,\n      icon: undefined,\n      cellHasDarkText: true,\n      narrowTable: {\n        showLabel: true,\n      },\n    }],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Applicants/services/useGetApiApplicants.generated.ts": "import { getApiApplicantsResponse } from '@/sections/Applicants/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiApplicantsFnArgs = {pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, sortBy?: (string) | null | undefined, embed?: (Array<'appointments' | 'areas' | 'department' | 'documents' | 'negotiators' | 'offers' | 'offices' | 'solicitor' | 'source'>) | null | undefined, id?: (Array<string>) | null | undefined, age?: (Array<'period' | 'new' | 'modern' | 'old'>) | null | undefined, contactDetail?: (Array<string>) | null | undefined, emailAddresses?: (Array<string>) | null | undefined, furnishing?: (Array<'furnished' | 'unfurnished' | 'partFurnished'>) | null | undefined, locality?: (Array<'rural' | 'village' | 'townCity'>) | null | undefined, negotiatorId?: (Array<string>) | null | undefined, officeId?: (Array<string>) | null | undefined, parking?: (Array<'residents' | 'offStreet' | 'secure' | 'underground' | 'garage' | 'doubleGarage' | 'tripleGarage' | 'carport'>) | null | undefined, situation?: (Array<'garden' | 'land' | 'patio' | 'roofTerrace' | 'conservatory' | 'balcony' | 'communalGardens' | 'outsideSpace'>) | null | undefined, style?: (Array<'terraced' | 'endTerrace' | 'detached' | 'semiDetached' | 'linkDetached' | 'mews' | 'basement' | 'lowerGroundFloor' | 'groundFloor' | 'firstFloor' | 'upperFloor' | 'upperFloorWithLift' | 'penthouse' | 'duplex'>) | null | undefined, type?: (Array<'house' | 'bungalow' | 'flatApartment' | 'maisonette' | 'land' | 'farm' | 'cottage' | 'studio' | 'townhouse' | 'developmentPlot'>) | null | undefined, market?: (Array<'local' | 'openA' | 'openB' | 'openC' | 'openD'>) | null | undefined, address?: (string) | null | undefined, departmentId?: (string) | null | undefined, marketingMode?: (Array<'buying' | 'renting'>) | null | undefined, name?: (string) | null | undefined, nameType?: (Array<'surname' | 'initials' | 'full' | 'companyName'>) | null | undefined, priceFrom?: (number) | null | undefined, priceTo?: (number) | null | undefined, rentFrom?: (number) | null | undefined, rentTo?: (number) | null | undefined, rentFrequency?: (Array<'weekly' | 'monthly' | 'annually'>) | null | undefined, bedroomsFrom?: (number) | null | undefined, bedroomsTo?: (number) | null | undefined, active?: (boolean) | null | undefined, fromArchive?: (boolean) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, hasLastCall?: (boolean) | null | undefined, lastCallFrom?: (Date) | null | undefined, lastCallTo?: (Date) | null | undefined, nextCallFrom?: (Date) | null | undefined, nextCallTo?: (Date) | null | undefined, hasNextCall?: (boolean) | null | undefined, metadata?: (Array<string>) | null | undefined, locationOptions?: (string) | null | undefined};\nexport const getApiApplicantsFn = async ({pageSize, pageNumber, sortBy, embed, id, age, contactDetail, emailAddresses, furnishing, locality, negotiatorId, officeId, parking, situation, style, type, market, address, departmentId, marketingMode, name, nameType, priceFrom, priceTo, rentFrom, rentTo, rentFrequency, bedroomsFrom, bedroomsTo, active, fromArchive, createdFrom, createdTo, modifiedFrom, modifiedTo, hasLastCall, lastCallFrom, lastCallTo, nextCallFrom, nextCallTo, hasNextCall, metadata, locationOptions}: GetApiApplicantsFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/applicants/${querySerialiser({args:{pageSize, pageNumber, sortBy, embed, id, age, contactDetail, emailAddresses, furnishing, locality, negotiatorId, officeId, parking, situation, style, type, market, address, departmentId, marketingMode, name, nameType, priceFrom, priceTo, rentFrom, rentTo, rentFrequency, bedroomsFrom, bedroomsTo, active, fromArchive, createdFrom, createdTo, modifiedFrom, modifiedTo, hasLastCall, lastCallFrom, lastCallTo, nextCallFrom, nextCallTo, hasNextCall, metadata, locationOptions}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiApplicantsResponse.parse(data)\n    };\nexport const useGetApiApplicants = ({pageSize, pageNumber, sortBy, embed, id, age, contactDetail, emailAddresses, furnishing, locality, negotiatorId, officeId, parking, situation, style, type, market, address, departmentId, marketingMode, name, nameType, priceFrom, priceTo, rentFrom, rentTo, rentFrequency, bedroomsFrom, bedroomsTo, active, fromArchive, createdFrom, createdTo, modifiedFrom, modifiedTo, hasLastCall, lastCallFrom, lastCallTo, nextCallFrom, nextCallTo, hasNextCall, metadata, locationOptions}: GetApiApplicantsFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Applicants', pageSize, pageNumber, sortBy, embed, id, age, contactDetail, emailAddresses, furnishing, locality, negotiatorId, officeId, parking, situation, style, type, market, address, departmentId, marketingMode, name, nameType, priceFrom, priceTo, rentFrom, rentTo, rentFrequency, bedroomsFrom, bedroomsTo, active, fromArchive, createdFrom, createdTo, modifiedFrom, modifiedTo, hasLastCall, lastCallFrom, lastCallTo, nextCallFrom, nextCallTo, hasNextCall, metadata, locationOptions],\n        queryFn: () => getApiApplicantsFn({pageSize, pageNumber, sortBy, embed, id, age, contactDetail, emailAddresses, furnishing, locality, negotiatorId, officeId, parking, situation, style, type, market, address, departmentId, marketingMode, name, nameType, priceFrom, priceTo, rentFrom, rentTo, rentFrequency, bedroomsFrom, bedroomsTo, active, fromArchive, createdFrom, createdTo, modifiedFrom, modifiedTo, hasLastCall, lastCallFrom, lastCallTo, nextCallFrom, nextCallTo, hasNextCall, metadata, locationOptions}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Applicants/services/apiTypes.generated.ts": "import { applicantModelPagedResult } from '@/schemas/applicantModelPagedResult.generated.tsx'\nimport { CreateApplicantModel, createApplicantModel } from '@/schemas/createApplicantModel.generated.tsx'\nimport { z } from 'zod'\nimport { applicantContactRelationshipModelPagedResult } from '@/schemas/applicantContactRelationshipModelPagedResult.generated.tsx'\nimport { InsertApplicantContactRelationshipModel, insertApplicantContactRelationshipModel } from '@/schemas/insertApplicantContactRelationshipModel.generated.tsx'\nimport { applicantModel } from '@/schemas/applicantModel.generated.tsx'\nimport { applicantContactRelationshipModel } from '@/schemas/applicantContactRelationshipModel.generated.tsx'\n\nexport const getApiApplicantsResponse = applicantModelPagedResult;\nexport type CreateApiApplicantsBody = CreateApplicantModel;\nexport const createApiApplicantsBody = createApplicantModel;\nexport const createApiApplicantsResponse = z.void();\nexport const getApiApplicantsIdRelationshipsResponse = applicantContactRelationshipModelPagedResult;\nexport type CreateApiApplicantsIdRelationshipsBody = InsertApplicantContactRelationshipModel;\nexport const createApiApplicantsIdRelationshipsBody = insertApplicantContactRelationshipModel;\nexport const createApiApplicantsIdRelationshipsResponse = z.void();\nexport const getApiApplicantsIdResponse = applicantModel;\nexport const patchApiApplicantsIdResponse = z.void();\nexport const getApiApplicantsIdRelationshipsRelationshipIdResponse = applicantContactRelationshipModel;\nexport const deleteApiApplicantsIdRelationshipsRelationshipIdResponse = z.void();",
  "src/schemas/applicantModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { applicantModel, ApplicantModel } from '@/schemas/applicantModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const applicantModelPagedResult = z.object({_embedded: z.array(applicantModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type ApplicantModelPagedResult = {_embedded?: (Array<ApplicantModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/applicantModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\nimport { unmappedRequirementModel, UnmappedRequirementModel } from '@/schemas/unmappedRequirementModel.generated.tsx'\nimport { applicantBuyingModel, ApplicantBuyingModel } from '@/schemas/applicantBuyingModel.generated.tsx'\nimport { applicantRentingModel, ApplicantRentingModel } from '@/schemas/applicantRentingModel.generated.tsx'\nimport { applicantExternalAreaModel, ApplicantExternalAreaModel } from '@/schemas/applicantExternalAreaModel.generated.tsx'\nimport { applicantInternalAreaModel, ApplicantInternalAreaModel } from '@/schemas/applicantInternalAreaModel.generated.tsx'\nimport { applicantSourceModel, ApplicantSourceModel } from '@/schemas/applicantSourceModel.generated.tsx'\nimport { applicantCommercialModel, ApplicantCommercialModel } from '@/schemas/applicantCommercialModel.generated.tsx'\nimport { applicantRegionalModel, ApplicantRegionalModel } from '@/schemas/applicantRegionalModel.generated.tsx'\nimport { applicantContactModel, ApplicantContactModel } from '@/schemas/applicantContactModel.generated.tsx'\n\nexport const applicantModel = /** Representation of an applicant */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the applicant */\nz.string().optional().nullable(), created: /** The date and time when the applicant was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the applicant was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), marketingMode: /** Indicates whether the applicant is look to buy or rent a property (buying/renting) */\nz.string().optional().nullable(), currency: /** The ISO-4217 currency code that relates to monetary amounts specified by the applicant */\nz.string().optional().nullable(), active: /** A flag determining whether or not the applicant is actively looking for a property */\nz.boolean().optional().nullable(), notes: /** A free text field describing any adhoc buying or renting requirements */\nz.string().optional().nullable(), sellingStatus: /** The applicant's selling status (preAppraisal/valuation/paidValuation/forSale/forSaleUnavailable/underOffer/underOfferUnavailable/reserved/exchanged/completed/soldExternally/withdrawn) */\nz.string().optional().nullable(), sellingPosition: /** The applicant's selling position (nothingToSell/renting/sellingWithUs/sellingWithOtherAgent/sellingPrivately/notYetOnMarket) */\nz.string().optional().nullable(), statusId: /** The status id of the applicant */\nz.string().optional().nullable(), lastCall: /** The date when the applicant was last contacted */\nz.string().optional().nullable(), nextCall: /** The date when the applicant is next due to be contacted */\nz.string().optional().nullable(), departmentId: /** The unique identifier of the department the applicant is associated with. The applicant will only match to properties with the same values set. See the [Platform Glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information about departments */\nz.string().optional().nullable(), solicitorId: /** The unique identifier of the solicitor associated to the applicant */\nz.string().optional().nullable(), potentialClient: /** A flag determining whether or not the applicant is a potential client */\nz.boolean().optional().nullable(), type: /** The applicant's property type requirements (eg house, bungalow, land), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department)\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nz.array(z.string().min(1)).optional().nullable(), style: /** The applicant's property style requirements (eg detached, semiDetached), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department)\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nz.array(z.string().min(1)).optional().nullable(), situation: /** The applicant's requirements for other aspects of prospective properties - such as outside space - as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department)\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nz.array(z.string().min(1)).optional().nullable(), parking: /** The applicant's parking requirements (eg garage), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department)\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nz.array(z.string().min(1)).optional().nullable(), age: /** The applicant's property age requirements (eg new, period), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department)\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nz.array(z.string().min(1)).optional().nullable(), locality: /** The applicant's general property location requirements (eg rural, townCity), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department)\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nz.array(z.string().min(1)).optional().nullable(), specialFeatures: /** The applicant's special feature property requirements (eg swimmingPool, tennisCourt), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(z.string().min(1)).optional().nullable(), unmappedRequirements: /** The requirements associated to the applicant which are not currently mapped. These are defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(unmappedRequirementModel).optional().nullable(), bedroomsMin: /** The minimum number of bedrooms the applicant requires. This is only supported by some departments. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nz.number().int().optional().nullable(), bedroomsMax: /** The maximum number of bedrooms the applicant requires. This is only supported by some departments. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nz.number().int().optional().nullable(), receptionsMin: /** The minimum number of reception rooms the applicant requires. This is only supported by some departments. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nz.number().int().optional().nullable(), receptionsMax: /** The maximum number of reception rooms the applicant requires. This is only supported by some departments. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nz.number().int().optional().nullable(), bathroomsMin: /** The minimum number of bathrooms the applicant requires. This is only supported by some departments. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nz.number().int().optional().nullable(), bathroomsMax: /** The maximum number of bathrooms the applicant requires. This is only supported by some departments. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nz.number().int().optional().nullable(), parkingSpacesMin: /** The minimum number of parking spaces the applicant requires. This is only supported by some departments. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nz.number().int().optional().nullable(), parkingSpacesMax: /** The maximum number of parking spaces the applicant requires. This is only supported by some departments. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nz.number().int().optional().nullable(), locationType: /** The applicant's location type (areas/addresses/none) */\nz.string().optional().nullable(), locationOptions: /** The applicant's location options */\nz.array(z.string().min(1)).optional().nullable(), archivedOn: /** The date and time the applicant was archived */\nz.string().pipe( z.coerce.date() ).optional().nullable(), fromArchive: /** A flag denoting whether or not this applicant is archived */\nz.boolean().optional().nullable(), buying: applicantBuyingModel.optional().nullable(), renting: applicantRentingModel.optional().nullable(), externalArea: applicantExternalAreaModel.optional().nullable(), internalArea: applicantInternalAreaModel.optional().nullable(), source: applicantSourceModel.optional().nullable(), commercial: applicantCommercialModel.optional().nullable(), regional: applicantRegionalModel.optional().nullable(), officeIds: /** A collection of unique identifiers of offices attached to the applicant. The first item in the collection is considered the primary office */\nz.array(z.string().min(1)).optional().nullable(), negotiatorIds: /** A collection of unique identifiers of negotiators attached to the applicant. The first item in the collection is considered the primary negotiator */\nz.array(z.string().min(1)).optional().nullable(), related: /** A collection of contacts and/or companies associated to the applicant. The first item in the collection is considered the primary relationship */\nz.array(applicantContactModel).optional().nullable(), metadata: /** App specific metadata that has been set against the applicant */\nz.record(z.string(), z.object({})).optional().nullable(), _eTag: /** The ETag for the current version of the applicant. Used for managing update concurrency */\nz.string().optional().nullable()});\nexport type ApplicantModel = /** Representation of an applicant */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the applicant */\nstring) | null | undefined, created?: (/** The date and time when the applicant was created */\nDate) | null | undefined, modified?: (/** The date and time when the applicant was last modified */\nDate) | null | undefined, marketingMode?: (/** Indicates whether the applicant is look to buy or rent a property (buying/renting) */\nstring) | null | undefined, currency?: (/** The ISO-4217 currency code that relates to monetary amounts specified by the applicant */\nstring) | null | undefined, active?: (/** A flag determining whether or not the applicant is actively looking for a property */\nboolean) | null | undefined, notes?: (/** A free text field describing any adhoc buying or renting requirements */\nstring) | null | undefined, sellingStatus?: (/** The applicant's selling status (preAppraisal/valuation/paidValuation/forSale/forSaleUnavailable/underOffer/underOfferUnavailable/reserved/exchanged/completed/soldExternally/withdrawn) */\nstring) | null | undefined, sellingPosition?: (/** The applicant's selling position (nothingToSell/renting/sellingWithUs/sellingWithOtherAgent/sellingPrivately/notYetOnMarket) */\nstring) | null | undefined, statusId?: (/** The status id of the applicant */\nstring) | null | undefined, lastCall?: (/** The date when the applicant was last contacted */\nstring) | null | undefined, nextCall?: (/** The date when the applicant is next due to be contacted */\nstring) | null | undefined, departmentId?: (/** The unique identifier of the department the applicant is associated with. The applicant will only match to properties with the same values set. See the [Platform Glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information about departments */\nstring) | null | undefined, solicitorId?: (/** The unique identifier of the solicitor associated to the applicant */\nstring) | null | undefined, potentialClient?: (/** A flag determining whether or not the applicant is a potential client */\nboolean) | null | undefined, type?: (/** The applicant's property type requirements (eg house, bungalow, land), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department)\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nArray<string>) | null | undefined, style?: (/** The applicant's property style requirements (eg detached, semiDetached), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department)\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nArray<string>) | null | undefined, situation?: (/** The applicant's requirements for other aspects of prospective properties - such as outside space - as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department)\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nArray<string>) | null | undefined, parking?: (/** The applicant's parking requirements (eg garage), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department)\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nArray<string>) | null | undefined, age?: (/** The applicant's property age requirements (eg new, period), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department)\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nArray<string>) | null | undefined, locality?: (/** The applicant's general property location requirements (eg rural, townCity), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department)\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nArray<string>) | null | undefined, specialFeatures?: (/** The applicant's special feature property requirements (eg swimmingPool, tennisCourt), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<string>) | null | undefined, unmappedRequirements?: (/** The requirements associated to the applicant which are not currently mapped. These are defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<UnmappedRequirementModel>) | null | undefined, bedroomsMin?: (/** The minimum number of bedrooms the applicant requires. This is only supported by some departments. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nnumber) | null | undefined, bedroomsMax?: (/** The maximum number of bedrooms the applicant requires. This is only supported by some departments. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nnumber) | null | undefined, receptionsMin?: (/** The minimum number of reception rooms the applicant requires. This is only supported by some departments. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nnumber) | null | undefined, receptionsMax?: (/** The maximum number of reception rooms the applicant requires. This is only supported by some departments. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nnumber) | null | undefined, bathroomsMin?: (/** The minimum number of bathrooms the applicant requires. This is only supported by some departments. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nnumber) | null | undefined, bathroomsMax?: (/** The maximum number of bathrooms the applicant requires. This is only supported by some departments. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nnumber) | null | undefined, parkingSpacesMin?: (/** The minimum number of parking spaces the applicant requires. This is only supported by some departments. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nnumber) | null | undefined, parkingSpacesMax?: (/** The maximum number of parking spaces the applicant requires. This is only supported by some departments. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nnumber) | null | undefined, locationType?: (/** The applicant's location type (areas/addresses/none) */\nstring) | null | undefined, locationOptions?: (/** The applicant's location options */\nArray<string>) | null | undefined, archivedOn?: (/** The date and time the applicant was archived */\nDate) | null | undefined, fromArchive?: (/** A flag denoting whether or not this applicant is archived */\nboolean) | null | undefined, buying?: (ApplicantBuyingModel) | null | undefined, renting?: (ApplicantRentingModel) | null | undefined, externalArea?: (ApplicantExternalAreaModel) | null | undefined, internalArea?: (ApplicantInternalAreaModel) | null | undefined, source?: (ApplicantSourceModel) | null | undefined, commercial?: (ApplicantCommercialModel) | null | undefined, regional?: (ApplicantRegionalModel) | null | undefined, officeIds?: (/** A collection of unique identifiers of offices attached to the applicant. The first item in the collection is considered the primary office */\nArray<string>) | null | undefined, negotiatorIds?: (/** A collection of unique identifiers of negotiators attached to the applicant. The first item in the collection is considered the primary negotiator */\nArray<string>) | null | undefined, related?: (/** A collection of contacts and/or companies associated to the applicant. The first item in the collection is considered the primary relationship */\nArray<ApplicantContactModel>) | null | undefined, metadata?: (/** App specific metadata that has been set against the applicant */\nRecord<string, Record<string, never>>) | null | undefined, _eTag?: (/** The ETag for the current version of the applicant. Used for managing update concurrency */\nstring) | null | undefined};",
  "src/schemas/linkModel.generated.tsx": "import { z } from 'zod'\n\nexport const linkModel = z.object({href: z.string().optional().nullable()});\nexport type LinkModel = {href?: (string) | null | undefined};",
  "src/schemas/unmappedRequirementModel.generated.tsx": "import { z } from 'zod'\n\nexport const unmappedRequirementModel = /** Represents an unmapped requirement type */\nz.object({type: /** The type of unmapped requirement */\nz.string().optional().nullable(), value: /** The value associated to the unmapped type */\nz.string().optional().nullable()});\nexport type UnmappedRequirementModel = /** Represents an unmapped requirement type */\n{type?: (/** The type of unmapped requirement */\nstring) | null | undefined, value?: (/** The value associated to the unmapped type */\nstring) | null | undefined};",
  "src/schemas/applicantBuyingModel.generated.tsx": "import { z } from 'zod'\nimport { applicantLeaseRemaining, ApplicantLeaseRemaining } from '@/schemas/applicantLeaseRemaining.generated.tsx'\n\nexport const applicantBuyingModel = /** The details specific to applicants with a marketingMode of buying */\nz.object({priceFrom: /** The lower bound of the applicant's budget */\nz.number().int().optional().nullable(), priceTo: /** The upper bound of the applicant's budget */\nz.number().int().optional().nullable(), decoration: /** A list of property decoration requirements taken from the full listing of the associated department (unmodernised/fair/good/veryGood) */\nz.array(z.string().min(1)).optional().nullable(), reasonId: /** The identifier of the applicant's buying reason */\nz.string().optional().nullable(), positionId: /** The identifier of the applicant's selling position */\nz.string().optional().nullable(), tenure: /** A list of tenure requirements taken from the full listing of the associated department (freehold/leasehold/shareOfFreehold) */\nz.array(z.string().min(1)).optional().nullable(), mortgageExpiry: /** The date when the applicant's current mortgage expires/is due for renewal */\nz.string().optional().nullable(), leaseRemaining: applicantLeaseRemaining.optional().nullable()});\nexport type ApplicantBuyingModel = /** The details specific to applicants with a marketingMode of buying */\n{priceFrom?: (/** The lower bound of the applicant's budget */\nnumber) | null | undefined, priceTo?: (/** The upper bound of the applicant's budget */\nnumber) | null | undefined, decoration?: (/** A list of property decoration requirements taken from the full listing of the associated department (unmodernised/fair/good/veryGood) */\nArray<string>) | null | undefined, reasonId?: (/** The identifier of the applicant's buying reason */\nstring) | null | undefined, positionId?: (/** The identifier of the applicant's selling position */\nstring) | null | undefined, tenure?: (/** A list of tenure requirements taken from the full listing of the associated department (freehold/leasehold/shareOfFreehold) */\nArray<string>) | null | undefined, mortgageExpiry?: (/** The date when the applicant's current mortgage expires/is due for renewal */\nstring) | null | undefined, leaseRemaining?: (ApplicantLeaseRemaining) | null | undefined};",
  "src/schemas/applicantLeaseRemaining.generated.tsx": "import { z } from 'zod'\n\nexport const applicantLeaseRemaining = /** The details specific to the applicant's lease term requirements where they are interested in properties with a leasehold tenure */\nz.object({min: /** The minimum number of years that must remain on the lease of a leasehold property */\nz.number().int().optional().nullable(), max: /** The maximum number of years that must remain on the lease of a leasehold property */\nz.number().int().optional().nullable()});\nexport type ApplicantLeaseRemaining = /** The details specific to the applicant's lease term requirements where they are interested in properties with a leasehold tenure */\n{min?: (/** The minimum number of years that must remain on the lease of a leasehold property */\nnumber) | null | undefined, max?: (/** The maximum number of years that must remain on the lease of a leasehold property */\nnumber) | null | undefined};",
  "src/schemas/applicantRentingModel.generated.tsx": "import { z } from 'zod'\n\nexport const applicantRentingModel = /** The details specific to applicants with a marketingMode of renting */\nz.object({moveDate: /** The date the applicant is looking to move to a new property */\nz.string().optional().nullable(), term: /** The applicant's preferred letting term (long/short/any) */\nz.string().optional().nullable(), rentFrom: /** The lower bound of the applicant's budget */\nz.number().optional().nullable(), rentTo: /** The upper bound of the applicant's budget */\nz.number().optional().nullable(), rentFrequency: /** The desired rent collection frequency specified by the applicant's budget (weekly/monthly/annually) */\nz.string().optional().nullable(), furnishing: /** A list of property furnishing requirements taken from the full listing of the associated department. Only applicable to applicants with a marketingMode of renting */\nz.array(z.string().min(1)).optional().nullable(), positionId: /** The identifier of the applicant's renting position */\nz.string().optional().nullable()});\nexport type ApplicantRentingModel = /** The details specific to applicants with a marketingMode of renting */\n{moveDate?: (/** The date the applicant is looking to move to a new property */\nstring) | null | undefined, term?: (/** The applicant's preferred letting term (long/short/any) */\nstring) | null | undefined, rentFrom?: (/** The lower bound of the applicant's budget */\nnumber) | null | undefined, rentTo?: (/** The upper bound of the applicant's budget */\nnumber) | null | undefined, rentFrequency?: (/** The desired rent collection frequency specified by the applicant's budget (weekly/monthly/annually) */\nstring) | null | undefined, furnishing?: (/** A list of property furnishing requirements taken from the full listing of the associated department. Only applicable to applicants with a marketingMode of renting */\nArray<string>) | null | undefined, positionId?: (/** The identifier of the applicant's renting position */\nstring) | null | undefined};",
  "src/schemas/applicantExternalAreaModel.generated.tsx": "import { z } from 'zod'\n\nexport const applicantExternalAreaModel = /** The applicant's outdoor space requirements */\nz.object({type: /** The unit of area that each amount corresponds to (acres/hectares) */\nz.string().optional().nullable(), amountFrom: /** The minimum unit value of outside space that the applicant is looking for */\nz.number().optional().nullable(), amountTo: /** The maximum unit value of outside space that the applicant is looking for */\nz.number().optional().nullable()});\nexport type ApplicantExternalAreaModel = /** The applicant's outdoor space requirements */\n{type?: (/** The unit of area that each amount corresponds to (acres/hectares) */\nstring) | null | undefined, amountFrom?: (/** The minimum unit value of outside space that the applicant is looking for */\nnumber) | null | undefined, amountTo?: (/** The maximum unit value of outside space that the applicant is looking for */\nnumber) | null | undefined};",
  "src/schemas/applicantInternalAreaModel.generated.tsx": "import { z } from 'zod'\n\nexport const applicantInternalAreaModel = /** The applicant's indoor space requirements */\nz.object({type: /** The unit of area that each amount corresponds to (squareFeet/squareMetres) */\nz.string().optional().nullable(), amount: /** The unit value of inside space that the applicant is looking for */\nz.number().optional().nullable()});\nexport type ApplicantInternalAreaModel = /** The applicant's indoor space requirements */\n{type?: (/** The unit of area that each amount corresponds to (squareFeet/squareMetres) */\nstring) | null | undefined, amount?: (/** The unit value of inside space that the applicant is looking for */\nnumber) | null | undefined};",
  "src/schemas/applicantSourceModel.generated.tsx": "import { z } from 'zod'\n\nexport const applicantSourceModel = /** An applicant's source of enquiry */\nz.object({id: /** The unique identifier of the applicant's source */\nz.string().optional().nullable(), type: /** The source type (office/source) */\nz.string().optional().nullable()});\nexport type ApplicantSourceModel = /** An applicant's source of enquiry */\n{id?: (/** The unique identifier of the applicant's source */\nstring) | null | undefined, type?: (/** The source type (office/source) */\nstring) | null | undefined};",
  "src/schemas/applicantCommercialModel.generated.tsx": "import { z } from 'zod'\n\nexport const applicantCommercialModel = /** An applicant's commercial details */\nz.object({useClass: /** The commercial use requirements (eg a1, a2, b1), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(z.string().min(1)).optional().nullable(), floorLevel: /** The commercial floor level attributes (eg basement, subGround, ground, upperFloor), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(z.string().min(1)).optional().nullable()});\nexport type ApplicantCommercialModel = /** An applicant's commercial details */\n{useClass?: (/** The commercial use requirements (eg a1, a2, b1), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<string>) | null | undefined, floorLevel?: (/** The commercial floor level attributes (eg basement, subGround, ground, upperFloor), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<string>) | null | undefined};",
  "src/schemas/applicantRegionalModel.generated.tsx": "import { z } from 'zod'\nimport { applicantGuernseyModel, ApplicantGuernseyModel } from '@/schemas/applicantGuernseyModel.generated.tsx'\n\nexport const applicantRegionalModel = /** Details relating to the real estate market in specific countries. Child models are named based on the ISO3166 country code that the data inside the model relates to */\nz.object({ggy: applicantGuernseyModel.optional().nullable()});\nexport type ApplicantRegionalModel = /** Details relating to the real estate market in specific countries. Child models are named based on the ISO3166 country code that the data inside the model relates to */\n{ggy?: (ApplicantGuernseyModel) | null | undefined};",
  "src/schemas/applicantGuernseyModel.generated.tsx": "import { z } from 'zod'\n\nexport const applicantGuernseyModel = /** Details of regional information specific to Guernsey */\nz.object({market: /** Requirements describing which markets the applicant is looking for properties in (local/openA/openB/openC/openD) */\nz.array(z.string().min(1)).optional().nullable()});\nexport type ApplicantGuernseyModel = /** Details of regional information specific to Guernsey */\n{market?: (/** Requirements describing which markets the applicant is looking for properties in (local/openA/openB/openC/openD) */\nArray<string>) | null | undefined};",
  "src/schemas/applicantContactModel.generated.tsx": "import { z } from 'zod'\nimport { applicantContactAddressModel, ApplicantContactAddressModel } from '@/schemas/applicantContactAddressModel.generated.tsx'\nimport { additionalContactDetailModel, AdditionalContactDetailModel } from '@/schemas/additionalContactDetailModel.generated.tsx'\n\nexport const applicantContactModel = /** A summarised view of the details of a contact or company associated to an applicant */\nz.object({id: /** The unique identifier of the contact or company */\nz.string().optional().nullable(), name: /** The complete name of the contact or company */\nz.string().optional().nullable(), title: /** The title of the contact (Available when 'type' is 'contact') */\nz.string().optional().nullable(), forename: /** The forename of the contact (Available when 'type' is 'contact') */\nz.string().optional().nullable(), surname: /** The surname of the contact (Available when 'type' is 'contact') */\nz.string().optional().nullable(), dateOfBirth: /** The date of birth of the contact (Available when 'type' is 'contact') */\nz.string().optional().nullable(), type: /** The type of the contact (company/contact) */\nz.string().optional().nullable(), homePhone: /** The home phone number of the contact or company */\nz.string().optional().nullable(), workPhone: /** The work phone number of the contact or company */\nz.string().optional().nullable(), mobilePhone: /** The mobile phone number of the contact or company */\nz.string().optional().nullable(), email: /** The email address of the contact or company */\nz.string().optional().nullable(), marketingConsent: /** The marketing consent status of the contact (grant/deny/notAsked) */\nz.string().optional().nullable(), fromArchive: /** A flag denoting whether or not this relationship is archived */\nz.boolean().optional().nullable(), primaryAddress: applicantContactAddressModel.optional().nullable(), additionalContactDetails: /** A collection of additional contact details */\nz.array(additionalContactDetailModel).optional().nullable()});\nexport type ApplicantContactModel = /** A summarised view of the details of a contact or company associated to an applicant */\n{id?: (/** The unique identifier of the contact or company */\nstring) | null | undefined, name?: (/** The complete name of the contact or company */\nstring) | null | undefined, title?: (/** The title of the contact (Available when 'type' is 'contact') */\nstring) | null | undefined, forename?: (/** The forename of the contact (Available when 'type' is 'contact') */\nstring) | null | undefined, surname?: (/** The surname of the contact (Available when 'type' is 'contact') */\nstring) | null | undefined, dateOfBirth?: (/** The date of birth of the contact (Available when 'type' is 'contact') */\nstring) | null | undefined, type?: (/** The type of the contact (company/contact) */\nstring) | null | undefined, homePhone?: (/** The home phone number of the contact or company */\nstring) | null | undefined, workPhone?: (/** The work phone number of the contact or company */\nstring) | null | undefined, mobilePhone?: (/** The mobile phone number of the contact or company */\nstring) | null | undefined, email?: (/** The email address of the contact or company */\nstring) | null | undefined, marketingConsent?: (/** The marketing consent status of the contact (grant/deny/notAsked) */\nstring) | null | undefined, fromArchive?: (/** A flag denoting whether or not this relationship is archived */\nboolean) | null | undefined, primaryAddress?: (ApplicantContactAddressModel) | null | undefined, additionalContactDetails?: (/** A collection of additional contact details */\nArray<AdditionalContactDetailModel>) | null | undefined};",
  "src/schemas/applicantContactAddressModel.generated.tsx": "import { z } from 'zod'\n\nexport const applicantContactAddressModel = /** Representation of the physical address of a building or premise */\nz.object({buildingName: /** The building name */\nz.string().optional().nullable(), buildingNumber: /** The building number */\nz.string().optional().nullable(), line1: /** The first line of the address */\nz.string().optional().nullable(), line2: /** The second line of the address */\nz.string().optional().nullable(), line3: /** The third line of the address */\nz.string().optional().nullable(), line4: /** The fourth line of the address */\nz.string().optional().nullable(), postcode: /** The postcode */\nz.string().optional().nullable(), countryId: /** The ISO-3166 country code that the address resides within */\nz.string().optional().nullable()});\nexport type ApplicantContactAddressModel = /** Representation of the physical address of a building or premise */\n{buildingName?: (/** The building name */\nstring) | null | undefined, buildingNumber?: (/** The building number */\nstring) | null | undefined, line1?: (/** The first line of the address */\nstring) | null | undefined, line2?: (/** The second line of the address */\nstring) | null | undefined, line3?: (/** The third line of the address */\nstring) | null | undefined, line4?: (/** The fourth line of the address */\nstring) | null | undefined, postcode?: (/** The postcode */\nstring) | null | undefined, countryId?: (/** The ISO-3166 country code that the address resides within */\nstring) | null | undefined};",
  "src/schemas/additionalContactDetailModel.generated.tsx": "import { z } from 'zod'\n\nexport const additionalContactDetailModel = /** Representation of additional contact details */\nz.object({type: /** The type of contact detail */\nz.string().optional().nullable(), value: /** The contact detail */\nz.string().optional().nullable()});\nexport type AdditionalContactDetailModel = /** Representation of additional contact details */\n{type?: (/** The type of contact detail */\nstring) | null | undefined, value?: (/** The contact detail */\nstring) | null | undefined};",
  "src/schemas/pagingLinkModel.generated.tsx": "import { z } from 'zod'\n\nexport const pagingLinkModel = z.object({href: z.string().optional().nullable()});\nexport type PagingLinkModel = {href?: (string) | null | undefined};",
  "src/routes.generated.tsx": "import { ApplicantsTable } from '@/sections/Applicants/tables/ApplicantsTable.generated.tsx'\nimport { PrivateRouteWrapper } from '@/components/PrivateRouteWrapper'\nimport { CreateApplicants } from '@/sections/Applicants/forms/CreateApplicants.example.tsx'\nimport { ApplicantsIdRelationshipsTable } from '@/sections/Applicants/tables/ApplicantsIdRelationshipsTable.generated.tsx'\nimport { CreateApplicantsIdRelationships } from '@/sections/Applicants/forms/CreateApplicantsIdRelationships.example.tsx'\nimport { AreasTable } from '@/sections/Areas/tables/AreasTable.generated.tsx'\nimport { CreateAreas } from '@/sections/Areas/forms/CreateAreas.example.tsx'\nimport { AppointmentsTable } from '@/sections/Appointments/tables/AppointmentsTable.generated.tsx'\nimport { CreateAppointments } from '@/sections/Appointments/forms/CreateAppointments.example.tsx'\nimport { AppointmentsIdOpenHouseAttendeesTable } from '@/sections/Appointments/tables/AppointmentsIdOpenHouseAttendeesTable.generated.tsx'\nimport { CreateAppointmentsIdOpenHouseAttendees } from '@/sections/Appointments/forms/CreateAppointmentsIdOpenHouseAttendees.example.tsx'\nimport { CompaniesTable } from '@/sections/Companies/tables/CompaniesTable.generated.tsx'\nimport { CreateCompanies } from '@/sections/Companies/forms/CreateCompanies.example.tsx'\nimport { CompaniesIdRelationshipsTable } from '@/sections/Companies/tables/CompaniesIdRelationshipsTable.generated.tsx'\nimport { ContactsTable } from '@/sections/Contacts/tables/ContactsTable.generated.tsx'\nimport { CreateContacts } from '@/sections/Contacts/forms/CreateContacts.example.tsx'\nimport { ContactsIdRelationshipsTable } from '@/sections/Contacts/tables/ContactsIdRelationshipsTable.generated.tsx'\nimport { ContactsIdSubscriptionsTable } from '@/sections/Contacts/tables/ContactsIdSubscriptionsTable.generated.tsx'\nimport { ConveyancingTable } from '@/sections/Conveyancing/tables/ConveyancingTable.generated.tsx'\nimport { ConveyancingIdChainTable } from '@/sections/Conveyancing/tables/ConveyancingIdChainTable.generated.tsx'\nimport { CreateConveyancingIdDownward } from '@/sections/Conveyancing/forms/CreateConveyancingIdDownward.example.tsx'\nimport { CreateConveyancingIdUpward } from '@/sections/Conveyancing/forms/CreateConveyancingIdUpward.example.tsx'\nimport { DepartmentsTable } from '@/sections/Departments/tables/DepartmentsTable.generated.tsx'\nimport { DocumentsTable } from '@/sections/Documents/tables/DocumentsTable.generated.tsx'\nimport { CreateDocuments } from '@/sections/Documents/forms/CreateDocuments.example.tsx'\nimport { CreateDocumentsSignedUrl } from '@/sections/Documents/forms/CreateDocumentsSignedUrl.example.tsx'\nimport { EnquiriesTable } from '@/sections/Enquiries/tables/EnquiriesTable.generated.tsx'\nimport { CreateEnquiries } from '@/sections/Enquiries/forms/CreateEnquiries.example.tsx'\nimport { IdentityChecksTable } from '@/sections/IdentityChecks/tables/IdentityChecksTable.generated.tsx'\nimport { CreateIdentityChecks } from '@/sections/IdentityChecks/forms/CreateIdentityChecks.example.tsx'\nimport { CreateIdentityChecksSignedUrl } from '@/sections/IdentityChecks/forms/CreateIdentityChecksSignedUrl.example.tsx'\nimport { InvoicesTable } from '@/sections/Invoices/tables/InvoicesTable.generated.tsx'\nimport { InvoicesPaymentsTable } from '@/sections/Invoices/tables/InvoicesPaymentsTable.generated.tsx'\nimport { InvoicesCreditsTable } from '@/sections/Invoices/tables/InvoicesCreditsTable.generated.tsx'\nimport { InvoicesChargesTable } from '@/sections/Invoices/tables/InvoicesChargesTable.generated.tsx'\nimport { JournalEntriesTable } from '@/sections/JournalEntries/tables/JournalEntriesTable.generated.tsx'\nimport { CreateJournalEntries } from '@/sections/JournalEntries/forms/CreateJournalEntries.example.tsx'\nimport { JournalEntriesLandlordsTable } from '@/sections/JournalEntries/tables/JournalEntriesLandlordsTable.generated.tsx'\nimport { CreateJournalEntriesBulk } from '@/sections/JournalEntries/forms/CreateJournalEntriesBulk.example.tsx'\nimport { LandlordsTable } from '@/sections/Landlords/tables/LandlordsTable.generated.tsx'\nimport { CreateLandlords } from '@/sections/Landlords/forms/CreateLandlords.example.tsx'\nimport { LandlordsIdRelationshipsTable } from '@/sections/Landlords/tables/LandlordsIdRelationshipsTable.generated.tsx'\nimport { CreateLandlordsIdRelationships } from '@/sections/Landlords/forms/CreateLandlordsIdRelationships.example.tsx'\nimport { MetadataTable } from '@/sections/Metadata/tables/MetadataTable.generated.tsx'\nimport { CreateMetadata } from '@/sections/Metadata/forms/CreateMetadata.example.tsx'\nimport { MetadataMetadataSchemaTable } from '@/sections/MetadataSchema/tables/MetadataMetadataSchemaTable.generated.tsx'\nimport { CreateMetadataMetadataSchema } from '@/sections/MetadataSchema/forms/CreateMetadataMetadataSchema.example.tsx'\nimport { NegotiatorsTable } from '@/sections/Negotiators/tables/NegotiatorsTable.generated.tsx'\nimport { CreateNegotiators } from '@/sections/Negotiators/forms/CreateNegotiators.example.tsx'\nimport { CreateNotifications } from '@/sections/Notifications/forms/CreateNotifications.example.tsx'\nimport { OffersTable } from '@/sections/Offers/tables/OffersTable.generated.tsx'\nimport { CreateOffers } from '@/sections/Offers/forms/CreateOffers.example.tsx'\nimport { OfficesTable } from '@/sections/Offices/tables/OfficesTable.generated.tsx'\nimport { CreateOffices } from '@/sections/Offices/forms/CreateOffices.example.tsx'\nimport { PropertiesTable } from '@/sections/Properties/tables/PropertiesTable.generated.tsx'\nimport { CreateProperties } from '@/sections/Properties/forms/CreateProperties.example.tsx'\nimport { PropertiesIdCertificatesTable } from '@/sections/Properties/tables/PropertiesIdCertificatesTable.generated.tsx'\nimport { CreatePropertiesIdCertificates } from '@/sections/Properties/forms/CreatePropertiesIdCertificates.example.tsx'\nimport { PropertiesIdKeysTable } from '@/sections/Properties/tables/PropertiesIdKeysTable.generated.tsx'\nimport { CreatePropertiesIdKeys } from '@/sections/Properties/forms/CreatePropertiesIdKeys.example.tsx'\nimport { PropertiesIdKeysKeyIdMovementsTable } from '@/sections/Properties/tables/PropertiesIdKeysKeyIdMovementsTable.generated.tsx'\nimport { CreatePropertiesIdKeysKeyIdMovements } from '@/sections/Properties/forms/CreatePropertiesIdKeysKeyIdMovements.example.tsx'\nimport { PropertiesIdChecksTable } from '@/sections/Properties/tables/PropertiesIdChecksTable.generated.tsx'\nimport { CreatePropertiesIdChecks } from '@/sections/Properties/forms/CreatePropertiesIdChecks.example.tsx'\nimport { PropertiesCertificatesTable } from '@/sections/Properties/tables/PropertiesCertificatesTable.generated.tsx'\nimport { PropertiesIdAppraisalsTable } from '@/sections/Properties/tables/PropertiesIdAppraisalsTable.generated.tsx'\nimport { CreatePropertiesIdAppraisals } from '@/sections/Properties/forms/CreatePropertiesIdAppraisals.example.tsx'\nimport { PropertyImagesTable } from '@/sections/PropertyImages/tables/PropertyImagesTable.generated.tsx'\nimport { CreatePropertyImages } from '@/sections/PropertyImages/forms/CreatePropertyImages.example.tsx'\nimport { CreatePropertyImagesSignedUrl } from '@/sections/PropertyImages/forms/CreatePropertyImagesSignedUrl.example.tsx'\nimport { CreatePropertyImagesReindex } from '@/sections/PropertyImages/forms/CreatePropertyImagesReindex.example.tsx'\nimport { ReferralsTable } from '@/sections/Referrals/tables/ReferralsTable.generated.tsx'\nimport { CreateReferrals } from '@/sections/Referrals/forms/CreateReferrals.example.tsx'\nimport { ReferralsTypesTable } from '@/sections/Referrals/tables/ReferralsTypesTable.generated.tsx'\nimport { ResthooksTable } from '@/sections/RestHooks/tables/ResthooksTable.generated.tsx'\nimport { CreateResthooks } from '@/sections/RestHooks/forms/CreateResthooks.example.tsx'\nimport { SourcesTable } from '@/sections/Sources/tables/SourcesTable.generated.tsx'\nimport { CreateSources } from '@/sections/Sources/forms/CreateSources.example.tsx'\nimport { TasksTable } from '@/sections/Tasks/tables/TasksTable.generated.tsx'\nimport { CreateTasks } from '@/sections/Tasks/forms/CreateTasks.example.tsx'\nimport { TenanciesTable } from '@/sections/Tenancies/tables/TenanciesTable.generated.tsx'\nimport { CreateTenancies } from '@/sections/Tenancies/forms/CreateTenancies.example.tsx'\nimport { TenanciesIdRelationshipsTable } from '@/sections/Tenancies/tables/TenanciesIdRelationshipsTable.generated.tsx'\nimport { TenanciesIdChecksTable } from '@/sections/Tenancies/tables/TenanciesIdChecksTable.generated.tsx'\nimport { CreateTenanciesIdChecks } from '@/sections/Tenancies/forms/CreateTenanciesIdChecks.example.tsx'\nimport { TenanciesIdBreakClausesTable } from '@/sections/Tenancies/tables/TenanciesIdBreakClausesTable.generated.tsx'\nimport { CreateTenanciesIdBreakClauses } from '@/sections/Tenancies/forms/CreateTenanciesIdBreakClauses.example.tsx'\nimport { TenanciesIdAllowancesTable } from '@/sections/Tenancies/tables/TenanciesIdAllowancesTable.generated.tsx'\nimport { CreateTenanciesIdAllowances } from '@/sections/Tenancies/forms/CreateTenanciesIdAllowances.example.tsx'\nimport { TenanciesIdResponsibilitiesTable } from '@/sections/Tenancies/tables/TenanciesIdResponsibilitiesTable.generated.tsx'\nimport { CreateTenanciesIdResponsibilities } from '@/sections/Tenancies/forms/CreateTenanciesIdResponsibilities.example.tsx'\nimport { TenanciesIdRenewalNegotiationsTable } from '@/sections/Tenancies/tables/TenanciesIdRenewalNegotiationsTable.generated.tsx'\nimport { CreateTenanciesIdRenewalNegotiations } from '@/sections/Tenancies/forms/CreateTenanciesIdRenewalNegotiations.example.tsx'\nimport { TenanciesIdExtensionsTable } from '@/sections/Tenancies/tables/TenanciesIdExtensionsTable.generated.tsx'\nimport { TenanciesIdRenewalNegotiationsRenewalIdChecksTable } from '@/sections/Tenancies/tables/TenanciesIdRenewalNegotiationsRenewalIdChecksTable.generated.tsx'\nimport { CreateTenanciesIdRenewalNegotiationsRenewalIdChecks } from '@/sections/Tenancies/forms/CreateTenanciesIdRenewalNegotiationsRenewalIdChecks.example.tsx'\nimport { TransactionsTable } from '@/sections/Transactions/tables/TransactionsTable.generated.tsx'\nimport { TransactionsNominalAccountsTable } from '@/sections/Transactions/tables/TransactionsNominalAccountsTable.generated.tsx'\nimport { CreateTransactionsSupplierInvoices } from '@/sections/Transactions/forms/CreateTransactionsSupplierInvoices.example.tsx'\nimport { VendorsTable } from '@/sections/Vendors/tables/VendorsTable.generated.tsx'\nimport { VendorsIdRelationshipsTable } from '@/sections/Vendors/tables/VendorsIdRelationshipsTable.generated.tsx'\nimport { CreateVendorsIdRelationships } from '@/sections/Vendors/forms/CreateVendorsIdRelationships.example.tsx'\nimport { WorksOrdersTable } from '@/sections/WorksOrders/tables/WorksOrdersTable.generated.tsx'\nimport { CreateWorksOrders } from '@/sections/WorksOrders/forms/CreateWorksOrders.example.tsx'\nimport { WorksOrdersIdItemsTable } from '@/sections/WorksOrders/tables/WorksOrdersIdItemsTable.generated.tsx'\nimport { CreateWorksOrdersIdItems } from '@/sections/WorksOrders/forms/CreateWorksOrdersIdItems.example.tsx'\n\nexport const routes = [{\n      path: '/applicants/',\n      element: (\n        <PrivateRouteWrapper>\n          <ApplicantsTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/applicants/new',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateApplicants />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/applicants/:id/relationships',\n      element: (\n        <PrivateRouteWrapper>\n          <ApplicantsIdRelationshipsTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/applicants/:id/relationshipsnew',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateApplicantsIdRelationships />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/areas/',\n      element: (\n        <PrivateRouteWrapper>\n          <AreasTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/areas/new',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateAreas />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/appointments/',\n      element: (\n        <PrivateRouteWrapper>\n          <AppointmentsTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/appointments/new',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateAppointments />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/appointments/:id/openHouseAttendees',\n      element: (\n        <PrivateRouteWrapper>\n          <AppointmentsIdOpenHouseAttendeesTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/appointments/:id/openHouseAttendeesnew',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateAppointmentsIdOpenHouseAttendees />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/companies/',\n      element: (\n        <PrivateRouteWrapper>\n          <CompaniesTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/companies/new',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateCompanies />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/companies/:id/relationships',\n      element: (\n        <PrivateRouteWrapper>\n          <CompaniesIdRelationshipsTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/contacts/',\n      element: (\n        <PrivateRouteWrapper>\n          <ContactsTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/contacts/new',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateContacts />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/contacts/:id/relationships',\n      element: (\n        <PrivateRouteWrapper>\n          <ContactsIdRelationshipsTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/contacts/:id/subscriptions',\n      element: (\n        <PrivateRouteWrapper>\n          <ContactsIdSubscriptionsTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/conveyancing/',\n      element: (\n        <PrivateRouteWrapper>\n          <ConveyancingTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/conveyancing/:id/chain',\n      element: (\n        <PrivateRouteWrapper>\n          <ConveyancingIdChainTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/conveyancing/:id/downwardnew',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateConveyancingIdDownward />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/conveyancing/:id/upwardnew',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateConveyancingIdUpward />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/departments/',\n      element: (\n        <PrivateRouteWrapper>\n          <DepartmentsTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/documents/',\n      element: (\n        <PrivateRouteWrapper>\n          <DocumentsTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/documents/new',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateDocuments />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/documents/signedUrlnew',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateDocumentsSignedUrl />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/enquiries/',\n      element: (\n        <PrivateRouteWrapper>\n          <EnquiriesTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/enquiries/new',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateEnquiries />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/identityChecks/',\n      element: (\n        <PrivateRouteWrapper>\n          <IdentityChecksTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/identityChecks/new',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateIdentityChecks />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/identityChecks/signedUrlnew',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateIdentityChecksSignedUrl />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/invoices/',\n      element: (\n        <PrivateRouteWrapper>\n          <InvoicesTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/invoices/payments',\n      element: (\n        <PrivateRouteWrapper>\n          <InvoicesPaymentsTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/invoices/credits',\n      element: (\n        <PrivateRouteWrapper>\n          <InvoicesCreditsTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/invoices/charges',\n      element: (\n        <PrivateRouteWrapper>\n          <InvoicesChargesTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/journalEntries/',\n      element: (\n        <PrivateRouteWrapper>\n          <JournalEntriesTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/journalEntries/new',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateJournalEntries />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/journalEntries/landlords',\n      element: (\n        <PrivateRouteWrapper>\n          <JournalEntriesLandlordsTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/journalEntries/bulknew',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateJournalEntriesBulk />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/landlords/',\n      element: (\n        <PrivateRouteWrapper>\n          <LandlordsTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/landlords/new',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateLandlords />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/landlords/:id/relationships',\n      element: (\n        <PrivateRouteWrapper>\n          <LandlordsIdRelationshipsTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/landlords/:id/relationshipsnew',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateLandlordsIdRelationships />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/metadata/',\n      element: (\n        <PrivateRouteWrapper>\n          <MetadataTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/metadata/new',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateMetadata />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/metadata/metadataSchema',\n      element: (\n        <PrivateRouteWrapper>\n          <MetadataMetadataSchemaTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/metadata/metadataSchemanew',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateMetadataMetadataSchema />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/negotiators/',\n      element: (\n        <PrivateRouteWrapper>\n          <NegotiatorsTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/negotiators/new',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateNegotiators />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/notifications/new',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateNotifications />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/offers/',\n      element: (\n        <PrivateRouteWrapper>\n          <OffersTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/offers/new',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateOffers />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/offices/',\n      element: (\n        <PrivateRouteWrapper>\n          <OfficesTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/offices/new',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateOffices />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/properties/',\n      element: (\n        <PrivateRouteWrapper>\n          <PropertiesTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/properties/new',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateProperties />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/properties/:id/certificates',\n      element: (\n        <PrivateRouteWrapper>\n          <PropertiesIdCertificatesTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/properties/:id/certificatesnew',\n      element: (\n        <PrivateRouteWrapper>\n          <CreatePropertiesIdCertificates />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/properties/:id/keys',\n      element: (\n        <PrivateRouteWrapper>\n          <PropertiesIdKeysTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/properties/:id/keysnew',\n      element: (\n        <PrivateRouteWrapper>\n          <CreatePropertiesIdKeys />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/properties/:id/keys/:keyId/movements',\n      element: (\n        <PrivateRouteWrapper>\n          <PropertiesIdKeysKeyIdMovementsTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/properties/:id/keys/:keyId/movementsnew',\n      element: (\n        <PrivateRouteWrapper>\n          <CreatePropertiesIdKeysKeyIdMovements />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/properties/:id/checks',\n      element: (\n        <PrivateRouteWrapper>\n          <PropertiesIdChecksTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/properties/:id/checksnew',\n      element: (\n        <PrivateRouteWrapper>\n          <CreatePropertiesIdChecks />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/properties/certificates',\n      element: (\n        <PrivateRouteWrapper>\n          <PropertiesCertificatesTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/properties/:id/appraisals',\n      element: (\n        <PrivateRouteWrapper>\n          <PropertiesIdAppraisalsTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/properties/:id/appraisalsnew',\n      element: (\n        <PrivateRouteWrapper>\n          <CreatePropertiesIdAppraisals />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/propertyImages/',\n      element: (\n        <PrivateRouteWrapper>\n          <PropertyImagesTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/propertyImages/new',\n      element: (\n        <PrivateRouteWrapper>\n          <CreatePropertyImages />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/propertyImages/signedUrlnew',\n      element: (\n        <PrivateRouteWrapper>\n          <CreatePropertyImagesSignedUrl />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/propertyImages/reindexnew',\n      element: (\n        <PrivateRouteWrapper>\n          <CreatePropertyImagesReindex />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/referrals/',\n      element: (\n        <PrivateRouteWrapper>\n          <ReferralsTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/referrals/new',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateReferrals />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/referrals/types',\n      element: (\n        <PrivateRouteWrapper>\n          <ReferralsTypesTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/resthooks/',\n      element: (\n        <PrivateRouteWrapper>\n          <ResthooksTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/resthooks/new',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateResthooks />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/sources/',\n      element: (\n        <PrivateRouteWrapper>\n          <SourcesTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/sources/new',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateSources />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/tasks/',\n      element: (\n        <PrivateRouteWrapper>\n          <TasksTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/tasks/new',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateTasks />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/tenancies/',\n      element: (\n        <PrivateRouteWrapper>\n          <TenanciesTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/tenancies/new',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateTenancies />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/tenancies/:id/relationships',\n      element: (\n        <PrivateRouteWrapper>\n          <TenanciesIdRelationshipsTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/tenancies/:id/checks',\n      element: (\n        <PrivateRouteWrapper>\n          <TenanciesIdChecksTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/tenancies/:id/checksnew',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateTenanciesIdChecks />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/tenancies/:id/breakClauses',\n      element: (\n        <PrivateRouteWrapper>\n          <TenanciesIdBreakClausesTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/tenancies/:id/breakClausesnew',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateTenanciesIdBreakClauses />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/tenancies/:id/allowances',\n      element: (\n        <PrivateRouteWrapper>\n          <TenanciesIdAllowancesTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/tenancies/:id/allowancesnew',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateTenanciesIdAllowances />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/tenancies/:id/responsibilities',\n      element: (\n        <PrivateRouteWrapper>\n          <TenanciesIdResponsibilitiesTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/tenancies/:id/responsibilitiesnew',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateTenanciesIdResponsibilities />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/tenancies/:id/renewalNegotiations',\n      element: (\n        <PrivateRouteWrapper>\n          <TenanciesIdRenewalNegotiationsTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/tenancies/:id/renewalNegotiationsnew',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateTenanciesIdRenewalNegotiations />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/tenancies/:id/extensions',\n      element: (\n        <PrivateRouteWrapper>\n          <TenanciesIdExtensionsTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/tenancies/:id/renewalNegotiations/:renewalId/checks',\n      element: (\n        <PrivateRouteWrapper>\n          <TenanciesIdRenewalNegotiationsRenewalIdChecksTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/tenancies/:id/renewalNegotiations/:renewalId/checksnew',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateTenanciesIdRenewalNegotiationsRenewalIdChecks />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/transactions/',\n      element: (\n        <PrivateRouteWrapper>\n          <TransactionsTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/transactions/nominalAccounts',\n      element: (\n        <PrivateRouteWrapper>\n          <TransactionsNominalAccountsTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/transactions/supplierInvoicesnew',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateTransactionsSupplierInvoices />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/vendors/',\n      element: (\n        <PrivateRouteWrapper>\n          <VendorsTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/vendors/:id/relationships',\n      element: (\n        <PrivateRouteWrapper>\n          <VendorsIdRelationshipsTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/vendors/:id/relationshipsnew',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateVendorsIdRelationships />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/worksOrders/',\n      element: (\n        <PrivateRouteWrapper>\n          <WorksOrdersTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/worksOrders/new',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateWorksOrders />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/worksOrders/:id/items',\n      element: (\n        <PrivateRouteWrapper>\n          <WorksOrdersIdItemsTable />\n        </PrivateRouteWrapper>\n      )\n    }, {\n      path: '/worksOrders/:id/itemsnew',\n      element: (\n        <PrivateRouteWrapper>\n          <CreateWorksOrdersIdItems />\n        </PrivateRouteWrapper>\n      )\n    }];",
  "src/sections/Applicants/forms/CreateApplicants.example.tsx": "import { CreateApplicantsForm, fieldNames, CreateApplicantsFormFields } from '@/sections/Applicants/forms/CreateApplicantsForm.generated.tsx'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateApplicants = () => {\n      \n\n      \n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateApplicantsForm >\n              <FormLayout>\n                <CreateApplicantsFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateApplicantsForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Applicants/forms/CreateApplicantsForm.generated.tsx": "import { CreateApiApplicantsBody, createApiApplicantsBody } from '@/sections/Applicants/services/apiTypes.generated.ts'\nimport { createApplicantsConfig } from '@/sections/Applicants/config/createApplicantsConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiApplicants } from '@/sections/Applicants/services/useCreateApiApplicants.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateApplicantsFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiApplicantsBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createApplicantsConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateApplicantsFormProps = {children: ReactNode, defaultValues?: CreateApiApplicantsBody, onSuccess?: () => void};\nexport const CreateApplicantsForm = (props: CreateApplicantsFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiApplicantsBody>({\n        resolver: zodResolver(createApiApplicantsBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiApplicants()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiApplicantsBody>({marketingMode: true, currency: true, active: true, notes: true, statusId: true, sellingStatus: true, sellingPosition: true, lastCall: true, nextCall: true, departmentId: true, solicitorId: true, potentialClient: true, type: true, style: true, situation: true, parking: true, age: true, locality: true, specialFeatures: true, bedroomsMin: true, bedroomsMax: true, receptionsMin: true, receptionsMax: true, bathroomsMin: true, bathroomsMax: true, parkingSpacesMin: true, parkingSpacesMax: true, locationType: true, locationOptions: true, buying: true, renting: true, externalArea: true, internalArea: true, source: true, regional: true, officeIds: true, negotiatorIds: true, related: true, metadata: true});",
  "src/schemas/createApplicantModel.generated.tsx": "import { CreateApplicantBuyingModel, createApplicantBuyingModel } from '@/schemas/createApplicantBuyingModel.generated.tsx'\nimport { CreateApplicantRentingModel, createApplicantRentingModel } from '@/schemas/createApplicantRentingModel.generated.tsx'\nimport { ApplicantExternalAreaModel, applicantExternalAreaModel } from '@/schemas/applicantExternalAreaModel.generated.tsx'\nimport { ApplicantInternalAreaModel, applicantInternalAreaModel } from '@/schemas/applicantInternalAreaModel.generated.tsx'\nimport { ApplicantSourceModel, applicantSourceModel } from '@/schemas/applicantSourceModel.generated.tsx'\nimport { ApplicantRegionalModel, applicantRegionalModel } from '@/schemas/applicantRegionalModel.generated.tsx'\nimport { CreateApplicantContactRelationshipModel, createApplicantContactRelationshipModel } from '@/schemas/createApplicantContactRelationshipModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type CreateApplicantModel = /** Request body used to create a new applicant */\n{marketingMode: /** Indicates whether the applicant is look to buy or rent a property (buying/renting) */\nstring, currency?: (/** The ISO-4217 currency code that relates to monetary amounts specified by the applicant\r\nWhere not specified this will default to the customer's base currency */\nstring) | null | undefined, active?: (/** A flag determining whether or not the applicant is actively looking for a property */\nboolean) | null | undefined, notes?: (/** A free text field describing any adhoc buying or renting requirements */\nstring) | null | undefined, statusId?: (/** The status id of the applicant */\nstring) | null | undefined, sellingStatus?: (/** The applicant's selling status (preAppraisal/valuation/paidValuation/forSale/forSaleUnavailable/underOffer/underOfferUnavailable/reserved/exchanged/completed/soldExternally/withdrawn) */\nstring) | null | undefined, sellingPosition?: (/** The applicant's selling position (nothingToSell/renting/sellingWithUs/sellingWithOtherAgent/sellingPrivately/notYetOnMarket) */\nstring) | null | undefined, lastCall?: (/** The date when the applicant was last contacted */\nstring) | null | undefined, nextCall?: (/** The date when the applicant is next due to be contacted */\nstring) | null | undefined, departmentId: /** The unique identifier of the department the applicant is associated with. The applicant will only match to properties with the same values set. See the [Platform Glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information about departments */\nstring, solicitorId?: (/** The unique identifier of the solicitor associated to the applicant */\nstring) | null | undefined, potentialClient?: (/** A flag determining whether or not the applicant is a potential client */\nboolean) | null | undefined, type?: (/** The applicant's property type requirements (eg house, bungalow, land), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<string>) | null | undefined, style?: (/** The applicant's property style requirements (eg detached, semiDetached), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<string>) | null | undefined, situation?: (/** The applicant's requirements for other aspects of prospective properties - such as outside space - as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<string>) | null | undefined, parking?: (/** The applicant's parking requirements (eg garage), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<string>) | null | undefined, age?: (/** The applicant's property age requirements (eg new, period), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<string>) | null | undefined, locality?: (/** The applicant's general property location requirements (eg rural, townCity), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<string>) | null | undefined, specialFeatures?: (/** The applicant's special feature property requirements (eg Swimming Pool, Tennis Court), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<string>) | null | undefined, bedroomsMin?: (/** The minimum number of bedrooms the applicant requires */\nnumber) | null | undefined, bedroomsMax?: (/** The maximum number of bedrooms the applicant requires */\nnumber) | null | undefined, receptionsMin?: (/** The minimum number of reception rooms the applicant requires */\nnumber) | null | undefined, receptionsMax?: (/** The maximum number of reception rooms the applicant requires */\nnumber) | null | undefined, bathroomsMin?: (/** The minimum number of bathrooms the applicant requires */\nnumber) | null | undefined, bathroomsMax?: (/** The maximum number of bathrooms the applicant requires */\nnumber) | null | undefined, parkingSpacesMin?: (/** The minimum number of parking spaces the applicant requires */\nnumber) | null | undefined, parkingSpacesMax?: (/** The maximum number of parking spaces the applicant requires */\nnumber) | null | undefined, locationType?: (/** The applicant's location type (areas/addresses/none) */\nstring) | null | undefined, locationOptions?: (/** The applicant's location options */\nArray<string>) | null | undefined, buying?: (CreateApplicantBuyingModel) | null | undefined, renting?: (CreateApplicantRentingModel) | null | undefined, externalArea?: (ApplicantExternalAreaModel) | null | undefined, internalArea?: (ApplicantInternalAreaModel) | null | undefined, source?: (ApplicantSourceModel) | null | undefined, regional?: (ApplicantRegionalModel) | null | undefined, officeIds: /** A collection of unique identifiers of offices attached to the applicant. The first item in the collection is considered the primary office */\nArray<string>, negotiatorIds: /** A collection of unique identifiers of negotiators attached to the applicant. The first item in the collection is considered the primary negotiator */\nArray<string>, related: /** A collection of contacts and/or companies associated to the applicant. The first item in the collection is considered the primary relationship */\nArray<CreateApplicantContactRelationshipModel>, metadata?: (/** App specific metadata to set against the applicant */\nRecord<string, Record<string, never>>) | null | undefined};\nexport const createApplicantModel = /** Request body used to create a new applicant */\nz.object({marketingMode: /** Indicates whether the applicant is look to buy or rent a property (buying/renting) */\nz.string().min(1), currency: /** The ISO-4217 currency code that relates to monetary amounts specified by the applicant\r\nWhere not specified this will default to the customer's base currency */\nz.string().optional().nullable(), active: /** A flag determining whether or not the applicant is actively looking for a property */\nz.boolean().optional().nullable(), notes: /** A free text field describing any adhoc buying or renting requirements */\nz.string().optional().nullable(), statusId: /** The status id of the applicant */\nz.string().optional().nullable(), sellingStatus: /** The applicant's selling status (preAppraisal/valuation/paidValuation/forSale/forSaleUnavailable/underOffer/underOfferUnavailable/reserved/exchanged/completed/soldExternally/withdrawn) */\nz.string().optional().nullable(), sellingPosition: /** The applicant's selling position (nothingToSell/renting/sellingWithUs/sellingWithOtherAgent/sellingPrivately/notYetOnMarket) */\nz.string().optional().nullable(), lastCall: /** The date when the applicant was last contacted */\nz.string().optional().nullable(), nextCall: /** The date when the applicant is next due to be contacted */\nz.string().optional().nullable(), departmentId: /** The unique identifier of the department the applicant is associated with. The applicant will only match to properties with the same values set. See the [Platform Glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information about departments */\nz.string().min(1), solicitorId: /** The unique identifier of the solicitor associated to the applicant */\nz.string().optional().nullable(), potentialClient: /** A flag determining whether or not the applicant is a potential client */\nz.boolean().optional().nullable(), type: /** The applicant's property type requirements (eg house, bungalow, land), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(z.string().min(1)).optional().nullable(), style: /** The applicant's property style requirements (eg detached, semiDetached), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(z.string().min(1)).optional().nullable(), situation: /** The applicant's requirements for other aspects of prospective properties - such as outside space - as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(z.string().min(1)).optional().nullable(), parking: /** The applicant's parking requirements (eg garage), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(z.string().min(1)).optional().nullable(), age: /** The applicant's property age requirements (eg new, period), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(z.string().min(1)).optional().nullable(), locality: /** The applicant's general property location requirements (eg rural, townCity), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(z.string().min(1)).optional().nullable(), specialFeatures: /** The applicant's special feature property requirements (eg Swimming Pool, Tennis Court), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(z.string().min(1)).optional().nullable(), bedroomsMin: /** The minimum number of bedrooms the applicant requires */\nz.number().int().optional().nullable(), bedroomsMax: /** The maximum number of bedrooms the applicant requires */\nz.number().int().optional().nullable(), receptionsMin: /** The minimum number of reception rooms the applicant requires */\nz.number().int().optional().nullable(), receptionsMax: /** The maximum number of reception rooms the applicant requires */\nz.number().int().optional().nullable(), bathroomsMin: /** The minimum number of bathrooms the applicant requires */\nz.number().int().optional().nullable(), bathroomsMax: /** The maximum number of bathrooms the applicant requires */\nz.number().int().optional().nullable(), parkingSpacesMin: /** The minimum number of parking spaces the applicant requires */\nz.number().int().optional().nullable(), parkingSpacesMax: /** The maximum number of parking spaces the applicant requires */\nz.number().int().optional().nullable(), locationType: /** The applicant's location type (areas/addresses/none) */\nz.string().optional().nullable(), locationOptions: /** The applicant's location options */\nz.array(z.string().min(1)).optional().nullable(), buying: createApplicantBuyingModel.optional().nullable(), renting: createApplicantRentingModel.optional().nullable(), externalArea: applicantExternalAreaModel.optional().nullable(), internalArea: applicantInternalAreaModel.optional().nullable(), source: applicantSourceModel.optional().nullable(), regional: applicantRegionalModel.optional().nullable(), officeIds: /** A collection of unique identifiers of offices attached to the applicant. The first item in the collection is considered the primary office */\nz.array(z.string().min(1)), negotiatorIds: /** A collection of unique identifiers of negotiators attached to the applicant. The first item in the collection is considered the primary negotiator */\nz.array(z.string().min(1)), related: /** A collection of contacts and/or companies associated to the applicant. The first item in the collection is considered the primary relationship */\nz.array(createApplicantContactRelationshipModel), metadata: /** App specific metadata to set against the applicant */\nz.record(z.string(), z.object({})).optional().nullable()});",
  "src/schemas/createApplicantBuyingModel.generated.tsx": "import { ApplicantLeaseRemaining, applicantLeaseRemaining } from '@/schemas/applicantLeaseRemaining.generated.tsx'\nimport { z } from 'zod'\n\nexport type CreateApplicantBuyingModel = /** The details specific to applicants with a marketingMode of buying */\n{reasonId?: (/** The identifier of the applicant's buying reason */\nstring) | null | undefined, positionId?: (/** The identifier of the applicant's selling position */\nstring) | null | undefined, priceFrom?: (/** The lower bound of the applicant's budget. (Required when 'marketingMode' is 'buying' and 'priceTo' is not provided) */\nnumber) | null | undefined, priceTo?: (/** The upper bound of the applicant's budget. (Required when 'marketingMode' is 'buying' and 'priceFrom' is not provided) */\nnumber) | null | undefined, decoration?: (/** A list of property decoration requirements taken from the full listing of the associated department (unmodernised/fair/good/veryGood) */\nArray<string>) | null | undefined, tenure?: (/** A list of tenure requirements taken from the full listing of the associated department (freehold/leasehold/shareOfFreehold) */\nArray<string>) | null | undefined, mortgageExpiry?: (/** The date when the applicant's current mortgage expires/is due for renewal */\nDate) | null | undefined, leaseRemaining?: (ApplicantLeaseRemaining) | null | undefined};\nexport const createApplicantBuyingModel = /** The details specific to applicants with a marketingMode of buying */\nz.object({reasonId: /** The identifier of the applicant's buying reason */\nz.string().optional().nullable(), positionId: /** The identifier of the applicant's selling position */\nz.string().optional().nullable(), priceFrom: /** The lower bound of the applicant's budget. (Required when 'marketingMode' is 'buying' and 'priceTo' is not provided) */\nz.number().int().optional().nullable(), priceTo: /** The upper bound of the applicant's budget. (Required when 'marketingMode' is 'buying' and 'priceFrom' is not provided) */\nz.number().int().optional().nullable(), decoration: /** A list of property decoration requirements taken from the full listing of the associated department (unmodernised/fair/good/veryGood) */\nz.array(z.string().min(1)).optional().nullable(), tenure: /** A list of tenure requirements taken from the full listing of the associated department (freehold/leasehold/shareOfFreehold) */\nz.array(z.string().min(1)).optional().nullable(), mortgageExpiry: /** The date when the applicant's current mortgage expires/is due for renewal */\nz.string().pipe( z.coerce.date() ).optional().nullable(), leaseRemaining: applicantLeaseRemaining.optional().nullable()});",
  "src/schemas/createApplicantRentingModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateApplicantRentingModel = /** The details specific to applicants with a marketingMode of renting */\n{moveDate?: (/** The date the applicant is looking to move to a new property */\nstring) | null | undefined, term?: (/** The applicant's preferred letting term (long/short/any) */\nstring) | null | undefined, rentFrom?: (/** The lower bound of the applicant's budget. (Required when 'marketingMode' is 'renting' and 'rentTo' is 0) */\nnumber) | null | undefined, rentTo?: (/** The upper bound of the applicant's budget. (Required when 'marketingMode' is 'renting' and 'rentFrom' is 0) */\nnumber) | null | undefined, rentFrequency?: (/** The desired rent collection frequency specified by the applicant's budget (weekly/monthly/annually/fourWeekly). */\nstring) | null | undefined, furnishing?: (/** A list of property furnishing requirements taken from the full listing of the associated department */\nArray<string>) | null | undefined, positionId?: (/** The identifier of the applicant's renting position */\nstring) | null | undefined};\nexport const createApplicantRentingModel = /** The details specific to applicants with a marketingMode of renting */\nz.object({moveDate: /** The date the applicant is looking to move to a new property */\nz.string().optional().nullable(), term: /** The applicant's preferred letting term (long/short/any) */\nz.string().optional().nullable(), rentFrom: /** The lower bound of the applicant's budget. (Required when 'marketingMode' is 'renting' and 'rentTo' is 0) */\nz.number().optional().nullable(), rentTo: /** The upper bound of the applicant's budget. (Required when 'marketingMode' is 'renting' and 'rentFrom' is 0) */\nz.number().optional().nullable(), rentFrequency: /** The desired rent collection frequency specified by the applicant's budget (weekly/monthly/annually/fourWeekly). */\nz.string().optional().nullable(), furnishing: /** A list of property furnishing requirements taken from the full listing of the associated department */\nz.array(z.string().min(1)).optional().nullable(), positionId: /** The identifier of the applicant's renting position */\nz.string().optional().nullable()});",
  "src/schemas/createApplicantContactRelationshipModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateApplicantContactRelationshipModel = /** Request body used to create a relationship between an applicant and a contact or company */\n{associatedId: /** The unique identifier of the contact or company to create a relationship with */\nstring, associatedType?: (/** The type of relationship to create (contact/company) */\nstring) | null | undefined};\nexport const createApplicantContactRelationshipModel = /** Request body used to create a relationship between an applicant and a contact or company */\nz.object({associatedId: /** The unique identifier of the contact or company to create a relationship with */\nz.string().min(1), associatedType: /** The type of relationship to create (contact/company) */\nz.string().optional().nullable()});",
  "src/sections/Applicants/config/createApplicantsConfig.example.tsx": "import { CreateApiApplicantsBody } from '@/sections/Applicants/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { Switch } from '@/inputs/Switch.tsx'\nimport { DateInput } from '@/inputs/DateInput.tsx'\nimport { OfficesInput } from '@/sections/Offices/inputs/OfficesInput.generated.tsx'\nimport { NegotiatorsInput } from '@/sections/Negotiators/inputs/NegotiatorsInput.generated.tsx'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createApplicantsConfig: ModelConfig<CreateApiApplicantsBody> = {marketingMode: {\n      key: 'marketingMode',\n      label: 'marketingMode',\n      defaultValue: '',\n      placeholder: 'marketingMode',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, currency: {\n      key: 'currency',\n      label: 'currency',\n      defaultValue: '',\n      placeholder: 'currency',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, active: {\n      key: 'active',\n      label: 'active',\n      defaultValue: false,\n      placeholder: 'active',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><Switch {...props} /></InputWrap>\n    }, notes: {\n      key: 'notes',\n      label: 'notes',\n      defaultValue: '',\n      placeholder: 'notes',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, statusId: {\n      key: 'statusId',\n      label: 'statusId',\n      defaultValue: '',\n      placeholder: 'statusId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, sellingStatus: {\n      key: 'sellingStatus',\n      label: 'sellingStatus',\n      defaultValue: '',\n      placeholder: 'sellingStatus',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, sellingPosition: {\n      key: 'sellingPosition',\n      label: 'sellingPosition',\n      defaultValue: '',\n      placeholder: 'sellingPosition',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, lastCall: {\n      key: 'lastCall',\n      label: 'lastCall',\n      defaultValue: null,\n      placeholder: 'lastCall',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><DateInput {...props} /></InputWrap>\n    }, nextCall: {\n      key: 'nextCall',\n      label: 'nextCall',\n      defaultValue: null,\n      placeholder: 'nextCall',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><DateInput {...props} /></InputWrap>\n    }, departmentId: {\n      key: 'departmentId',\n      label: 'departmentId',\n      defaultValue: '',\n      placeholder: 'departmentId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, solicitorId: {\n      key: 'solicitorId',\n      label: 'solicitorId',\n      defaultValue: '',\n      placeholder: 'solicitorId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, potentialClient: {\n      key: 'potentialClient',\n      label: 'potentialClient',\n      defaultValue: false,\n      placeholder: 'potentialClient',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><Switch {...props} /></InputWrap>\n    }, type: {\n      key: 'type',\n      label: 'type',\n      defaultValue: [],\n      placeholder: 'type',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, style: {\n      key: 'style',\n      label: 'style',\n      defaultValue: [],\n      placeholder: 'style',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, situation: {\n      key: 'situation',\n      label: 'situation',\n      defaultValue: [],\n      placeholder: 'situation',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, parking: {\n      key: 'parking',\n      label: 'parking',\n      defaultValue: [],\n      placeholder: 'parking',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, age: {\n      key: 'age',\n      label: 'age',\n      defaultValue: [],\n      placeholder: 'age',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, locality: {\n      key: 'locality',\n      label: 'locality',\n      defaultValue: [],\n      placeholder: 'locality',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, specialFeatures: {\n      key: 'specialFeatures',\n      label: 'specialFeatures',\n      defaultValue: [],\n      placeholder: 'specialFeatures',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, bedroomsMin: {\n      key: 'bedroomsMin',\n      label: 'bedroomsMin',\n      defaultValue: null,\n      placeholder: 'bedroomsMin',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, bedroomsMax: {\n      key: 'bedroomsMax',\n      label: 'bedroomsMax',\n      defaultValue: null,\n      placeholder: 'bedroomsMax',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, receptionsMin: {\n      key: 'receptionsMin',\n      label: 'receptionsMin',\n      defaultValue: null,\n      placeholder: 'receptionsMin',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, receptionsMax: {\n      key: 'receptionsMax',\n      label: 'receptionsMax',\n      defaultValue: null,\n      placeholder: 'receptionsMax',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, bathroomsMin: {\n      key: 'bathroomsMin',\n      label: 'bathroomsMin',\n      defaultValue: null,\n      placeholder: 'bathroomsMin',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, bathroomsMax: {\n      key: 'bathroomsMax',\n      label: 'bathroomsMax',\n      defaultValue: null,\n      placeholder: 'bathroomsMax',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, parkingSpacesMin: {\n      key: 'parkingSpacesMin',\n      label: 'parkingSpacesMin',\n      defaultValue: null,\n      placeholder: 'parkingSpacesMin',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, parkingSpacesMax: {\n      key: 'parkingSpacesMax',\n      label: 'parkingSpacesMax',\n      defaultValue: null,\n      placeholder: 'parkingSpacesMax',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, locationType: {\n      key: 'locationType',\n      label: 'locationType',\n      defaultValue: '',\n      placeholder: 'locationType',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, locationOptions: {\n      key: 'locationOptions',\n      label: 'locationOptions',\n      defaultValue: [],\n      placeholder: 'locationOptions',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, buying: {\n      key: 'buying',\n      label: 'buying',\n      defaultValue: null,\n      placeholder: 'buying',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, renting: {\n      key: 'renting',\n      label: 'renting',\n      defaultValue: null,\n      placeholder: 'renting',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, externalArea: {\n      key: 'externalArea',\n      label: 'externalArea',\n      defaultValue: null,\n      placeholder: 'externalArea',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, internalArea: {\n      key: 'internalArea',\n      label: 'internalArea',\n      defaultValue: null,\n      placeholder: 'internalArea',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, source: {\n      key: 'source',\n      label: 'source',\n      defaultValue: null,\n      placeholder: 'source',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, regional: {\n      key: 'regional',\n      label: 'regional',\n      defaultValue: null,\n      placeholder: 'regional',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, officeIds: {\n      key: 'officeIds',\n      label: 'officeIds',\n      defaultValue: [],\n      placeholder: 'officeIds',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><OfficesInput {...props} /></InputWrap>\n    }, negotiatorIds: {\n      key: 'negotiatorIds',\n      label: 'negotiatorIds',\n      defaultValue: [],\n      placeholder: 'negotiatorIds',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><NegotiatorsInput {...props} /></InputWrap>\n    }, related: {\n      key: 'related',\n      label: 'related',\n      defaultValue: [],\n      placeholder: 'related',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, metadata: {\n      key: 'metadata',\n      label: 'metadata',\n      defaultValue: null,\n      placeholder: 'metadata',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/Offices/inputs/OfficesInput.generated.tsx": "import { useGetApiOffices } from '@/sections/Offices/services/useGetApiOffices.generated.ts'\nimport { FieldValues, useFormContext, Controller } from 'react-hook-form'\nimport { ContextInputProps, KeyPath, Option } from '@/components/ModelRuntimeConfig'\nimport { InputError, InputGroup, MultiSelectInput } from '@reapit/elements'\nimport { useState } from 'react'\n\nexport const OfficesInput = <Model extends FieldValues, Key extends KeyPath<Model>>({\n  fieldName,\n  fieldConfig,\n}: ContextInputProps<Model, Key>) => {\n  const { icon, label, placeholder } = fieldConfig\n\n  const [queryText, setQueryText] = useState('')\n\n  const response = useGetApiOffices({ name: queryText })\n\n  const { control } = useFormContext<Model>()\n\n  return (\n    <>\n      <InputGroup\n        onChange={(event) => setQueryText(event.target.value)}\n        icon={icon}\n        placeholder={placeholder}\n        label={label}\n      />\n      <Controller\n        control={control}\n        name={fieldName}\n        render={({ field, fieldState }) => (\n          <>\n            <MultiSelectInput\n              id={fieldName}\n              {...field}\n              value={field.value?.join(',') ?? ''}\n              onChange={(event) => field.onChange(event.target.value.split(','))}\n              options={\n                response?.data?._embedded\n                  ?.filter((option): option is Option => Boolean(option.id))\n                  ?.map(({ id }) => ({ value: id, name: id })) ?? []\n              }\n            />\n            {fieldState.error?.message && <InputError message={fieldState.error.message} />}\n          </>\n        )}\n      />\n    </>\n  )\n};",
  "src/sections/Offices/services/useGetApiOffices.generated.ts": "import { getApiOfficesResponse } from '@/sections/Offices/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiOfficesFnArgs = {pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, sortBy?: (string) | null | undefined, embed?: (Array<'negotiators'>) | null | undefined, id?: (Array<string>) | null | undefined, address?: (string) | null | undefined, name?: (string) | null | undefined, region?: (string) | null | undefined, active?: (boolean) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, metadata?: (Array<string>) | null | undefined, extrasField?: (Array<string>) | null | undefined};\nexport const getApiOfficesFn = async ({pageSize, pageNumber, sortBy, embed, id, address, name, region, active, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata, extrasField}: GetApiOfficesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/offices/${querySerialiser({args:{pageSize, pageNumber, sortBy, embed, id, address, name, region, active, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata, extrasField}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiOfficesResponse.parse(data)\n    };\nexport const useGetApiOffices = ({pageSize, pageNumber, sortBy, embed, id, address, name, region, active, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata, extrasField}: GetApiOfficesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Offices', pageSize, pageNumber, sortBy, embed, id, address, name, region, active, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata, extrasField],\n        queryFn: () => getApiOfficesFn({pageSize, pageNumber, sortBy, embed, id, address, name, region, active, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata, extrasField}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Offices/services/apiTypes.generated.ts": "import { officeModelPagedResult } from '@/schemas/officeModelPagedResult.generated.tsx'\nimport { CreateOfficeModel, createOfficeModel } from '@/schemas/createOfficeModel.generated.tsx'\nimport { z } from 'zod'\nimport { officeModel } from '@/schemas/officeModel.generated.tsx'\n\nexport const getApiOfficesResponse = officeModelPagedResult;\nexport type CreateApiOfficesBody = CreateOfficeModel;\nexport const createApiOfficesBody = createOfficeModel;\nexport const createApiOfficesResponse = z.void();\nexport const getApiOfficesIdResponse = officeModel;\nexport const patchApiOfficesIdResponse = z.void();",
  "src/schemas/officeModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { officeModel, OfficeModel } from '@/schemas/officeModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const officeModelPagedResult = z.object({_embedded: z.array(officeModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type OfficeModelPagedResult = {_embedded?: (Array<OfficeModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/officeModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\nimport { officeAddressModel, OfficeAddressModel } from '@/schemas/officeAddressModel.generated.tsx'\nimport { additionalOfficeContactDetailsModel, AdditionalOfficeContactDetailsModel } from '@/schemas/additionalOfficeContactDetailsModel.generated.tsx'\n\nexport const officeModel = /** Representation of an office */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the office */\nz.string().optional().nullable(), created: /** The date and time when the office was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the office was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), name: /** The name of the office */\nz.string().optional().nullable(), manager: /** The name of the office manager */\nz.string().optional().nullable(), active: /** A flag denoting whether or not this office is active */\nz.boolean().optional().nullable(), region: /** The region that the office is in */\nz.string().optional().nullable(), address: officeAddressModel.optional().nullable(), additionalContactDetails: /** A collection of additional contact details */\nz.array(additionalOfficeContactDetailsModel).optional().nullable(), workPhone: /** The work phone number of the office */\nz.string().optional().nullable(), email: /** The email address of the office */\nz.string().optional().nullable(), metadata: /** App specific metadata that has been set against the office */\nz.record(z.string(), z.object({})).optional().nullable(), _eTag: /** The ETag for the current version of the office. Used for managing update concurrency */\nz.string().optional().nullable(), extrasField: /** The requested extras fields */\nz.record(z.string(), z.object({})).optional().nullable()});\nexport type OfficeModel = /** Representation of an office */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the office */\nstring) | null | undefined, created?: (/** The date and time when the office was created */\nDate) | null | undefined, modified?: (/** The date and time when the office was last modified */\nDate) | null | undefined, name?: (/** The name of the office */\nstring) | null | undefined, manager?: (/** The name of the office manager */\nstring) | null | undefined, active?: (/** A flag denoting whether or not this office is active */\nboolean) | null | undefined, region?: (/** The region that the office is in */\nstring) | null | undefined, address?: (OfficeAddressModel) | null | undefined, additionalContactDetails?: (/** A collection of additional contact details */\nArray<AdditionalOfficeContactDetailsModel>) | null | undefined, workPhone?: (/** The work phone number of the office */\nstring) | null | undefined, email?: (/** The email address of the office */\nstring) | null | undefined, metadata?: (/** App specific metadata that has been set against the office */\nRecord<string, Record<string, never>>) | null | undefined, _eTag?: (/** The ETag for the current version of the office. Used for managing update concurrency */\nstring) | null | undefined, extrasField?: (/** The requested extras fields */\nRecord<string, Record<string, never>>) | null | undefined};",
  "src/schemas/officeAddressModel.generated.tsx": "import { z } from 'zod'\nimport { officeAddressGeolocationModel, OfficeAddressGeolocationModel } from '@/schemas/officeAddressGeolocationModel.generated.tsx'\n\nexport const officeAddressModel = /** Representation of the physical address of a building or premise */\nz.object({buildingName: /** The building name */\nz.string().optional().nullable(), buildingNumber: /** The building number */\nz.string().optional().nullable(), line1: /** The first line of the address */\nz.string().optional().nullable(), line2: /** The second line of the address */\nz.string().optional().nullable(), line3: /** The third line of the address */\nz.string().optional().nullable(), line4: /** The fourth line of the address */\nz.string().optional().nullable(), postcode: /** The postcode */\nz.string().optional().nullable(), countryId: /** The ISO-3166 country code that the address resides within */\nz.string().optional().nullable(), geolocation: officeAddressGeolocationModel.optional().nullable()});\nexport type OfficeAddressModel = /** Representation of the physical address of a building or premise */\n{buildingName?: (/** The building name */\nstring) | null | undefined, buildingNumber?: (/** The building number */\nstring) | null | undefined, line1?: (/** The first line of the address */\nstring) | null | undefined, line2?: (/** The second line of the address */\nstring) | null | undefined, line3?: (/** The third line of the address */\nstring) | null | undefined, line4?: (/** The fourth line of the address */\nstring) | null | undefined, postcode?: (/** The postcode */\nstring) | null | undefined, countryId?: (/** The ISO-3166 country code that the address resides within */\nstring) | null | undefined, geolocation?: (OfficeAddressGeolocationModel) | null | undefined};",
  "src/schemas/officeAddressGeolocationModel.generated.tsx": "import { z } from 'zod'\n\nexport const officeAddressGeolocationModel = /** Representation of the geographical location of an address using coordinates */\nz.object({latitude: /** The latitude coordinate of the coordinate pair */\nz.number().optional().nullable(), longitude: /** The longitude coordinate of the coordinate pair */\nz.number().optional().nullable()});\nexport type OfficeAddressGeolocationModel = /** Representation of the geographical location of an address using coordinates */\n{latitude?: (/** The latitude coordinate of the coordinate pair */\nnumber) | null | undefined, longitude?: (/** The longitude coordinate of the coordinate pair */\nnumber) | null | undefined};",
  "src/schemas/additionalOfficeContactDetailsModel.generated.tsx": "import { additionalContactDetailModel, AdditionalContactDetailModel } from '@/schemas/additionalContactDetailModel.generated.tsx'\n\nexport const additionalOfficeContactDetailsModel = additionalContactDetailModel;\nexport type AdditionalOfficeContactDetailsModel = AdditionalContactDetailModel;",
  "src/sections/Negotiators/inputs/NegotiatorsInput.generated.tsx": "import { useGetApiNegotiators } from '@/sections/Negotiators/services/useGetApiNegotiators.generated.ts'\nimport { FieldValues, useFormContext, Controller } from 'react-hook-form'\nimport { ContextInputProps, KeyPath, Option } from '@/components/ModelRuntimeConfig'\nimport { InputError, InputGroup, MultiSelectInput } from '@reapit/elements'\nimport { useState } from 'react'\n\nexport const NegotiatorsInput = <Model extends FieldValues, Key extends KeyPath<Model>>({\n  fieldName,\n  fieldConfig,\n}: ContextInputProps<Model, Key>) => {\n  const { icon, label, placeholder } = fieldConfig\n\n  const [queryText, setQueryText] = useState('')\n\n  const response = useGetApiNegotiators({ name: queryText })\n\n  const { control } = useFormContext<Model>()\n\n  return (\n    <>\n      <InputGroup\n        onChange={(event) => setQueryText(event.target.value)}\n        icon={icon}\n        placeholder={placeholder}\n        label={label}\n      />\n      <Controller\n        control={control}\n        name={fieldName}\n        render={({ field, fieldState }) => (\n          <>\n            <MultiSelectInput\n              id={fieldName}\n              {...field}\n              value={field.value?.join(',') ?? ''}\n              onChange={(event) => field.onChange(event.target.value.split(','))}\n              options={\n                response?.data?._embedded\n                  ?.filter((option): option is Option => Boolean(option.id))\n                  ?.map(({ id }) => ({ value: id, name: id })) ?? []\n              }\n            />\n            {fieldState.error?.message && <InputError message={fieldState.error.message} />}\n          </>\n        )}\n      />\n    </>\n  )\n};",
  "src/sections/Negotiators/services/useGetApiNegotiators.generated.ts": "import { getApiNegotiatorsResponse } from '@/sections/Negotiators/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiNegotiatorsFnArgs = {pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, sortBy?: (string) | null | undefined, embed?: (Array<'office'>) | null | undefined, id?: (Array<string>) | null | undefined, officeId?: (Array<string>) | null | undefined, email?: (string) | null | undefined, name?: (string) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, active?: (boolean) | null | undefined, metadata?: (Array<string>) | null | undefined};\nexport const getApiNegotiatorsFn = async ({pageSize, pageNumber, sortBy, embed, id, officeId, email, name, createdFrom, createdTo, modifiedFrom, modifiedTo, active, metadata}: GetApiNegotiatorsFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/negotiators/${querySerialiser({args:{pageSize, pageNumber, sortBy, embed, id, officeId, email, name, createdFrom, createdTo, modifiedFrom, modifiedTo, active, metadata}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiNegotiatorsResponse.parse(data)\n    };\nexport const useGetApiNegotiators = ({pageSize, pageNumber, sortBy, embed, id, officeId, email, name, createdFrom, createdTo, modifiedFrom, modifiedTo, active, metadata}: GetApiNegotiatorsFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Negotiators', pageSize, pageNumber, sortBy, embed, id, officeId, email, name, createdFrom, createdTo, modifiedFrom, modifiedTo, active, metadata],\n        queryFn: () => getApiNegotiatorsFn({pageSize, pageNumber, sortBy, embed, id, officeId, email, name, createdFrom, createdTo, modifiedFrom, modifiedTo, active, metadata}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Negotiators/services/apiTypes.generated.ts": "import { negotiatorModelPagedResult } from '@/schemas/negotiatorModelPagedResult.generated.tsx'\nimport { CreateNegotiatorModel, createNegotiatorModel } from '@/schemas/createNegotiatorModel.generated.tsx'\nimport { z } from 'zod'\nimport { negotiatorModel } from '@/schemas/negotiatorModel.generated.tsx'\n\nexport const getApiNegotiatorsResponse = negotiatorModelPagedResult;\nexport type CreateApiNegotiatorsBody = CreateNegotiatorModel;\nexport const createApiNegotiatorsBody = createNegotiatorModel;\nexport const createApiNegotiatorsResponse = z.void();\nexport const getApiNegotiatorsIdResponse = negotiatorModel;\nexport const patchApiNegotiatorsIdResponse = z.void();",
  "src/schemas/negotiatorModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { negotiatorModel, NegotiatorModel } from '@/schemas/negotiatorModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const negotiatorModelPagedResult = z.object({_embedded: z.array(negotiatorModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type NegotiatorModelPagedResult = {_embedded?: (Array<NegotiatorModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/negotiatorModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\nimport { additionalContactDetailModel, AdditionalContactDetailModel } from '@/schemas/additionalContactDetailModel.generated.tsx'\n\nexport const negotiatorModel = /** Representation of a negotiator */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the negotiator */\nz.string().optional().nullable(), created: /** The date and time when the negotiator was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the negotiator was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), name: /** The name of the negotiator */\nz.string().optional().nullable(), jobTitle: /** The job title of the negotiator */\nz.string().optional().nullable(), officeId: /** The unique identifier of the office that the negotiator is attached to */\nz.string().optional().nullable(), workPhone: /** The work phone number of the negotiator */\nz.string().optional().nullable(), mobilePhone: /** The mobile phone number of the negotiator */\nz.string().optional().nullable(), email: /** The email address of the negotiator */\nz.string().optional().nullable(), profileImageUrl: /** The URL of the optional negotiator profile image */\nz.string().optional().nullable(), active: /** A flag determining whether or not the negotiator is active */\nz.boolean().optional().nullable(), diaryNegotiatorIds: /** The identifiers of other negotiators whose diaries should be displayed to this negotiator when rendering diary/calendar view components in applicants */\nz.array(z.string().min(1)).optional().nullable(), diaryOfficeIds: /** The identifiers of other offices whose diaries should be displayed to this negotiator when rendering diary/calendar view components in applicants */\nz.array(z.string().min(1)).optional().nullable(), additionalContactDetails: /** A collection of additional contact details */\nz.array(additionalContactDetailModel).optional().nullable(), metadata: /** App specific metadata that has been set against the negotiator */\nz.record(z.string(), z.object({})).optional().nullable(), _eTag: /** The ETag for the current version of the negotiator. Used for managing update concurrency */\nz.string().optional().nullable()});\nexport type NegotiatorModel = /** Representation of a negotiator */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the negotiator */\nstring) | null | undefined, created?: (/** The date and time when the negotiator was created */\nDate) | null | undefined, modified?: (/** The date and time when the negotiator was last modified */\nDate) | null | undefined, name?: (/** The name of the negotiator */\nstring) | null | undefined, jobTitle?: (/** The job title of the negotiator */\nstring) | null | undefined, officeId?: (/** The unique identifier of the office that the negotiator is attached to */\nstring) | null | undefined, workPhone?: (/** The work phone number of the negotiator */\nstring) | null | undefined, mobilePhone?: (/** The mobile phone number of the negotiator */\nstring) | null | undefined, email?: (/** The email address of the negotiator */\nstring) | null | undefined, profileImageUrl?: (/** The URL of the optional negotiator profile image */\nstring) | null | undefined, active?: (/** A flag determining whether or not the negotiator is active */\nboolean) | null | undefined, diaryNegotiatorIds?: (/** The identifiers of other negotiators whose diaries should be displayed to this negotiator when rendering diary/calendar view components in applicants */\nArray<string>) | null | undefined, diaryOfficeIds?: (/** The identifiers of other offices whose diaries should be displayed to this negotiator when rendering diary/calendar view components in applicants */\nArray<string>) | null | undefined, additionalContactDetails?: (/** A collection of additional contact details */\nArray<AdditionalContactDetailModel>) | null | undefined, metadata?: (/** App specific metadata that has been set against the negotiator */\nRecord<string, Record<string, never>>) | null | undefined, _eTag?: (/** The ETag for the current version of the negotiator. Used for managing update concurrency */\nstring) | null | undefined};",
  "src/sections/Applicants/services/useCreateApiApplicants.generated.ts": "import { CreateApplicantModel } from '@/schemas/createApplicantModel.generated.tsx'\nimport { createApiApplicantsResponse } from '@/sections/Applicants/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiApplicantsFnArgs = {body: CreateApplicantModel};\nexport const createApiApplicantsFn = async ({body}: CreateApiApplicantsFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/applicants/${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiApplicantsResponse.parse(data)\n    };\nexport const useCreateApiApplicants = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiApplicantsFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Applicants']})\n        }\n      })\n    };",
  "src/sections/Applicants/tables/ApplicantsIdRelationshipsTable.generated.tsx": "import { useGetApiApplicantsIdRelationships } from '@/sections/Applicants/services/useGetApiApplicantsIdRelationships.generated.ts'\nimport { useState } from 'react'\nimport { useParams, useNavigate } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\n\nexport type UseApplicantsIdRelationshipsTableArgs = {id: string};\nexport const useApplicantsIdRelationshipsTable = (args: UseApplicantsIdRelationshipsTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiApplicantsIdRelationships({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const ApplicantsIdRelationshipsTable = () => {\n  const {id} = useParams()\n    \n    invariant(id, 'Missing id param')\n    \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useApplicantsIdRelationshipsTable({id}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Applicants',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New applicantsIdRelationshipsTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/applicants/${id}/relationships/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Applicants/services/useGetApiApplicantsIdRelationships.generated.ts": "import { getApiApplicantsIdRelationshipsResponse } from '@/sections/Applicants/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiApplicantsIdRelationshipsFnArgs = {id: string, pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined};\nexport const getApiApplicantsIdRelationshipsFn = async ({id, pageSize, pageNumber}: GetApiApplicantsIdRelationshipsFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/applicants/${id}/relationships${querySerialiser({args:{pageSize, pageNumber}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiApplicantsIdRelationshipsResponse.parse(data)\n    };\nexport const useGetApiApplicantsIdRelationships = ({id, pageSize, pageNumber}: GetApiApplicantsIdRelationshipsFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Applicants', id, pageSize, pageNumber],\n        queryFn: () => getApiApplicantsIdRelationshipsFn({id, pageSize, pageNumber}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/schemas/applicantContactRelationshipModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { applicantContactRelationshipModel, ApplicantContactRelationshipModel } from '@/schemas/applicantContactRelationshipModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const applicantContactRelationshipModelPagedResult = z.object({_embedded: z.array(applicantContactRelationshipModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type ApplicantContactRelationshipModelPagedResult = {_embedded?: (Array<ApplicantContactRelationshipModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/applicantContactRelationshipModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\n\nexport const applicantContactRelationshipModel = /** Representation of a relationship between an applicant and a contact or company */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the applicant relationship */\nz.string().optional().nullable(), created: /** The date and time when the relationship was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the relationship was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), applicantId: /** The unique identifier of the applicant */\nz.string().optional().nullable(), associatedType: /** The type of related entity (contact/company) */\nz.string().optional().nullable(), associatedId: /** The unique identifier of the related contact or company */\nz.string().optional().nullable(), isMain: /** A flag denoting whether or not this relationship should be regarded as the main relationship for the parent applicant entity */\nz.boolean().optional().nullable(), fromArchive: /** A flag denoting whether or not this relationship is archived */\nz.boolean().optional().nullable()});\nexport type ApplicantContactRelationshipModel = /** Representation of a relationship between an applicant and a contact or company */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the applicant relationship */\nstring) | null | undefined, created?: (/** The date and time when the relationship was created */\nDate) | null | undefined, modified?: (/** The date and time when the relationship was last modified */\nDate) | null | undefined, applicantId?: (/** The unique identifier of the applicant */\nstring) | null | undefined, associatedType?: (/** The type of related entity (contact/company) */\nstring) | null | undefined, associatedId?: (/** The unique identifier of the related contact or company */\nstring) | null | undefined, isMain?: (/** A flag denoting whether or not this relationship should be regarded as the main relationship for the parent applicant entity */\nboolean) | null | undefined, fromArchive?: (/** A flag denoting whether or not this relationship is archived */\nboolean) | null | undefined};",
  "src/sections/Applicants/forms/CreateApplicantsIdRelationships.example.tsx": "import { CreateApplicantsIdRelationshipsForm, fieldNames, CreateApplicantsIdRelationshipsFormFields } from '@/sections/Applicants/forms/CreateApplicantsIdRelationshipsForm.generated.tsx'\nimport { useParams } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateApplicantsIdRelationships = () => {\n      const { id } = useParams()\n\n      invariant(id, 'Expected id to be defined')\n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateApplicantsIdRelationshipsForm id={id}>\n              <FormLayout>\n                <CreateApplicantsIdRelationshipsFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateApplicantsIdRelationshipsForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Applicants/forms/CreateApplicantsIdRelationshipsForm.generated.tsx": "import { CreateApiApplicantsIdRelationshipsBody, createApiApplicantsIdRelationshipsBody } from '@/sections/Applicants/services/apiTypes.generated.ts'\nimport { createApplicantsIdRelationshipsConfig } from '@/sections/Applicants/config/createApplicantsIdRelationshipsConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiApplicantsIdRelationships } from '@/sections/Applicants/services/useCreateApiApplicantsIdRelationships.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateApplicantsIdRelationshipsFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiApplicantsIdRelationshipsBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createApplicantsIdRelationshipsConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateApplicantsIdRelationshipsFormProps = {id: string, children: ReactNode, defaultValues?: CreateApiApplicantsIdRelationshipsBody, onSuccess?: () => void};\nexport const CreateApplicantsIdRelationshipsForm = (props: CreateApplicantsIdRelationshipsFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiApplicantsIdRelationshipsBody>({\n        resolver: zodResolver(createApiApplicantsIdRelationshipsBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiApplicantsIdRelationships()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiApplicantsIdRelationshipsBody>({associatedId: true, associatedType: true, isMain: true});",
  "src/schemas/insertApplicantContactRelationshipModel.generated.tsx": "import { z } from 'zod'\n\nexport type InsertApplicantContactRelationshipModel = /** Request body used to create or update a relationship between an applicant and a contact or company */\n{associatedId?: (/** The unique identifier of the contact or company to create a relationship with */\nstring) | null | undefined, associatedType?: (/** The type of relationship to create (contact/company) */\nstring) | null | undefined, isMain?: (/** Flag denoting whether or not this relationship should be considered to be the main/primary relationship. Setting to true will automatically demote the existing primary relationship */\nboolean) | null | undefined};\nexport const insertApplicantContactRelationshipModel = /** Request body used to create or update a relationship between an applicant and a contact or company */\nz.object({associatedId: /** The unique identifier of the contact or company to create a relationship with */\nz.string().optional().nullable(), associatedType: /** The type of relationship to create (contact/company) */\nz.string().optional().nullable(), isMain: /** Flag denoting whether or not this relationship should be considered to be the main/primary relationship. Setting to true will automatically demote the existing primary relationship */\nz.boolean().optional().nullable()});",
  "src/sections/Applicants/config/createApplicantsIdRelationshipsConfig.example.tsx": "import { CreateApiApplicantsIdRelationshipsBody } from '@/sections/Applicants/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { Switch } from '@/inputs/Switch.tsx'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createApplicantsIdRelationshipsConfig: ModelConfig<CreateApiApplicantsIdRelationshipsBody> = {associatedId: {\n      key: 'associatedId',\n      label: 'associatedId',\n      defaultValue: '',\n      placeholder: 'associatedId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, associatedType: {\n      key: 'associatedType',\n      label: 'associatedType',\n      defaultValue: '',\n      placeholder: 'associatedType',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, isMain: {\n      key: 'isMain',\n      label: 'isMain',\n      defaultValue: false,\n      placeholder: 'isMain',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><Switch {...props} /></InputWrap>\n    }};",
  "src/sections/Applicants/services/useCreateApiApplicantsIdRelationships.generated.ts": "import { InsertApplicantContactRelationshipModel } from '@/schemas/insertApplicantContactRelationshipModel.generated.tsx'\nimport { createApiApplicantsIdRelationshipsResponse } from '@/sections/Applicants/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiApplicantsIdRelationshipsFnArgs = {id: string, body: InsertApplicantContactRelationshipModel};\nexport const createApiApplicantsIdRelationshipsFn = async ({id, body}: CreateApiApplicantsIdRelationshipsFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/applicants/${id}/relationships${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiApplicantsIdRelationshipsResponse.parse(data)\n    };\nexport const useCreateApiApplicantsIdRelationships = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiApplicantsIdRelationshipsFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Applicants']})\n        }\n      })\n    };",
  "src/sections/Areas/tables/AreasTable.generated.tsx": "import { useGetApiAreas } from '@/sections/Areas/services/useGetApiAreas.generated.ts'\nimport { useState } from 'react'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\nimport { useNavigate } from 'react-router-dom'\n\nexport type UseAreasTableArgs = {sortBy?: (string) | null | undefined, id?: (Array<string>) | null | undefined, departmentId?: (Array<string>) | null | undefined, officeId?: (Array<string>) | null | undefined, name?: (string) | null | undefined, active?: (boolean) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined};\nexport const useAreasTable = (args: UseAreasTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiAreas({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const AreasTable = () => {\n  \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useAreasTable({}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Areas',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New areasTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/areas/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Areas/services/useGetApiAreas.generated.ts": "import { getApiAreasResponse } from '@/sections/Areas/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiAreasFnArgs = {pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, sortBy?: (string) | null | undefined, id?: (Array<string>) | null | undefined, departmentId?: (Array<string>) | null | undefined, officeId?: (Array<string>) | null | undefined, name?: (string) | null | undefined, active?: (boolean) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined};\nexport const getApiAreasFn = async ({pageSize, pageNumber, sortBy, id, departmentId, officeId, name, active, createdFrom, createdTo, modifiedFrom, modifiedTo}: GetApiAreasFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/areas/${querySerialiser({args:{pageSize, pageNumber, sortBy, id, departmentId, officeId, name, active, createdFrom, createdTo, modifiedFrom, modifiedTo}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiAreasResponse.parse(data)\n    };\nexport const useGetApiAreas = ({pageSize, pageNumber, sortBy, id, departmentId, officeId, name, active, createdFrom, createdTo, modifiedFrom, modifiedTo}: GetApiAreasFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Areas', pageSize, pageNumber, sortBy, id, departmentId, officeId, name, active, createdFrom, createdTo, modifiedFrom, modifiedTo],\n        queryFn: () => getApiAreasFn({pageSize, pageNumber, sortBy, id, departmentId, officeId, name, active, createdFrom, createdTo, modifiedFrom, modifiedTo}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Areas/services/apiTypes.generated.ts": "import { areaModelPagedResult } from '@/schemas/areaModelPagedResult.generated.tsx'\nimport { CreateAreaModel, createAreaModel } from '@/schemas/createAreaModel.generated.tsx'\nimport { z } from 'zod'\nimport { areaModel } from '@/schemas/areaModel.generated.tsx'\n\nexport const getApiAreasResponse = areaModelPagedResult;\nexport type CreateApiAreasBody = CreateAreaModel;\nexport const createApiAreasBody = createAreaModel;\nexport const createApiAreasResponse = z.void();\nexport const getApiAreasIdResponse = areaModel;\nexport const patchApiAreasIdResponse = z.void();",
  "src/schemas/areaModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { areaModel, AreaModel } from '@/schemas/areaModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const areaModelPagedResult = z.object({_embedded: z.array(areaModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type AreaModelPagedResult = {_embedded?: (Array<AreaModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/areaModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\n\nexport const areaModel = /** Representation of an area that properties reside in, or applicants are looking to buy/rent in */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the area */\nz.string().optional().nullable(), created: /** The date and time when the area was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the area was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), name: /** The name of the area */\nz.string().optional().nullable(), active: /** A flag denoting whether the area can currently be selected against properties and applicants */\nz.boolean().optional().nullable(), type: /** The type of area (postcodes/polygon/group) */\nz.string().optional().nullable(), area: /** The location details (comma delimited list of postcodes, group ids or lat/long coordinate groups) */\nz.array(z.string().min(1)).optional().nullable(), departmentIds: /** A collection of unique identifiers of departments associated to the area */\nz.array(z.string().min(1)).optional().nullable(), officeIds: /** A collection of unique identifiers of offices attached to the area. The first item in the collection is considered the primary office */\nz.array(z.string().min(1)).optional().nullable(), parentIds: /** A collection of unique identifiers of parent area groups that this area is part of\r\nThis information can be used to understand the area hierarchy in a customer's system */\nz.array(z.string().min(1)).optional().nullable(), _eTag: /** The ETag for the current version of the area. Used for managing update concurrency */\nz.string().optional().nullable()});\nexport type AreaModel = /** Representation of an area that properties reside in, or applicants are looking to buy/rent in */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the area */\nstring) | null | undefined, created?: (/** The date and time when the area was created */\nDate) | null | undefined, modified?: (/** The date and time when the area was last modified */\nDate) | null | undefined, name?: (/** The name of the area */\nstring) | null | undefined, active?: (/** A flag denoting whether the area can currently be selected against properties and applicants */\nboolean) | null | undefined, type?: (/** The type of area (postcodes/polygon/group) */\nstring) | null | undefined, area?: (/** The location details (comma delimited list of postcodes, group ids or lat/long coordinate groups) */\nArray<string>) | null | undefined, departmentIds?: (/** A collection of unique identifiers of departments associated to the area */\nArray<string>) | null | undefined, officeIds?: (/** A collection of unique identifiers of offices attached to the area. The first item in the collection is considered the primary office */\nArray<string>) | null | undefined, parentIds?: (/** A collection of unique identifiers of parent area groups that this area is part of\r\nThis information can be used to understand the area hierarchy in a customer's system */\nArray<string>) | null | undefined, _eTag?: (/** The ETag for the current version of the area. Used for managing update concurrency */\nstring) | null | undefined};",
  "src/sections/Areas/forms/CreateAreas.example.tsx": "import { CreateAreasForm, fieldNames, CreateAreasFormFields } from '@/sections/Areas/forms/CreateAreasForm.generated.tsx'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateAreas = () => {\n      \n\n      \n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateAreasForm >\n              <FormLayout>\n                <CreateAreasFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateAreasForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Areas/forms/CreateAreasForm.generated.tsx": "import { CreateApiAreasBody, createApiAreasBody } from '@/sections/Areas/services/apiTypes.generated.ts'\nimport { createAreasConfig } from '@/sections/Areas/config/createAreasConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiAreas } from '@/sections/Areas/services/useCreateApiAreas.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateAreasFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiAreasBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createAreasConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateAreasFormProps = {children: ReactNode, defaultValues?: CreateApiAreasBody, onSuccess?: () => void};\nexport const CreateAreasForm = (props: CreateAreasFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiAreasBody>({\n        resolver: zodResolver(createApiAreasBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiAreas()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiAreasBody>({name: true, type: true, area: true, departmentIds: true, officeIds: true, parentId: true});",
  "src/schemas/createAreaModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateAreaModel = /** Request body used to create a new area */\n{name: /** The name of the area */\nstring, type: /** The type of area (postcodes/polygon/group) */\nstring, area: /** The location details (comma delimited list of postcodes, group ids or lat/long coordinate groups) */\nArray<string>, departmentIds?: (/** A collection of unique identifiers of departments associated to the area */\nArray<string>) | null | undefined, officeIds?: (/** A collection of unique identifiers of offices attached to the area. The first item in the collection is considered the primary office */\nArray<string>) | null | undefined, parentId?: (/** The unique identifier of the parent area, if the area should be registered as a child area/group in an existing area group */\nstring) | null | undefined};\nexport const createAreaModel = /** Request body used to create a new area */\nz.object({name: /** The name of the area */\nz.string().min(1), type: /** The type of area (postcodes/polygon/group) */\nz.string().min(1), area: /** The location details (comma delimited list of postcodes, group ids or lat/long coordinate groups) */\nz.array(z.string().min(1)), departmentIds: /** A collection of unique identifiers of departments associated to the area */\nz.array(z.string().min(1)).optional().nullable(), officeIds: /** A collection of unique identifiers of offices attached to the area. The first item in the collection is considered the primary office */\nz.array(z.string().min(1)).optional().nullable(), parentId: /** The unique identifier of the parent area, if the area should be registered as a child area/group in an existing area group */\nz.string().optional().nullable()});",
  "src/sections/Areas/config/createAreasConfig.example.tsx": "import { CreateApiAreasBody } from '@/sections/Areas/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { OfficesInput } from '@/sections/Offices/inputs/OfficesInput.generated.tsx'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createAreasConfig: ModelConfig<CreateApiAreasBody> = {name: {\n      key: 'name',\n      label: 'name',\n      defaultValue: '',\n      placeholder: 'name',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, type: {\n      key: 'type',\n      label: 'type',\n      defaultValue: '',\n      placeholder: 'type',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, area: {\n      key: 'area',\n      label: 'area',\n      defaultValue: [],\n      placeholder: 'area',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, departmentIds: {\n      key: 'departmentIds',\n      label: 'departmentIds',\n      defaultValue: [],\n      placeholder: 'departmentIds',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, officeIds: {\n      key: 'officeIds',\n      label: 'officeIds',\n      defaultValue: [],\n      placeholder: 'officeIds',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><OfficesInput {...props} /></InputWrap>\n    }, parentId: {\n      key: 'parentId',\n      label: 'parentId',\n      defaultValue: '',\n      placeholder: 'parentId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/Areas/services/useCreateApiAreas.generated.ts": "import { CreateAreaModel } from '@/schemas/createAreaModel.generated.tsx'\nimport { createApiAreasResponse } from '@/sections/Areas/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiAreasFnArgs = {body: CreateAreaModel};\nexport const createApiAreasFn = async ({body}: CreateApiAreasFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/areas/${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiAreasResponse.parse(data)\n    };\nexport const useCreateApiAreas = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiAreasFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Areas']})\n        }\n      })\n    };",
  "src/sections/Appointments/tables/AppointmentsTable.generated.tsx": "import { useGetApiAppointments } from '@/sections/Appointments/services/useGetApiAppointments.generated.ts'\nimport { useState } from 'react'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\nimport { useNavigate } from 'react-router-dom'\n\nexport type UseAppointmentsTableArgs = {sortBy?: (string) | null | undefined, embed?: (Array<'negotiators' | 'offices' | 'organiser' | 'property' | 'type'>) | null | undefined, id?: (Array<string>) | null | undefined, typeId?: (Array<string>) | null | undefined, negotiatorId?: (Array<string>) | null | undefined, officeId?: (Array<string>) | null | undefined, propertyId?: (Array<string>) | null | undefined, attendeeId?: (Array<string>) | null | undefined, attendeeType?: (Array<'applicant' | 'contact' | 'landlord' | 'tenancy'>) | null | undefined, start?: (Date) | null | undefined, end?: (Date) | null | undefined, includeCancelled?: (boolean) | null | undefined, includeUnconfirmed?: (boolean) | null | undefined, fromArchive?: (boolean) | null | undefined, followUpFrom?: (Date) | null | undefined, followUpTo?: (Date) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, extrasField?: (Array<string>) | null | undefined, metadata?: (Array<string>) | null | undefined};\nexport const useAppointmentsTable = (args: UseAppointmentsTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiAppointments({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const AppointmentsTable = () => {\n  \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useAppointmentsTable({}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Appointments',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New appointmentsTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/appointments/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Appointments/services/useGetApiAppointments.generated.ts": "import { getApiAppointmentsResponse } from '@/sections/Appointments/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiAppointmentsFnArgs = {pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, sortBy?: (string) | null | undefined, embed?: (Array<'negotiators' | 'offices' | 'organiser' | 'property' | 'type'>) | null | undefined, id?: (Array<string>) | null | undefined, typeId?: (Array<string>) | null | undefined, negotiatorId?: (Array<string>) | null | undefined, officeId?: (Array<string>) | null | undefined, propertyId?: (Array<string>) | null | undefined, attendeeId?: (Array<string>) | null | undefined, attendeeType?: (Array<'applicant' | 'contact' | 'landlord' | 'tenancy'>) | null | undefined, start?: (Date) | null | undefined, end?: (Date) | null | undefined, includeCancelled?: (boolean) | null | undefined, includeUnconfirmed?: (boolean) | null | undefined, fromArchive?: (boolean) | null | undefined, followUpFrom?: (Date) | null | undefined, followUpTo?: (Date) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, extrasField?: (Array<string>) | null | undefined, metadata?: (Array<string>) | null | undefined};\nexport const getApiAppointmentsFn = async ({pageSize, pageNumber, sortBy, embed, id, typeId, negotiatorId, officeId, propertyId, attendeeId, attendeeType, start, end, includeCancelled, includeUnconfirmed, fromArchive, followUpFrom, followUpTo, createdFrom, createdTo, modifiedFrom, modifiedTo, extrasField, metadata}: GetApiAppointmentsFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/appointments/${querySerialiser({args:{pageSize, pageNumber, sortBy, embed, id, typeId, negotiatorId, officeId, propertyId, attendeeId, attendeeType, start, end, includeCancelled, includeUnconfirmed, fromArchive, followUpFrom, followUpTo, createdFrom, createdTo, modifiedFrom, modifiedTo, extrasField, metadata}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiAppointmentsResponse.parse(data)\n    };\nexport const useGetApiAppointments = ({pageSize, pageNumber, sortBy, embed, id, typeId, negotiatorId, officeId, propertyId, attendeeId, attendeeType, start, end, includeCancelled, includeUnconfirmed, fromArchive, followUpFrom, followUpTo, createdFrom, createdTo, modifiedFrom, modifiedTo, extrasField, metadata}: GetApiAppointmentsFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Appointments', pageSize, pageNumber, sortBy, embed, id, typeId, negotiatorId, officeId, propertyId, attendeeId, attendeeType, start, end, includeCancelled, includeUnconfirmed, fromArchive, followUpFrom, followUpTo, createdFrom, createdTo, modifiedFrom, modifiedTo, extrasField, metadata],\n        queryFn: () => getApiAppointmentsFn({pageSize, pageNumber, sortBy, embed, id, typeId, negotiatorId, officeId, propertyId, attendeeId, attendeeType, start, end, includeCancelled, includeUnconfirmed, fromArchive, followUpFrom, followUpTo, createdFrom, createdTo, modifiedFrom, modifiedTo, extrasField, metadata}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Appointments/services/apiTypes.generated.ts": "import { appointmentModelPagedResult } from '@/schemas/appointmentModelPagedResult.generated.tsx'\nimport { CreateAppointmentModel, createAppointmentModel } from '@/schemas/createAppointmentModel.generated.tsx'\nimport { z } from 'zod'\nimport { openHouseAttendeeModelPagedResult } from '@/schemas/openHouseAttendeeModelPagedResult.generated.tsx'\nimport { CreateOpenHouseAttendeeModel, createOpenHouseAttendeeModel } from '@/schemas/createOpenHouseAttendeeModel.generated.tsx'\nimport { appointmentModel } from '@/schemas/appointmentModel.generated.tsx'\nimport { openHouseAttendeeModel } from '@/schemas/openHouseAttendeeModel.generated.tsx'\n\nexport const getApiAppointmentsResponse = appointmentModelPagedResult;\nexport type CreateApiAppointmentsBody = CreateAppointmentModel;\nexport const createApiAppointmentsBody = createAppointmentModel;\nexport const createApiAppointmentsResponse = z.void();\nexport const getApiAppointmentsIdOpenHouseAttendeesResponse = openHouseAttendeeModelPagedResult;\nexport type CreateApiAppointmentsIdOpenHouseAttendeesBody = CreateOpenHouseAttendeeModel;\nexport const createApiAppointmentsIdOpenHouseAttendeesBody = createOpenHouseAttendeeModel;\nexport const createApiAppointmentsIdOpenHouseAttendeesResponse = z.void();\nexport const getApiAppointmentsIdResponse = appointmentModel;\nexport const patchApiAppointmentsIdResponse = z.void();\nexport const getApiAppointmentsIdOpenHouseAttendeesOpenHouseAttendeeIdResponse = openHouseAttendeeModel;\nexport const deleteApiAppointmentsIdOpenHouseAttendeesOpenHouseAttendeeIdResponse = z.void();\nexport const patchApiAppointmentsIdOpenHouseAttendeesOpenHouseAttendeeIdResponse = z.void();",
  "src/schemas/appointmentModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { appointmentModel, AppointmentModel } from '@/schemas/appointmentModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const appointmentModelPagedResult = z.object({_embedded: z.array(appointmentModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type AppointmentModelPagedResult = {_embedded?: (Array<AppointmentModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/appointmentModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\nimport { recurrenceModel, RecurrenceModel } from '@/schemas/recurrenceModel.generated.tsx'\nimport { appointmentFollowUpModel, AppointmentFollowUpModel } from '@/schemas/appointmentFollowUpModel.generated.tsx'\nimport { appointmentAttendeeModel, AppointmentAttendeeModel } from '@/schemas/appointmentAttendeeModel.generated.tsx'\nimport { appointmentDocumentModel, AppointmentDocumentModel } from '@/schemas/appointmentDocumentModel.generated.tsx'\n\nexport const appointmentModel = /** Representation of a calendar appointment */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the appointment */\nz.string().optional().nullable(), created: /** The date and time when the appointment was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the appointment was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), start: /** The date and time when the appointment will start */\nz.string().pipe( z.coerce.date() ).optional().nullable(), end: /** The date and time when the appointment will end */\nz.string().pipe( z.coerce.date() ).optional().nullable(), typeId: /** The unique identifier of the appointment type */\nz.string().optional().nullable(), description: /** A free text description about the appointment */\nz.string().optional().nullable(), recurring: /** A flag denoting whether or not the appointment recurs */\nz.boolean().optional().nullable(), recurrence: recurrenceModel.optional().nullable(), cancelled: /** A flag denoting whether or not the appointment has been cancelled */\nz.boolean().optional().nullable(), followUp: appointmentFollowUpModel.optional().nullable(), propertyId: /** The unique identifier of the property related to the appointment */\nz.string().optional().nullable(), organiserId: /** The unique identifier of the negotiator that organised the appointment */\nz.string().optional().nullable(), negotiatorIds: /** A collection of unique identifiers of negotiators attached to the appointment. The first item in the collection is considered the primary negotiator */\nz.array(z.string().min(1)).optional().nullable(), officeIds: /** A collection of unique identifiers of offices attached to the appointment. The first item in the collection is considered the primary office */\nz.array(z.string().min(1)).optional().nullable(), attendee: appointmentAttendeeModel.optional().nullable(), attended: /** The attendance status of the appointment (notSet/noShow/attended) */\nz.string().optional().nullable(), accompanied: /** A flag denoting whether or not the appointment will be accompanied by one or more negotiators */\nz.boolean().optional().nullable(), isRepeat: /** A flag denoting whether or not the appointment is a subsequent appointment to a previous one (a repeat appointment for the same attendee) */\nz.boolean().optional().nullable(), virtual: /** A flag denoting whether or not the appointment is virtual */\nz.boolean().optional().nullable(), negotiatorConfirmed: /** A flag denoting whether or not the main negotiator has confirmed their attendance */\nz.boolean().optional().nullable(), attendeeConfirmed: /** A flag denoting whether or not the attendee has confirmed their attendance */\nz.boolean().optional().nullable(), propertyConfirmed: /** A flag denoting whether or not the property and/or property's vendor has confirmed their attendance */\nz.boolean().optional().nullable(), fromArchive: /** A flag determining whether or not the appointment is archived */\nz.boolean().optional().nullable(), otherAgentId: /** The unique identifier of the external company either carrying out or attending the appointment with the agent */\nz.string().optional().nullable(), documents: appointmentDocumentModel.optional().nullable(), metadata: /** App specific metadata that has been set against the appointment */\nz.record(z.string(), z.object({})).optional().nullable(), extrasField: /** The requested extras fields */\nz.record(z.string(), z.object({})).optional().nullable(), _eTag: /** The ETag for the current version of the appointment. Used for managing update concurrency */\nz.string().optional().nullable()});\nexport type AppointmentModel = /** Representation of a calendar appointment */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the appointment */\nstring) | null | undefined, created?: (/** The date and time when the appointment was created */\nDate) | null | undefined, modified?: (/** The date and time when the appointment was last modified */\nDate) | null | undefined, start?: (/** The date and time when the appointment will start */\nDate) | null | undefined, end?: (/** The date and time when the appointment will end */\nDate) | null | undefined, typeId?: (/** The unique identifier of the appointment type */\nstring) | null | undefined, description?: (/** A free text description about the appointment */\nstring) | null | undefined, recurring?: (/** A flag denoting whether or not the appointment recurs */\nboolean) | null | undefined, recurrence?: (RecurrenceModel) | null | undefined, cancelled?: (/** A flag denoting whether or not the appointment has been cancelled */\nboolean) | null | undefined, followUp?: (AppointmentFollowUpModel) | null | undefined, propertyId?: (/** The unique identifier of the property related to the appointment */\nstring) | null | undefined, organiserId?: (/** The unique identifier of the negotiator that organised the appointment */\nstring) | null | undefined, negotiatorIds?: (/** A collection of unique identifiers of negotiators attached to the appointment. The first item in the collection is considered the primary negotiator */\nArray<string>) | null | undefined, officeIds?: (/** A collection of unique identifiers of offices attached to the appointment. The first item in the collection is considered the primary office */\nArray<string>) | null | undefined, attendee?: (AppointmentAttendeeModel) | null | undefined, attended?: (/** The attendance status of the appointment (notSet/noShow/attended) */\nstring) | null | undefined, accompanied?: (/** A flag denoting whether or not the appointment will be accompanied by one or more negotiators */\nboolean) | null | undefined, isRepeat?: (/** A flag denoting whether or not the appointment is a subsequent appointment to a previous one (a repeat appointment for the same attendee) */\nboolean) | null | undefined, virtual?: (/** A flag denoting whether or not the appointment is virtual */\nboolean) | null | undefined, negotiatorConfirmed?: (/** A flag denoting whether or not the main negotiator has confirmed their attendance */\nboolean) | null | undefined, attendeeConfirmed?: (/** A flag denoting whether or not the attendee has confirmed their attendance */\nboolean) | null | undefined, propertyConfirmed?: (/** A flag denoting whether or not the property and/or property's vendor has confirmed their attendance */\nboolean) | null | undefined, fromArchive?: (/** A flag determining whether or not the appointment is archived */\nboolean) | null | undefined, otherAgentId?: (/** The unique identifier of the external company either carrying out or attending the appointment with the agent */\nstring) | null | undefined, documents?: (AppointmentDocumentModel) | null | undefined, metadata?: (/** App specific metadata that has been set against the appointment */\nRecord<string, Record<string, never>>) | null | undefined, extrasField?: (/** The requested extras fields */\nRecord<string, Record<string, never>>) | null | undefined, _eTag?: (/** The ETag for the current version of the appointment. Used for managing update concurrency */\nstring) | null | undefined};",
  "src/schemas/recurrenceModel.generated.tsx": "import { z } from 'zod'\n\nexport const recurrenceModel = /** Representation of an appointments recurrence details */\nz.object({interval: /** The recurrence interval */\nz.number().int().optional().nullable(), type: /** The type of unit that the `interval` applies to (daily/weekly/yearly/monthly) */\nz.string().optional().nullable(), until: /** The date and time of the last occurrence of the appointment */\nz.string().pipe( z.coerce.date() ).optional().nullable()});\nexport type RecurrenceModel = /** Representation of an appointments recurrence details */\n{interval?: (/** The recurrence interval */\nnumber) | null | undefined, type?: (/** The type of unit that the `interval` applies to (daily/weekly/yearly/monthly) */\nstring) | null | undefined, until?: (/** The date and time of the last occurrence of the appointment */\nDate) | null | undefined};",
  "src/schemas/appointmentFollowUpModel.generated.tsx": "import { z } from 'zod'\n\nexport const appointmentFollowUpModel = /** Follow up information relating to an appointment */\nz.object({due: /** The date when the appointment should be followed up */\nz.string().optional().nullable(), responseId: /** The unique identifier of a pre-defined follow up response type */\nz.string().optional().nullable(), notes: /** Free text internal follow up notes to be stored against the appointment */\nz.string().optional().nullable()});\nexport type AppointmentFollowUpModel = /** Follow up information relating to an appointment */\n{due?: (/** The date when the appointment should be followed up */\nstring) | null | undefined, responseId?: (/** The unique identifier of a pre-defined follow up response type */\nstring) | null | undefined, notes?: (/** Free text internal follow up notes to be stored against the appointment */\nstring) | null | undefined};",
  "src/schemas/appointmentAttendeeModel.generated.tsx": "import { z } from 'zod'\nimport { appointmentContactModel, AppointmentContactModel } from '@/schemas/appointmentContactModel.generated.tsx'\n\nexport const appointmentAttendeeModel = /** An appointment attendee */\nz.object({id: /** The unique identifier of the attendee */\nz.string().optional().nullable(), type: /** The type of attendee */\nz.string().optional().nullable(), contacts: /** A collection of contacts relating to the attendee */\nz.array(appointmentContactModel).optional().nullable()});\nexport type AppointmentAttendeeModel = /** An appointment attendee */\n{id?: (/** The unique identifier of the attendee */\nstring) | null | undefined, type?: (/** The type of attendee */\nstring) | null | undefined, contacts?: (/** A collection of contacts relating to the attendee */\nArray<AppointmentContactModel>) | null | undefined};",
  "src/schemas/appointmentContactModel.generated.tsx": "import { z } from 'zod'\n\nexport const appointmentContactModel = /** A summarised view of the details of a contact associated to an appointment attendee */\nz.object({id: /** The unique identifier of the contact */\nz.string().optional().nullable(), name: /** The name of the contact */\nz.string().optional().nullable(), homePhone: /** The home phone number of the contact */\nz.string().optional().nullable(), workPhone: /** The work phone number of the contact */\nz.string().optional().nullable(), mobilePhone: /** The mobile phone number of the contact */\nz.string().optional().nullable(), email: /** The email address of the contact */\nz.string().optional().nullable(), fromArchive: /** A flag determining if the related contact is archived */\nz.boolean().optional().nullable()});\nexport type AppointmentContactModel = /** A summarised view of the details of a contact associated to an appointment attendee */\n{id?: (/** The unique identifier of the contact */\nstring) | null | undefined, name?: (/** The name of the contact */\nstring) | null | undefined, homePhone?: (/** The home phone number of the contact */\nstring) | null | undefined, workPhone?: (/** The work phone number of the contact */\nstring) | null | undefined, mobilePhone?: (/** The mobile phone number of the contact */\nstring) | null | undefined, email?: (/** The email address of the contact */\nstring) | null | undefined, fromArchive?: (/** A flag determining if the related contact is archived */\nboolean) | null | undefined};",
  "src/schemas/appointmentDocumentModel.generated.tsx": "import { z } from 'zod'\n\nexport const appointmentDocumentModel = /** A view of the documents associated to the appointment */\nz.object({draftPropertyInspectionReportId: /** The unique identifier of the draft property inspection report document */\nz.string().optional().nullable(), finalPropertyInspectionReportId: /** The unique identifier of the final property inspection report document */\nz.string().optional().nullable()});\nexport type AppointmentDocumentModel = /** A view of the documents associated to the appointment */\n{draftPropertyInspectionReportId?: (/** The unique identifier of the draft property inspection report document */\nstring) | null | undefined, finalPropertyInspectionReportId?: (/** The unique identifier of the final property inspection report document */\nstring) | null | undefined};",
  "src/sections/Appointments/forms/CreateAppointments.example.tsx": "import { CreateAppointmentsForm, fieldNames, CreateAppointmentsFormFields } from '@/sections/Appointments/forms/CreateAppointmentsForm.generated.tsx'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateAppointments = () => {\n      \n\n      \n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateAppointmentsForm >\n              <FormLayout>\n                <CreateAppointmentsFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateAppointmentsForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Appointments/forms/CreateAppointmentsForm.generated.tsx": "import { CreateApiAppointmentsBody, createApiAppointmentsBody } from '@/sections/Appointments/services/apiTypes.generated.ts'\nimport { createAppointmentsConfig } from '@/sections/Appointments/config/createAppointmentsConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiAppointments } from '@/sections/Appointments/services/useCreateApiAppointments.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateAppointmentsFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiAppointmentsBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createAppointmentsConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateAppointmentsFormProps = {children: ReactNode, defaultValues?: CreateApiAppointmentsBody, onSuccess?: () => void};\nexport const CreateAppointmentsForm = (props: CreateAppointmentsFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiAppointmentsBody>({\n        resolver: zodResolver(createApiAppointmentsBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiAppointments()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiAppointmentsBody>({start: true, end: true, followUpOn: true, typeId: true, description: true, organiserId: true, negotiatorIds: true, officeIds: true, attendee: true, propertyId: true, otherAgentId: true, accompanied: true, negotiatorConfirmed: true, attendeeConfirmed: true, propertyConfirmed: true, virtual: true, isRepeat: true, attended: true, recurrence: true, documents: true, metadata: true});",
  "src/schemas/createAppointmentModel.generated.tsx": "import { CreateAppointmentAttendeeModel, createAppointmentAttendeeModel } from '@/schemas/createAppointmentAttendeeModel.generated.tsx'\nimport { CreateAppointmentRecurrenceModel, createAppointmentRecurrenceModel } from '@/schemas/createAppointmentRecurrenceModel.generated.tsx'\nimport { CreateAppointmentDocumentModel, createAppointmentDocumentModel } from '@/schemas/createAppointmentDocumentModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type CreateAppointmentModel = /** Request body used to create a new calendar appointment */\n{start: /** The date and time when the appointment will start */\nDate, end: /** The date and time when the appointment will end */\nDate, followUpOn?: (/** The date when the appointment should be followed up */\nstring) | null | undefined, typeId: /** The unique identifier of the appointment type */\nstring, description?: (/** A free text description about the appointment */\nstring) | null | undefined, organiserId?: (/** The unique identifier of the negotiator that organised the appointment */\nstring) | null | undefined, negotiatorIds?: (/** A collection of unique identifiers of negotiators attached to the appointment. The first item in the collection is considered the primary negotiator */\nArray<string>) | null | undefined, officeIds?: (/** A collection of unique identifiers of offices attached to the appointment. The first item in the collection is considered the primary office */\nArray<string>) | null | undefined, attendee?: (CreateAppointmentAttendeeModel) | null | undefined, propertyId?: (/** The unique identifier of the property related to the appointment */\nstring) | null | undefined, otherAgentId?: (/** The unique identifier of the external company either carrying out or attending the appointment with the agent */\nstring) | null | undefined, accompanied?: (/** A flag denoting whether or not the appointment will be accompanied by one or more negotiators */\nboolean) | null | undefined, negotiatorConfirmed?: (/** A flag denoting whether or not the main negotiator has confirmed their attendance */\nboolean) | null | undefined, attendeeConfirmed?: (/** A flag denoting whether or not the attendee has confirmed their attendance */\nboolean) | null | undefined, propertyConfirmed?: (/** A flag denoting whether or not the property and/or property's vendor has confirmed their attendance */\nboolean) | null | undefined, virtual?: (/** A flag denoting whether or not the appointment is virtual */\nboolean) | null | undefined, isRepeat?: (/** A flag denoting whether or not the appointment is a subsequent appointment to a previous one (a repeat appointment for the same attendee) */\nboolean) | null | undefined, attended?: (/** The attendance status of the appointment (notSet/noShow/attended) */\nstring) | null | undefined, recurrence?: (CreateAppointmentRecurrenceModel) | null | undefined, documents?: (CreateAppointmentDocumentModel) | null | undefined, metadata?: (/** App specific metadata to set against the appointment */\nRecord<string, Record<string, never>>) | null | undefined};\nexport const createAppointmentModel = /** Request body used to create a new calendar appointment */\nz.object({start: /** The date and time when the appointment will start */\nz.string().pipe( z.coerce.date() ), end: /** The date and time when the appointment will end */\nz.string().pipe( z.coerce.date() ), followUpOn: /** The date when the appointment should be followed up */\nz.string().optional().nullable(), typeId: /** The unique identifier of the appointment type */\nz.string().min(1), description: /** A free text description about the appointment */\nz.string().optional().nullable(), organiserId: /** The unique identifier of the negotiator that organised the appointment */\nz.string().optional().nullable(), negotiatorIds: /** A collection of unique identifiers of negotiators attached to the appointment. The first item in the collection is considered the primary negotiator */\nz.array(z.string().min(1)).optional().nullable(), officeIds: /** A collection of unique identifiers of offices attached to the appointment. The first item in the collection is considered the primary office */\nz.array(z.string().min(1)).optional().nullable(), attendee: createAppointmentAttendeeModel.optional().nullable(), propertyId: /** The unique identifier of the property related to the appointment */\nz.string().optional().nullable(), otherAgentId: /** The unique identifier of the external company either carrying out or attending the appointment with the agent */\nz.string().optional().nullable(), accompanied: /** A flag denoting whether or not the appointment will be accompanied by one or more negotiators */\nz.boolean().optional().nullable(), negotiatorConfirmed: /** A flag denoting whether or not the main negotiator has confirmed their attendance */\nz.boolean().optional().nullable(), attendeeConfirmed: /** A flag denoting whether or not the attendee has confirmed their attendance */\nz.boolean().optional().nullable(), propertyConfirmed: /** A flag denoting whether or not the property and/or property's vendor has confirmed their attendance */\nz.boolean().optional().nullable(), virtual: /** A flag denoting whether or not the appointment is virtual */\nz.boolean().optional().nullable(), isRepeat: /** A flag denoting whether or not the appointment is a subsequent appointment to a previous one (a repeat appointment for the same attendee) */\nz.boolean().optional().nullable(), attended: /** The attendance status of the appointment (notSet/noShow/attended) */\nz.string().optional().nullable(), recurrence: createAppointmentRecurrenceModel.optional().nullable(), documents: createAppointmentDocumentModel.optional().nullable(), metadata: /** App specific metadata to set against the appointment */\nz.record(z.string(), z.object({})).optional().nullable()});",
  "src/schemas/createAppointmentAttendeeModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateAppointmentAttendeeModel = /** Represents an external attendee on an appointment */\n{id?: (/** The unique identifier of the attendee */\nstring) | null | undefined, type?: (/** The type of attendee (applicant/contact/landlord/tenant) */\nstring) | null | undefined};\nexport const createAppointmentAttendeeModel = /** Represents an external attendee on an appointment */\nz.object({id: /** The unique identifier of the attendee */\nz.string().optional().nullable(), type: /** The type of attendee (applicant/contact/landlord/tenant) */\nz.string().optional().nullable()});",
  "src/schemas/createAppointmentRecurrenceModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateAppointmentRecurrenceModel = /** Details of an appointment's recurrence pattern */\n{interval?: (/** The numeric value denoting how often the appointment will recur */\nnumber) | null | undefined, type?: (/** The type of unit that the `interval` applies to (daily/weekly/yearly/monthly) */\nstring) | null | undefined, until?: (/** The date and time of the last occurrence of the appointment. (Required if 'type' is provided) */\nDate) | null | undefined};\nexport const createAppointmentRecurrenceModel = /** Details of an appointment's recurrence pattern */\nz.object({interval: /** The numeric value denoting how often the appointment will recur */\nz.number().int().optional().nullable(), type: /** The type of unit that the `interval` applies to (daily/weekly/yearly/monthly) */\nz.string().optional().nullable(), until: /** The date and time of the last occurrence of the appointment. (Required if 'type' is provided) */\nz.string().pipe( z.coerce.date() ).optional().nullable()});",
  "src/schemas/createAppointmentDocumentModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateAppointmentDocumentModel = /** A view of the documents associated to the appointment */\n{draftPropertyInspectionReportId?: (/** The unique identifier of the draft property inspection report document */\nstring) | null | undefined, finalPropertyInspectionReportId?: (/** The unique identifier of the final property inspection report document */\nstring) | null | undefined};\nexport const createAppointmentDocumentModel = /** A view of the documents associated to the appointment */\nz.object({draftPropertyInspectionReportId: /** The unique identifier of the draft property inspection report document */\nz.string().optional().nullable(), finalPropertyInspectionReportId: /** The unique identifier of the final property inspection report document */\nz.string().optional().nullable()});",
  "src/sections/Appointments/config/createAppointmentsConfig.example.tsx": "import { CreateApiAppointmentsBody } from '@/sections/Appointments/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { DateInput } from '@/inputs/DateInput.tsx'\nimport { NegotiatorsInput } from '@/sections/Negotiators/inputs/NegotiatorsInput.generated.tsx'\nimport { OfficesInput } from '@/sections/Offices/inputs/OfficesInput.generated.tsx'\nimport { Switch } from '@/inputs/Switch.tsx'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createAppointmentsConfig: ModelConfig<CreateApiAppointmentsBody> = {start: {\n      key: 'start',\n      label: 'start',\n      defaultValue: null,\n      placeholder: 'start',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, end: {\n      key: 'end',\n      label: 'end',\n      defaultValue: null,\n      placeholder: 'end',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, followUpOn: {\n      key: 'followUpOn',\n      label: 'followUpOn',\n      defaultValue: null,\n      placeholder: 'followUpOn',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><DateInput {...props} /></InputWrap>\n    }, typeId: {\n      key: 'typeId',\n      label: 'typeId',\n      defaultValue: '',\n      placeholder: 'typeId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, description: {\n      key: 'description',\n      label: 'description',\n      defaultValue: '',\n      placeholder: 'description',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, organiserId: {\n      key: 'organiserId',\n      label: 'organiserId',\n      defaultValue: '',\n      placeholder: 'organiserId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, negotiatorIds: {\n      key: 'negotiatorIds',\n      label: 'negotiatorIds',\n      defaultValue: [],\n      placeholder: 'negotiatorIds',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><NegotiatorsInput {...props} /></InputWrap>\n    }, officeIds: {\n      key: 'officeIds',\n      label: 'officeIds',\n      defaultValue: [],\n      placeholder: 'officeIds',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><OfficesInput {...props} /></InputWrap>\n    }, attendee: {\n      key: 'attendee',\n      label: 'attendee',\n      defaultValue: null,\n      placeholder: 'attendee',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, propertyId: {\n      key: 'propertyId',\n      label: 'propertyId',\n      defaultValue: '',\n      placeholder: 'propertyId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, otherAgentId: {\n      key: 'otherAgentId',\n      label: 'otherAgentId',\n      defaultValue: '',\n      placeholder: 'otherAgentId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, accompanied: {\n      key: 'accompanied',\n      label: 'accompanied',\n      defaultValue: false,\n      placeholder: 'accompanied',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><Switch {...props} /></InputWrap>\n    }, negotiatorConfirmed: {\n      key: 'negotiatorConfirmed',\n      label: 'negotiatorConfirmed',\n      defaultValue: false,\n      placeholder: 'negotiatorConfirmed',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><Switch {...props} /></InputWrap>\n    }, attendeeConfirmed: {\n      key: 'attendeeConfirmed',\n      label: 'attendeeConfirmed',\n      defaultValue: false,\n      placeholder: 'attendeeConfirmed',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><Switch {...props} /></InputWrap>\n    }, propertyConfirmed: {\n      key: 'propertyConfirmed',\n      label: 'propertyConfirmed',\n      defaultValue: false,\n      placeholder: 'propertyConfirmed',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><Switch {...props} /></InputWrap>\n    }, virtual: {\n      key: 'virtual',\n      label: 'virtual',\n      defaultValue: false,\n      placeholder: 'virtual',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><Switch {...props} /></InputWrap>\n    }, isRepeat: {\n      key: 'isRepeat',\n      label: 'isRepeat',\n      defaultValue: false,\n      placeholder: 'isRepeat',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><Switch {...props} /></InputWrap>\n    }, attended: {\n      key: 'attended',\n      label: 'attended',\n      defaultValue: '',\n      placeholder: 'attended',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, recurrence: {\n      key: 'recurrence',\n      label: 'recurrence',\n      defaultValue: null,\n      placeholder: 'recurrence',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, documents: {\n      key: 'documents',\n      label: 'documents',\n      defaultValue: null,\n      placeholder: 'documents',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, metadata: {\n      key: 'metadata',\n      label: 'metadata',\n      defaultValue: null,\n      placeholder: 'metadata',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/Appointments/services/useCreateApiAppointments.generated.ts": "import { CreateAppointmentModel } from '@/schemas/createAppointmentModel.generated.tsx'\nimport { createApiAppointmentsResponse } from '@/sections/Appointments/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiAppointmentsFnArgs = {body: CreateAppointmentModel};\nexport const createApiAppointmentsFn = async ({body}: CreateApiAppointmentsFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/appointments/${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiAppointmentsResponse.parse(data)\n    };\nexport const useCreateApiAppointments = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiAppointmentsFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Appointments']})\n        }\n      })\n    };",
  "src/sections/Appointments/tables/AppointmentsIdOpenHouseAttendeesTable.generated.tsx": "import { useGetApiAppointmentsIdOpenHouseAttendees } from '@/sections/Appointments/services/useGetApiAppointmentsIdOpenHouseAttendees.generated.ts'\nimport { useState } from 'react'\nimport { useParams, useNavigate } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\n\nexport type UseAppointmentsIdOpenHouseAttendeesTableArgs = {id: string};\nexport const useAppointmentsIdOpenHouseAttendeesTable = (args: UseAppointmentsIdOpenHouseAttendeesTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiAppointmentsIdOpenHouseAttendees({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const AppointmentsIdOpenHouseAttendeesTable = () => {\n  const {id} = useParams()\n    \n    invariant(id, 'Missing id param')\n    \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useAppointmentsIdOpenHouseAttendeesTable({id}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Appointments',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New appointmentsIdOpenHouseAttendeesTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/appointments/${id}/openHouseAttendees/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Appointments/services/useGetApiAppointmentsIdOpenHouseAttendees.generated.ts": "import { getApiAppointmentsIdOpenHouseAttendeesResponse } from '@/sections/Appointments/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiAppointmentsIdOpenHouseAttendeesFnArgs = {id: string, pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined};\nexport const getApiAppointmentsIdOpenHouseAttendeesFn = async ({id, pageSize, pageNumber}: GetApiAppointmentsIdOpenHouseAttendeesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/appointments/${id}/openHouseAttendees${querySerialiser({args:{pageSize, pageNumber}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiAppointmentsIdOpenHouseAttendeesResponse.parse(data)\n    };\nexport const useGetApiAppointmentsIdOpenHouseAttendees = ({id, pageSize, pageNumber}: GetApiAppointmentsIdOpenHouseAttendeesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Appointments', id, pageSize, pageNumber],\n        queryFn: () => getApiAppointmentsIdOpenHouseAttendeesFn({id, pageSize, pageNumber}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/schemas/openHouseAttendeeModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { openHouseAttendeeModel, OpenHouseAttendeeModel } from '@/schemas/openHouseAttendeeModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const openHouseAttendeeModelPagedResult = z.object({_embedded: z.array(openHouseAttendeeModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type OpenHouseAttendeeModelPagedResult = {_embedded?: (Array<OpenHouseAttendeeModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/openHouseAttendeeModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\nimport { appointmentAttendeeModel, AppointmentAttendeeModel } from '@/schemas/appointmentAttendeeModel.generated.tsx'\n\nexport const openHouseAttendeeModel = /** Representation of a calendar appointment */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the open house attendee */\nz.string().optional().nullable(), openHouseId: /** The unique identifier of the open house appointment */\nz.string().optional().nullable(), created: /** The date and time when the open house attendee was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the open house attendee was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), notes: /** The notes taken regarding the open house attendee */\nz.string().optional().nullable(), interestLevel: /** The open house attendees interest level (veryInterested/notInterested/possibleInterest) */\nz.string().optional().nullable(), attendee: appointmentAttendeeModel.optional().nullable(), _eTag: /** The ETag for the current version of the open house attendee. Used for managing update concurrency */\nz.string().optional().nullable()});\nexport type OpenHouseAttendeeModel = /** Representation of a calendar appointment */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the open house attendee */\nstring) | null | undefined, openHouseId?: (/** The unique identifier of the open house appointment */\nstring) | null | undefined, created?: (/** The date and time when the open house attendee was created */\nDate) | null | undefined, modified?: (/** The date and time when the open house attendee was last modified */\nDate) | null | undefined, notes?: (/** The notes taken regarding the open house attendee */\nstring) | null | undefined, interestLevel?: (/** The open house attendees interest level (veryInterested/notInterested/possibleInterest) */\nstring) | null | undefined, attendee?: (AppointmentAttendeeModel) | null | undefined, _eTag?: (/** The ETag for the current version of the open house attendee. Used for managing update concurrency */\nstring) | null | undefined};",
  "src/sections/Appointments/forms/CreateAppointmentsIdOpenHouseAttendees.example.tsx": "import { CreateAppointmentsIdOpenHouseAttendeesForm, fieldNames, CreateAppointmentsIdOpenHouseAttendeesFormFields } from '@/sections/Appointments/forms/CreateAppointmentsIdOpenHouseAttendeesForm.generated.tsx'\nimport { useParams } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateAppointmentsIdOpenHouseAttendees = () => {\n      const { id } = useParams()\n\n      invariant(id, 'Expected id to be defined')\n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateAppointmentsIdOpenHouseAttendeesForm id={id}>\n              <FormLayout>\n                <CreateAppointmentsIdOpenHouseAttendeesFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateAppointmentsIdOpenHouseAttendeesForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Appointments/forms/CreateAppointmentsIdOpenHouseAttendeesForm.generated.tsx": "import { CreateApiAppointmentsIdOpenHouseAttendeesBody, createApiAppointmentsIdOpenHouseAttendeesBody } from '@/sections/Appointments/services/apiTypes.generated.ts'\nimport { createAppointmentsIdOpenHouseAttendeesConfig } from '@/sections/Appointments/config/createAppointmentsIdOpenHouseAttendeesConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiAppointmentsIdOpenHouseAttendees } from '@/sections/Appointments/services/useCreateApiAppointmentsIdOpenHouseAttendees.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateAppointmentsIdOpenHouseAttendeesFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiAppointmentsIdOpenHouseAttendeesBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createAppointmentsIdOpenHouseAttendeesConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateAppointmentsIdOpenHouseAttendeesFormProps = {id: string, children: ReactNode, defaultValues?: CreateApiAppointmentsIdOpenHouseAttendeesBody, onSuccess?: () => void};\nexport const CreateAppointmentsIdOpenHouseAttendeesForm = (props: CreateAppointmentsIdOpenHouseAttendeesFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiAppointmentsIdOpenHouseAttendeesBody>({\n        resolver: zodResolver(createApiAppointmentsIdOpenHouseAttendeesBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiAppointmentsIdOpenHouseAttendees()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiAppointmentsIdOpenHouseAttendeesBody>({interestLevel: true, notes: true, attendee: true});",
  "src/schemas/createOpenHouseAttendeeModel.generated.tsx": "import { CreateAppointmentAttendeeModel, createAppointmentAttendeeModel } from '@/schemas/createAppointmentAttendeeModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type CreateOpenHouseAttendeeModel = /** Request body used to create a new open house attendee */\n{interestLevel?: (/** The interest level of the open house attendee (veryInterested/mightBeInterested/notInterested/notSet) */\nstring) | null | undefined, notes?: (/** Notes on this open house attendee */\nstring) | null | undefined, attendee?: (CreateAppointmentAttendeeModel) | null | undefined};\nexport const createOpenHouseAttendeeModel = /** Request body used to create a new open house attendee */\nz.object({interestLevel: /** The interest level of the open house attendee (veryInterested/mightBeInterested/notInterested/notSet) */\nz.string().optional().nullable(), notes: /** Notes on this open house attendee */\nz.string().optional().nullable(), attendee: createAppointmentAttendeeModel.optional().nullable()});",
  "src/sections/Appointments/config/createAppointmentsIdOpenHouseAttendeesConfig.example.tsx": "import { CreateApiAppointmentsIdOpenHouseAttendeesBody } from '@/sections/Appointments/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createAppointmentsIdOpenHouseAttendeesConfig: ModelConfig<CreateApiAppointmentsIdOpenHouseAttendeesBody> = {interestLevel: {\n      key: 'interestLevel',\n      label: 'interestLevel',\n      defaultValue: '',\n      placeholder: 'interestLevel',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, notes: {\n      key: 'notes',\n      label: 'notes',\n      defaultValue: '',\n      placeholder: 'notes',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, attendee: {\n      key: 'attendee',\n      label: 'attendee',\n      defaultValue: null,\n      placeholder: 'attendee',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/Appointments/services/useCreateApiAppointmentsIdOpenHouseAttendees.generated.ts": "import { CreateOpenHouseAttendeeModel } from '@/schemas/createOpenHouseAttendeeModel.generated.tsx'\nimport { createApiAppointmentsIdOpenHouseAttendeesResponse } from '@/sections/Appointments/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiAppointmentsIdOpenHouseAttendeesFnArgs = {id: string, body: CreateOpenHouseAttendeeModel};\nexport const createApiAppointmentsIdOpenHouseAttendeesFn = async ({id, body}: CreateApiAppointmentsIdOpenHouseAttendeesFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/appointments/${id}/openHouseAttendees${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiAppointmentsIdOpenHouseAttendeesResponse.parse(data)\n    };\nexport const useCreateApiAppointmentsIdOpenHouseAttendees = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiAppointmentsIdOpenHouseAttendeesFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Appointments']})\n        }\n      })\n    };",
  "src/sections/Companies/tables/CompaniesTable.generated.tsx": "import { useGetApiCompanies } from '@/sections/Companies/services/useGetApiCompanies.generated.ts'\nimport { useState } from 'react'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\nimport { useNavigate } from 'react-router-dom'\n\nexport type UseCompaniesTableArgs = {sortBy?: (string) | null | undefined, embed?: (Array<'companyTypes' | 'relationships'>) | null | undefined, id?: (Array<string>) | null | undefined, address?: (string) | null | undefined, branch?: (string) | null | undefined, name?: (string) | null | undefined, typeId?: (string) | null | undefined, negotiatorId?: (Array<string>) | null | undefined, officeId?: (Array<string>) | null | undefined, contactDetail?: (Array<string>) | null | undefined, fromArchive?: (boolean) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, metadata?: (Array<string>) | null | undefined};\nexport const useCompaniesTable = (args: UseCompaniesTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiCompanies({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const CompaniesTable = () => {\n  \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useCompaniesTable({}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Companies',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New companiesTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/companies/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Companies/services/useGetApiCompanies.generated.ts": "import { getApiCompaniesResponse } from '@/sections/Companies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiCompaniesFnArgs = {pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, sortBy?: (string) | null | undefined, embed?: (Array<'companyTypes' | 'relationships'>) | null | undefined, id?: (Array<string>) | null | undefined, address?: (string) | null | undefined, branch?: (string) | null | undefined, name?: (string) | null | undefined, typeId?: (string) | null | undefined, negotiatorId?: (Array<string>) | null | undefined, officeId?: (Array<string>) | null | undefined, contactDetail?: (Array<string>) | null | undefined, fromArchive?: (boolean) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, metadata?: (Array<string>) | null | undefined};\nexport const getApiCompaniesFn = async ({pageSize, pageNumber, sortBy, embed, id, address, branch, name, typeId, negotiatorId, officeId, contactDetail, fromArchive, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata}: GetApiCompaniesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/companies/${querySerialiser({args:{pageSize, pageNumber, sortBy, embed, id, address, branch, name, typeId, negotiatorId, officeId, contactDetail, fromArchive, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiCompaniesResponse.parse(data)\n    };\nexport const useGetApiCompanies = ({pageSize, pageNumber, sortBy, embed, id, address, branch, name, typeId, negotiatorId, officeId, contactDetail, fromArchive, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata}: GetApiCompaniesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Companies', pageSize, pageNumber, sortBy, embed, id, address, branch, name, typeId, negotiatorId, officeId, contactDetail, fromArchive, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata],\n        queryFn: () => getApiCompaniesFn({pageSize, pageNumber, sortBy, embed, id, address, branch, name, typeId, negotiatorId, officeId, contactDetail, fromArchive, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Companies/services/apiTypes.generated.ts": "import { companyModelPagedResult } from '@/schemas/companyModelPagedResult.generated.tsx'\nimport { CreateCompanyModel, createCompanyModel } from '@/schemas/createCompanyModel.generated.tsx'\nimport { z } from 'zod'\nimport { companyRoleModelPagedResult } from '@/schemas/companyRoleModelPagedResult.generated.tsx'\nimport { companyModel } from '@/schemas/companyModel.generated.tsx'\nimport { staffModelPagedResult } from '@/schemas/staffModelPagedResult.generated.tsx'\n\nexport const getApiCompaniesResponse = companyModelPagedResult;\nexport type CreateApiCompaniesBody = CreateCompanyModel;\nexport const createApiCompaniesBody = createCompanyModel;\nexport const createApiCompaniesResponse = z.void();\nexport const getApiCompaniesIdRelationshipsResponse = companyRoleModelPagedResult;\nexport const getApiCompaniesIdResponse = companyModel;\nexport const patchApiCompaniesIdResponse = z.void();\nexport const getApiCompaniesIdStaffMembersResponse = staffModelPagedResult;",
  "src/schemas/companyModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { companyModel, CompanyModel } from '@/schemas/companyModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const companyModelPagedResult = z.object({_embedded: z.array(companyModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type CompanyModelPagedResult = {_embedded?: (Array<CompanyModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/companyModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\nimport { companyAddressModel, CompanyAddressModel } from '@/schemas/companyAddressModel.generated.tsx'\nimport { companyPaymentsModel, CompanyPaymentsModel } from '@/schemas/companyPaymentsModel.generated.tsx'\nimport { additionalContactDetailModel, AdditionalContactDetailModel } from '@/schemas/additionalContactDetailModel.generated.tsx'\nimport { companyRoleModel, CompanyRoleModel } from '@/schemas/companyRoleModel.generated.tsx'\n\nexport const companyModel = /** Representation of a company */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the company */\nz.string().optional().nullable(), created: /** The date and time when the company was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the company was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), name: /** The name of the company */\nz.string().optional().nullable(), branch: /** The branch name of the company */\nz.string().optional().nullable(), notes: /** A free text field containing notes that describe the company's business or service offering */\nz.string().optional().nullable(), active: /** A flag determining whether or not the company is currently active */\nz.boolean().optional().nullable(), marketingConsent: /** The marketing consent status of the company (deny/notAsked) */\nz.string().optional().nullable(), vatRegistered: /** A flag determining whether or not the company is VAT registered */\nz.boolean().optional().nullable(), typeIds: /** A collection of unique identifiers of company types that categorise the type of business the company operates */\nz.array(z.string().min(1)).optional().nullable(), supplierTypeId: /** The unique identifier of a supplier type, if the company is a supplier */\nz.string().optional().nullable(), workPhone: /** The work phone number of the company */\nz.string().optional().nullable(), mobilePhone: /** The mobile phone number of the company */\nz.string().optional().nullable(), email: /** The email address of the company */\nz.string().optional().nullable(), archivedOn: /** The date and time the company was archived */\nz.string().pipe( z.coerce.date() ).optional().nullable(), fromArchive: /** A flag determining whether or not the company is archived */\nz.boolean().optional().nullable(), address: companyAddressModel.optional().nullable(), payments: companyPaymentsModel.optional().nullable(), additionalContactDetails: /** A collection of additional contact details */\nz.array(additionalContactDetailModel).optional().nullable(), officeIds: /** A collection of unique identifiers of offices attached to the company. The first item in the collection is considered the primary office */\nz.array(z.string().min(1)).optional().nullable(), negotiatorIds: /** A collection of unique identifiers of negotiators attached to the company. The first item in the collection is considered the primary negotiator */\nz.array(z.string().min(1)).optional().nullable(), communicationPreferenceLetter: /** A flag determining whether or not the company is happy to receive communications by letter */\nz.boolean().optional().nullable(), communicationPreferenceEmail: /** A flag determining whether or not the company is happy to receive communications by email */\nz.boolean().optional().nullable(), communicationPreferencePhone: /** A flag determining whether or not the company is happy to receive communications by phone */\nz.boolean().optional().nullable(), communicationPreferenceSms: /** A flag determining whether or not the company is happy to receive communications by SMS */\nz.boolean().optional().nullable(), metadata: /** App specific metadata that has been set against the company */\nz.record(z.string(), z.object({})).optional().nullable(), _eTag: /** The ETag for the current version of the company. Used for managing update concurrency */\nz.string().optional().nullable(), relationships: /** A list of relationships belonging to the company. This is later removed from the response */\nz.array(companyRoleModel).optional().nullable()});\nexport type CompanyModel = /** Representation of a company */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the company */\nstring) | null | undefined, created?: (/** The date and time when the company was created */\nDate) | null | undefined, modified?: (/** The date and time when the company was last modified */\nDate) | null | undefined, name?: (/** The name of the company */\nstring) | null | undefined, branch?: (/** The branch name of the company */\nstring) | null | undefined, notes?: (/** A free text field containing notes that describe the company's business or service offering */\nstring) | null | undefined, active?: (/** A flag determining whether or not the company is currently active */\nboolean) | null | undefined, marketingConsent?: (/** The marketing consent status of the company (deny/notAsked) */\nstring) | null | undefined, vatRegistered?: (/** A flag determining whether or not the company is VAT registered */\nboolean) | null | undefined, typeIds?: (/** A collection of unique identifiers of company types that categorise the type of business the company operates */\nArray<string>) | null | undefined, supplierTypeId?: (/** The unique identifier of a supplier type, if the company is a supplier */\nstring) | null | undefined, workPhone?: (/** The work phone number of the company */\nstring) | null | undefined, mobilePhone?: (/** The mobile phone number of the company */\nstring) | null | undefined, email?: (/** The email address of the company */\nstring) | null | undefined, archivedOn?: (/** The date and time the company was archived */\nDate) | null | undefined, fromArchive?: (/** A flag determining whether or not the company is archived */\nboolean) | null | undefined, address?: (CompanyAddressModel) | null | undefined, payments?: (CompanyPaymentsModel) | null | undefined, additionalContactDetails?: (/** A collection of additional contact details */\nArray<AdditionalContactDetailModel>) | null | undefined, officeIds?: (/** A collection of unique identifiers of offices attached to the company. The first item in the collection is considered the primary office */\nArray<string>) | null | undefined, negotiatorIds?: (/** A collection of unique identifiers of negotiators attached to the company. The first item in the collection is considered the primary negotiator */\nArray<string>) | null | undefined, communicationPreferenceLetter?: (/** A flag determining whether or not the company is happy to receive communications by letter */\nboolean) | null | undefined, communicationPreferenceEmail?: (/** A flag determining whether or not the company is happy to receive communications by email */\nboolean) | null | undefined, communicationPreferencePhone?: (/** A flag determining whether or not the company is happy to receive communications by phone */\nboolean) | null | undefined, communicationPreferenceSms?: (/** A flag determining whether or not the company is happy to receive communications by SMS */\nboolean) | null | undefined, metadata?: (/** App specific metadata that has been set against the company */\nRecord<string, Record<string, never>>) | null | undefined, _eTag?: (/** The ETag for the current version of the company. Used for managing update concurrency */\nstring) | null | undefined, relationships?: (/** A list of relationships belonging to the company. This is later removed from the response */\nArray<CompanyRoleModel>) | null | undefined};",
  "src/schemas/companyAddressModel.generated.tsx": "import { z } from 'zod'\n\nexport const companyAddressModel = /** Representation of the physical address of a building or premise */\nz.object({buildingName: /** The building name */\nz.string().optional().nullable(), buildingNumber: /** The building number */\nz.string().optional().nullable(), line1: /** The first line of the address */\nz.string().optional().nullable(), line2: /** The second line of the address */\nz.string().optional().nullable(), line3: /** The third line of the address */\nz.string().optional().nullable(), line4: /** The fourth line of the address */\nz.string().optional().nullable(), postcode: /** The postcode */\nz.string().optional().nullable(), country: /** The ISO-3166 country code that the address resides within */\nz.string().optional().nullable()});\nexport type CompanyAddressModel = /** Representation of the physical address of a building or premise */\n{buildingName?: (/** The building name */\nstring) | null | undefined, buildingNumber?: (/** The building number */\nstring) | null | undefined, line1?: (/** The first line of the address */\nstring) | null | undefined, line2?: (/** The second line of the address */\nstring) | null | undefined, line3?: (/** The third line of the address */\nstring) | null | undefined, line4?: (/** The fourth line of the address */\nstring) | null | undefined, postcode?: (/** The postcode */\nstring) | null | undefined, country?: (/** The ISO-3166 country code that the address resides within */\nstring) | null | undefined};",
  "src/schemas/companyPaymentsModel.generated.tsx": "import { z } from 'zod'\n\nexport const companyPaymentsModel = /** Representation of the payments and terms configuration for a company */\nz.object({nominalAccountId: /** The identifier of the nominal code selected in the payments and terms configuration */\nz.string().optional().nullable()});\nexport type CompanyPaymentsModel = /** Representation of the payments and terms configuration for a company */\n{nominalAccountId?: (/** The identifier of the nominal code selected in the payments and terms configuration */\nstring) | null | undefined};",
  "src/schemas/companyRoleModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\n\nexport const companyRoleModel = /** Representation of the roles that an individual companies possesses */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the relationship */\nz.string().optional().nullable(), created: /** The date and time when the relationship was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the relationship was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), companyId: /** The unique identifier of the related company */\nz.string().optional().nullable(), associatedType: /** The type of related entity (applicant/landlord/offer/tenancy/vendor) */\nz.string().optional().nullable(), associatedId: /** The unique identifier of the related entity */\nz.string().optional().nullable(), fromArchive: /** Flag to determine if this role on the system is now archived */\nz.boolean().optional().nullable()});\nexport type CompanyRoleModel = /** Representation of the roles that an individual companies possesses */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the relationship */\nstring) | null | undefined, created?: (/** The date and time when the relationship was created */\nDate) | null | undefined, modified?: (/** The date and time when the relationship was last modified */\nDate) | null | undefined, companyId?: (/** The unique identifier of the related company */\nstring) | null | undefined, associatedType?: (/** The type of related entity (applicant/landlord/offer/tenancy/vendor) */\nstring) | null | undefined, associatedId?: (/** The unique identifier of the related entity */\nstring) | null | undefined, fromArchive?: (/** Flag to determine if this role on the system is now archived */\nboolean) | null | undefined};",
  "src/sections/Companies/forms/CreateCompanies.example.tsx": "import { CreateCompaniesForm, fieldNames, CreateCompaniesFormFields } from '@/sections/Companies/forms/CreateCompaniesForm.generated.tsx'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateCompanies = () => {\n      \n\n      \n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateCompaniesForm >\n              <FormLayout>\n                <CreateCompaniesFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateCompaniesForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Companies/forms/CreateCompaniesForm.generated.tsx": "import { CreateApiCompaniesBody, createApiCompaniesBody } from '@/sections/Companies/services/apiTypes.generated.ts'\nimport { createCompaniesConfig } from '@/sections/Companies/config/createCompaniesConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiCompanies } from '@/sections/Companies/services/useCreateApiCompanies.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateCompaniesFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiCompaniesBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createCompaniesConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateCompaniesFormProps = {children: ReactNode, defaultValues?: CreateApiCompaniesBody, onSuccess?: () => void};\nexport const CreateCompaniesForm = (props: CreateCompaniesFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiCompaniesBody>({\n        resolver: zodResolver(createApiCompaniesBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiCompanies()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiCompaniesBody>({name: true, branch: true, notes: true, active: true, marketingConsent: true, vatRegistered: true, typeIds: true, supplierTypeId: true, workPhone: true, mobilePhone: true, email: true, address: true, communicationPreferenceLetter: true, communicationPreferenceEmail: true, communicationPreferencePhone: true, communicationPreferenceSms: true, metadata: true});",
  "src/schemas/createCompanyModel.generated.tsx": "import { CreateCompanyAddressModel, createCompanyAddressModel } from '@/schemas/createCompanyAddressModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type CreateCompanyModel = /** Request body used to create a new company */\n{name: /** The name of the company */\nstring, branch?: (/** The branch name of the company */\nstring) | null | undefined, notes?: (/** A free text field containing notes that describe the company's business or service offering */\nstring) | null | undefined, active?: (/** A flag determining whether or not the company is currently active */\nboolean) | null | undefined, marketingConsent?: (/** The marketing consent status of the company (deny/notAsked) */\nstring) | null | undefined, vatRegistered?: (/** A flag determining whether or not the company is VAT registered */\nboolean) | null | undefined, typeIds: /** A collection of unique identifiers of company types that categorise the type of business the company operates */\nArray<string>, supplierTypeId?: (/** The unique identifier of a supplier type, if the company is a supplier */\nstring) | null | undefined, workPhone?: (/** The work phone number of the company. (Required when no other company or address details are provided) */\nstring) | null | undefined, mobilePhone?: (/** The mobile phone number of the company. (Required when no other company or address details are provided) */\nstring) | null | undefined, email?: (/** The email address of the company. (Required when no other company or address details are provided) */\nstring) | null | undefined, address?: (CreateCompanyAddressModel) | null | undefined, communicationPreferenceLetter?: (/** A flag determining whether or not the company is happy to receive communications by letter */\nboolean) | null | undefined, communicationPreferenceEmail?: (/** A flag determining whether or not the company is happy to receive communications by email */\nboolean) | null | undefined, communicationPreferencePhone?: (/** A flag determining whether or not the company is happy to receive communications by phone */\nboolean) | null | undefined, communicationPreferenceSms?: (/** A flag determining whether or not the company is happy to receive communications by SMS */\nboolean) | null | undefined, metadata?: (/** App specific metadata to set against the company */\nRecord<string, Record<string, never>>) | null | undefined};\nexport const createCompanyModel = /** Request body used to create a new company */\nz.object({name: /** The name of the company */\nz.string().min(1), branch: /** The branch name of the company */\nz.string().optional().nullable(), notes: /** A free text field containing notes that describe the company's business or service offering */\nz.string().optional().nullable(), active: /** A flag determining whether or not the company is currently active */\nz.boolean().optional().nullable(), marketingConsent: /** The marketing consent status of the company (deny/notAsked) */\nz.string().optional().nullable(), vatRegistered: /** A flag determining whether or not the company is VAT registered */\nz.boolean().optional().nullable(), typeIds: /** A collection of unique identifiers of company types that categorise the type of business the company operates */\nz.array(z.string().min(1)), supplierTypeId: /** The unique identifier of a supplier type, if the company is a supplier */\nz.string().optional().nullable(), workPhone: /** The work phone number of the company. (Required when no other company or address details are provided) */\nz.string().optional().nullable(), mobilePhone: /** The mobile phone number of the company. (Required when no other company or address details are provided) */\nz.string().optional().nullable(), email: /** The email address of the company. (Required when no other company or address details are provided) */\nz.string().optional().nullable(), address: createCompanyAddressModel.optional().nullable(), communicationPreferenceLetter: /** A flag determining whether or not the company is happy to receive communications by letter */\nz.boolean().optional().nullable(), communicationPreferenceEmail: /** A flag determining whether or not the company is happy to receive communications by email */\nz.boolean().optional().nullable(), communicationPreferencePhone: /** A flag determining whether or not the company is happy to receive communications by phone */\nz.boolean().optional().nullable(), communicationPreferenceSms: /** A flag determining whether or not the company is happy to receive communications by SMS */\nz.boolean().optional().nullable(), metadata: /** App specific metadata to set against the company */\nz.record(z.string(), z.object({})).optional().nullable()});",
  "src/schemas/createCompanyAddressModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateCompanyAddressModel = /** Request body to set the address of a new company */\n{type?: (/** The type of address (primary/secondary/home/work/forwarding/company/previous) */\nstring) | null | undefined, buildingName?: (/** The building name */\nstring) | null | undefined, buildingNumber?: (/** The building number */\nstring) | null | undefined, line1?: (/** The first line of the address */\nstring) | null | undefined, line2?: (/** The second line of the address */\nstring) | null | undefined, line3?: (/** The third line of the address */\nstring) | null | undefined, line4?: (/** The fourth line of the address */\nstring) | null | undefined, postcode?: (/** The postcode */\nstring) | null | undefined, countryId?: (/** The ISO-3166 country code that the address resides within */\nstring) | null | undefined};\nexport const createCompanyAddressModel = /** Request body to set the address of a new company */\nz.object({type: /** The type of address (primary/secondary/home/work/forwarding/company/previous) */\nz.string().optional().nullable(), buildingName: /** The building name */\nz.string().optional().nullable(), buildingNumber: /** The building number */\nz.string().optional().nullable(), line1: /** The first line of the address */\nz.string().optional().nullable(), line2: /** The second line of the address */\nz.string().optional().nullable(), line3: /** The third line of the address */\nz.string().optional().nullable(), line4: /** The fourth line of the address */\nz.string().optional().nullable(), postcode: /** The postcode */\nz.string().optional().nullable(), countryId: /** The ISO-3166 country code that the address resides within */\nz.string().optional().nullable()});",
  "src/sections/Companies/config/createCompaniesConfig.example.tsx": "import { CreateApiCompaniesBody } from '@/sections/Companies/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { Switch } from '@/inputs/Switch.tsx'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createCompaniesConfig: ModelConfig<CreateApiCompaniesBody> = {name: {\n      key: 'name',\n      label: 'name',\n      defaultValue: '',\n      placeholder: 'name',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, branch: {\n      key: 'branch',\n      label: 'branch',\n      defaultValue: '',\n      placeholder: 'branch',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, notes: {\n      key: 'notes',\n      label: 'notes',\n      defaultValue: '',\n      placeholder: 'notes',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, active: {\n      key: 'active',\n      label: 'active',\n      defaultValue: false,\n      placeholder: 'active',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><Switch {...props} /></InputWrap>\n    }, marketingConsent: {\n      key: 'marketingConsent',\n      label: 'marketingConsent',\n      defaultValue: '',\n      placeholder: 'marketingConsent',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, vatRegistered: {\n      key: 'vatRegistered',\n      label: 'vatRegistered',\n      defaultValue: false,\n      placeholder: 'vatRegistered',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><Switch {...props} /></InputWrap>\n    }, typeIds: {\n      key: 'typeIds',\n      label: 'typeIds',\n      defaultValue: [],\n      placeholder: 'typeIds',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, supplierTypeId: {\n      key: 'supplierTypeId',\n      label: 'supplierTypeId',\n      defaultValue: '',\n      placeholder: 'supplierTypeId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, workPhone: {\n      key: 'workPhone',\n      label: 'workPhone',\n      defaultValue: '',\n      placeholder: 'workPhone',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, mobilePhone: {\n      key: 'mobilePhone',\n      label: 'mobilePhone',\n      defaultValue: '',\n      placeholder: 'mobilePhone',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, email: {\n      key: 'email',\n      label: 'email',\n      defaultValue: '',\n      placeholder: 'email',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, address: {\n      key: 'address',\n      label: 'address',\n      defaultValue: null,\n      placeholder: 'address',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, communicationPreferenceLetter: {\n      key: 'communicationPreferenceLetter',\n      label: 'communicationPreferenceLetter',\n      defaultValue: false,\n      placeholder: 'communicationPreferenceLetter',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><Switch {...props} /></InputWrap>\n    }, communicationPreferenceEmail: {\n      key: 'communicationPreferenceEmail',\n      label: 'communicationPreferenceEmail',\n      defaultValue: false,\n      placeholder: 'communicationPreferenceEmail',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><Switch {...props} /></InputWrap>\n    }, communicationPreferencePhone: {\n      key: 'communicationPreferencePhone',\n      label: 'communicationPreferencePhone',\n      defaultValue: false,\n      placeholder: 'communicationPreferencePhone',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><Switch {...props} /></InputWrap>\n    }, communicationPreferenceSms: {\n      key: 'communicationPreferenceSms',\n      label: 'communicationPreferenceSms',\n      defaultValue: false,\n      placeholder: 'communicationPreferenceSms',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><Switch {...props} /></InputWrap>\n    }, metadata: {\n      key: 'metadata',\n      label: 'metadata',\n      defaultValue: null,\n      placeholder: 'metadata',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/Companies/services/useCreateApiCompanies.generated.ts": "import { CreateCompanyModel } from '@/schemas/createCompanyModel.generated.tsx'\nimport { createApiCompaniesResponse } from '@/sections/Companies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiCompaniesFnArgs = {body: CreateCompanyModel};\nexport const createApiCompaniesFn = async ({body}: CreateApiCompaniesFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/companies/${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiCompaniesResponse.parse(data)\n    };\nexport const useCreateApiCompanies = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiCompaniesFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Companies']})\n        }\n      })\n    };",
  "src/sections/Companies/tables/CompaniesIdRelationshipsTable.generated.tsx": "import { useGetApiCompaniesIdRelationships } from '@/sections/Companies/services/useGetApiCompaniesIdRelationships.generated.ts'\nimport { useState } from 'react'\nimport { useParams, useNavigate } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\n\nexport type UseCompaniesIdRelationshipsTableArgs = {id: string};\nexport const useCompaniesIdRelationshipsTable = (args: UseCompaniesIdRelationshipsTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiCompaniesIdRelationships({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const CompaniesIdRelationshipsTable = () => {\n  const {id} = useParams()\n    \n    invariant(id, 'Missing id param')\n    \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useCompaniesIdRelationshipsTable({id}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Companies',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New companiesIdRelationshipsTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/companies/${id}/relationships/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Companies/services/useGetApiCompaniesIdRelationships.generated.ts": "import { getApiCompaniesIdRelationshipsResponse } from '@/sections/Companies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiCompaniesIdRelationshipsFnArgs = {id: string, pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined};\nexport const getApiCompaniesIdRelationshipsFn = async ({id, pageSize, pageNumber}: GetApiCompaniesIdRelationshipsFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/companies/${id}/relationships${querySerialiser({args:{pageSize, pageNumber}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiCompaniesIdRelationshipsResponse.parse(data)\n    };\nexport const useGetApiCompaniesIdRelationships = ({id, pageSize, pageNumber}: GetApiCompaniesIdRelationshipsFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Companies', id, pageSize, pageNumber],\n        queryFn: () => getApiCompaniesIdRelationshipsFn({id, pageSize, pageNumber}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/schemas/companyRoleModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { companyRoleModel, CompanyRoleModel } from '@/schemas/companyRoleModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const companyRoleModelPagedResult = z.object({_embedded: z.array(companyRoleModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type CompanyRoleModelPagedResult = {_embedded?: (Array<CompanyRoleModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/sections/Contacts/tables/ContactsTable.generated.tsx": "import { useGetApiContacts } from '@/sections/Contacts/services/useGetApiContacts.generated.ts'\nimport { useState } from 'react'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\nimport { useNavigate } from 'react-router-dom'\n\nexport type UseContactsTableArgs = {sortBy?: (string) | null | undefined, embed?: (Array<'documents' | 'identityChecks' | 'negotiators' | 'offices' | 'relationships' | 'source'>) | null | undefined, id?: (Array<string>) | null | undefined, contactDetail?: (Array<string>) | null | undefined, email?: (Array<string>) | null | undefined, negotiatorId?: (Array<string>) | null | undefined, officeId?: (Array<string>) | null | undefined, address?: (string) | null | undefined, identityCheck?: (Array<'pass' | 'fail' | 'pending' | 'warnings' | 'unchecked'>) | null | undefined, name?: (string) | null | undefined, nameType?: (string) | null | undefined, marketingConsent?: (Array<'grant' | 'deny' | 'notAsked'>) | null | undefined, marketingConsentFilterType?: (Array<'assumedOrExplicit' | 'explicit'>) | null | undefined, active?: (boolean) | null | undefined, fromArchive?: (boolean) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, metadata?: (Array<string>) | null | undefined, extrasField?: (Array<string>) | null | undefined};\nexport const useContactsTable = (args: UseContactsTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiContacts({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const ContactsTable = () => {\n  \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useContactsTable({}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Contacts',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New contactsTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/contacts/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Contacts/services/useGetApiContacts.generated.ts": "import { getApiContactsResponse } from '@/sections/Contacts/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiContactsFnArgs = {pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, sortBy?: (string) | null | undefined, embed?: (Array<'documents' | 'identityChecks' | 'negotiators' | 'offices' | 'relationships' | 'source'>) | null | undefined, id?: (Array<string>) | null | undefined, contactDetail?: (Array<string>) | null | undefined, email?: (Array<string>) | null | undefined, negotiatorId?: (Array<string>) | null | undefined, officeId?: (Array<string>) | null | undefined, address?: (string) | null | undefined, identityCheck?: (Array<'pass' | 'fail' | 'pending' | 'warnings' | 'unchecked'>) | null | undefined, name?: (string) | null | undefined, nameType?: (string) | null | undefined, marketingConsent?: (Array<'grant' | 'deny' | 'notAsked'>) | null | undefined, marketingConsentFilterType?: (Array<'assumedOrExplicit' | 'explicit'>) | null | undefined, active?: (boolean) | null | undefined, fromArchive?: (boolean) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, metadata?: (Array<string>) | null | undefined, extrasField?: (Array<string>) | null | undefined};\nexport const getApiContactsFn = async ({pageSize, pageNumber, sortBy, embed, id, contactDetail, email, negotiatorId, officeId, address, identityCheck, name, nameType, marketingConsent, marketingConsentFilterType, active, fromArchive, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata, extrasField}: GetApiContactsFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/contacts/${querySerialiser({args:{pageSize, pageNumber, sortBy, embed, id, contactDetail, email, negotiatorId, officeId, address, identityCheck, name, nameType, marketingConsent, marketingConsentFilterType, active, fromArchive, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata, extrasField}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiContactsResponse.parse(data)\n    };\nexport const useGetApiContacts = ({pageSize, pageNumber, sortBy, embed, id, contactDetail, email, negotiatorId, officeId, address, identityCheck, name, nameType, marketingConsent, marketingConsentFilterType, active, fromArchive, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata, extrasField}: GetApiContactsFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Contacts', pageSize, pageNumber, sortBy, embed, id, contactDetail, email, negotiatorId, officeId, address, identityCheck, name, nameType, marketingConsent, marketingConsentFilterType, active, fromArchive, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata, extrasField],\n        queryFn: () => getApiContactsFn({pageSize, pageNumber, sortBy, embed, id, contactDetail, email, negotiatorId, officeId, address, identityCheck, name, nameType, marketingConsent, marketingConsentFilterType, active, fromArchive, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata, extrasField}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Contacts/services/apiTypes.generated.ts": "import { contactModelPagedResult } from '@/schemas/contactModelPagedResult.generated.tsx'\nimport { CreateContactModel, createContactModel } from '@/schemas/createContactModel.generated.tsx'\nimport { z } from 'zod'\nimport { contactRoleModelPagedResult } from '@/schemas/contactRoleModelPagedResult.generated.tsx'\nimport { contactSubscriptionModelPagedResult } from '@/schemas/contactSubscriptionModelPagedResult.generated.tsx'\nimport { contactModel } from '@/schemas/contactModel.generated.tsx'\nimport { contactSubscriptionModel } from '@/schemas/contactSubscriptionModel.generated.tsx'\n\nexport const getApiContactsResponse = contactModelPagedResult;\nexport type CreateApiContactsBody = CreateContactModel;\nexport const createApiContactsBody = createContactModel;\nexport const createApiContactsResponse = z.void();\nexport const getApiContactsIdRelationshipsResponse = contactRoleModelPagedResult;\nexport const getApiContactsIdSubscriptionsResponse = contactSubscriptionModelPagedResult;\nexport const getApiContactsIdResponse = contactModel;\nexport const patchApiContactsIdResponse = z.void();\nexport const getApiContactsIdSubscriptionsSubscriptionIdResponse = contactSubscriptionModel;\nexport const updateApiContactsIdSubscriptionsSubscriptionIdResponse = z.void();",
  "src/schemas/contactModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { contactModel, ContactModel } from '@/schemas/contactModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const contactModelPagedResult = z.object({_embedded: z.array(contactModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type ContactModelPagedResult = {_embedded?: (Array<ContactModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/contactModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\nimport { contactSourceModel, ContactSourceModel } from '@/schemas/contactSourceModel.generated.tsx'\nimport { contactAddressModel, ContactAddressModel } from '@/schemas/contactAddressModel.generated.tsx'\nimport { additionalContactDetailModel, AdditionalContactDetailModel } from '@/schemas/additionalContactDetailModel.generated.tsx'\nimport { contactRoleModel, ContactRoleModel } from '@/schemas/contactRoleModel.generated.tsx'\n\nexport const contactModel = /** Representation of an individual contact */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the contact */\nz.string().optional().nullable(), created: /** The date and time when the contact was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the contact was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), title: /** The contact's title  (eg. Mr, Mrs, Miss, Dr) */\nz.string().optional().nullable(), forename: /** The contact's forename */\nz.string().optional().nullable(), surname: /** The contact's surname */\nz.string().optional().nullable(), dateOfBirth: /** The contact's date of birth */\nz.string().optional().nullable(), active: /** A flag determining whether or not the contact is currently active */\nz.boolean().optional().nullable(), marketingConsent: /** The marketing consent status of the contact (grant/deny/notAsked) */\nz.string().optional().nullable(), identityCheck: /** The status of the last identity check performed against the contact (pass/fail/pending/cancelled/warnings/unchecked) */\nz.string().optional().nullable(), source: contactSourceModel.optional().nullable(), homePhone: /** The home phone number of the contact */\nz.string().optional().nullable(), workPhone: /** The work phone number of the contact */\nz.string().optional().nullable(), mobilePhone: /** The mobile phone number of the contact */\nz.string().optional().nullable(), email: /** The email address of the contact */\nz.string().optional().nullable(), archivedOn: /** The date and time the contact was archived */\nz.string().pipe( z.coerce.date() ).optional().nullable(), fromArchive: /** A flag determining whether or not the contact is archived */\nz.boolean().optional().nullable(), primaryAddress: contactAddressModel.optional().nullable(), secondaryAddress: contactAddressModel.optional().nullable(), workAddress: contactAddressModel.optional().nullable(), officeIds: /** A collection of unique identifiers of offices attached to the contact. The first item in the collection is considered the primary office */\nz.array(z.string().min(1)).optional().nullable(), negotiatorIds: /** A collection of unique identifiers of negotiators attached to the contact. The first item in the collection is considered the primary negotiator */\nz.array(z.string().min(1)).optional().nullable(), categoryIds: /** A collection of categories associated to the contact. */\nz.array(z.string().min(1)).optional().nullable(), communicationPreferenceLetter: /** A flag determining whether or not the contact is happy to receive communications by letter */\nz.boolean().optional().nullable(), communicationPreferenceEmail: /** A flag determining whether or not the contact is happy to receive communications by email */\nz.boolean().optional().nullable(), communicationPreferencePhone: /** A flag determining whether or not the contact is happy to receive communications by phone */\nz.boolean().optional().nullable(), communicationPreferenceSMS: /** A flag determining whether or not the contact is happy to receive communications by SMS */\nz.boolean().optional().nullable(), additionalContactDetails: /** A collection of additional contact details */\nz.array(additionalContactDetailModel).optional().nullable(), metadata: /** App specific metadata that has been set against the contact */\nz.record(z.string(), z.object({})).optional().nullable(), _eTag: /** The ETag for the current version of the contact. Used for managing update concurrency */\nz.string().optional().nullable(), extrasField: /** The requested extras fields */\nz.record(z.string(), z.object({})).optional().nullable(), relationships: /** A list of relationships belonging to the contact. This is later removed from the response */\nz.array(contactRoleModel).optional().nullable()});\nexport type ContactModel = /** Representation of an individual contact */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the contact */\nstring) | null | undefined, created?: (/** The date and time when the contact was created */\nDate) | null | undefined, modified?: (/** The date and time when the contact was last modified */\nDate) | null | undefined, title?: (/** The contact's title  (eg. Mr, Mrs, Miss, Dr) */\nstring) | null | undefined, forename?: (/** The contact's forename */\nstring) | null | undefined, surname?: (/** The contact's surname */\nstring) | null | undefined, dateOfBirth?: (/** The contact's date of birth */\nstring) | null | undefined, active?: (/** A flag determining whether or not the contact is currently active */\nboolean) | null | undefined, marketingConsent?: (/** The marketing consent status of the contact (grant/deny/notAsked) */\nstring) | null | undefined, identityCheck?: (/** The status of the last identity check performed against the contact (pass/fail/pending/cancelled/warnings/unchecked) */\nstring) | null | undefined, source?: (ContactSourceModel) | null | undefined, homePhone?: (/** The home phone number of the contact */\nstring) | null | undefined, workPhone?: (/** The work phone number of the contact */\nstring) | null | undefined, mobilePhone?: (/** The mobile phone number of the contact */\nstring) | null | undefined, email?: (/** The email address of the contact */\nstring) | null | undefined, archivedOn?: (/** The date and time the contact was archived */\nDate) | null | undefined, fromArchive?: (/** A flag determining whether or not the contact is archived */\nboolean) | null | undefined, primaryAddress?: (ContactAddressModel) | null | undefined, secondaryAddress?: (ContactAddressModel) | null | undefined, workAddress?: (ContactAddressModel) | null | undefined, officeIds?: (/** A collection of unique identifiers of offices attached to the contact. The first item in the collection is considered the primary office */\nArray<string>) | null | undefined, negotiatorIds?: (/** A collection of unique identifiers of negotiators attached to the contact. The first item in the collection is considered the primary negotiator */\nArray<string>) | null | undefined, categoryIds?: (/** A collection of categories associated to the contact. */\nArray<string>) | null | undefined, communicationPreferenceLetter?: (/** A flag determining whether or not the contact is happy to receive communications by letter */\nboolean) | null | undefined, communicationPreferenceEmail?: (/** A flag determining whether or not the contact is happy to receive communications by email */\nboolean) | null | undefined, communicationPreferencePhone?: (/** A flag determining whether or not the contact is happy to receive communications by phone */\nboolean) | null | undefined, communicationPreferenceSMS?: (/** A flag determining whether or not the contact is happy to receive communications by SMS */\nboolean) | null | undefined, additionalContactDetails?: (/** A collection of additional contact details */\nArray<AdditionalContactDetailModel>) | null | undefined, metadata?: (/** App specific metadata that has been set against the contact */\nRecord<string, Record<string, never>>) | null | undefined, _eTag?: (/** The ETag for the current version of the contact. Used for managing update concurrency */\nstring) | null | undefined, extrasField?: (/** The requested extras fields */\nRecord<string, Record<string, never>>) | null | undefined, relationships?: (/** A list of relationships belonging to the contact. This is later removed from the response */\nArray<ContactRoleModel>) | null | undefined};",
  "src/schemas/contactSourceModel.generated.tsx": "import { z } from 'zod'\n\nexport const contactSourceModel = /** Representation of a contact's source */\nz.object({id: /** The unique identifier of the source of the contact */\nz.string().optional().nullable(), type: /** The source type (office/source) */\nz.string().optional().nullable()});\nexport type ContactSourceModel = /** Representation of a contact's source */\n{id?: (/** The unique identifier of the source of the contact */\nstring) | null | undefined, type?: (/** The source type (office/source) */\nstring) | null | undefined};",
  "src/schemas/contactAddressModel.generated.tsx": "import { z } from 'zod'\n\nexport const contactAddressModel = /** Representation of the physical address of a building or premise */\nz.object({type: /** The type of address (primary/secondary/home/work/forwarding/company/previous) */\nz.string().optional().nullable(), buildingName: /** The building name */\nz.string().optional().nullable(), buildingNumber: /** The building number */\nz.string().optional().nullable(), line1: /** The first line of the address */\nz.string().optional().nullable(), line2: /** The second line of the address */\nz.string().optional().nullable(), line3: /** The third line of the address */\nz.string().optional().nullable(), line4: /** The fourth line of the address */\nz.string().optional().nullable(), postcode: /** The postcode */\nz.string().optional().nullable(), countryId: /** The ISO-3166 country code that the address resides in */\nz.string().optional().nullable()});\nexport type ContactAddressModel = /** Representation of the physical address of a building or premise */\n{type?: (/** The type of address (primary/secondary/home/work/forwarding/company/previous) */\nstring) | null | undefined, buildingName?: (/** The building name */\nstring) | null | undefined, buildingNumber?: (/** The building number */\nstring) | null | undefined, line1?: (/** The first line of the address */\nstring) | null | undefined, line2?: (/** The second line of the address */\nstring) | null | undefined, line3?: (/** The third line of the address */\nstring) | null | undefined, line4?: (/** The fourth line of the address */\nstring) | null | undefined, postcode?: (/** The postcode */\nstring) | null | undefined, countryId?: (/** The ISO-3166 country code that the address resides in */\nstring) | null | undefined};",
  "src/schemas/contactRoleModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\n\nexport const contactRoleModel = /** Representation of the roles that an individual contacts possesses */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the relationship */\nz.string().optional().nullable(), created: /** The date and time when the relationship was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the relationship was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), contactId: /** The unique identifier of the related contact */\nz.string().optional().nullable(), associatedType: /** The type of related entity (applicant/landlord/offer/tenancy/vendor) */\nz.string().optional().nullable(), associatedId: /** The unique identifier of the related entity */\nz.string().optional().nullable(), fromArchive: /** Flag to determine if this role on the system is now archived */\nz.boolean().optional().nullable()});\nexport type ContactRoleModel = /** Representation of the roles that an individual contacts possesses */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the relationship */\nstring) | null | undefined, created?: (/** The date and time when the relationship was created */\nDate) | null | undefined, modified?: (/** The date and time when the relationship was last modified */\nDate) | null | undefined, contactId?: (/** The unique identifier of the related contact */\nstring) | null | undefined, associatedType?: (/** The type of related entity (applicant/landlord/offer/tenancy/vendor) */\nstring) | null | undefined, associatedId?: (/** The unique identifier of the related entity */\nstring) | null | undefined, fromArchive?: (/** Flag to determine if this role on the system is now archived */\nboolean) | null | undefined};",
  "src/sections/Contacts/forms/CreateContacts.example.tsx": "import { CreateContactsForm, fieldNames, CreateContactsFormFields } from '@/sections/Contacts/forms/CreateContactsForm.generated.tsx'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateContacts = () => {\n      \n\n      \n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateContactsForm >\n              <FormLayout>\n                <CreateContactsFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateContactsForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Contacts/forms/CreateContactsForm.generated.tsx": "import { CreateApiContactsBody, createApiContactsBody } from '@/sections/Contacts/services/apiTypes.generated.ts'\nimport { createContactsConfig } from '@/sections/Contacts/config/createContactsConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiContacts } from '@/sections/Contacts/services/useCreateApiContacts.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateContactsFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiContactsBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createContactsConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateContactsFormProps = {children: ReactNode, defaultValues?: CreateApiContactsBody, onSuccess?: () => void};\nexport const CreateContactsForm = (props: CreateContactsFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiContactsBody>({\n        resolver: zodResolver(createApiContactsBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiContacts()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiContactsBody>({title: true, forename: true, surname: true, dateOfBirth: true, active: true, marketingConsent: true, source: true, homePhone: true, workPhone: true, mobilePhone: true, email: true, officeIds: true, negotiatorIds: true, categoryIds: true, primaryAddress: true, secondaryAddress: true, workAddress: true, communicationPreferenceLetter: true, communicationPreferenceEmail: true, communicationPreferencePhone: true, communicationPreferenceSMS: true, metadata: true});",
  "src/schemas/createContactModel.generated.tsx": "import { CreateContactSourceModel, createContactSourceModel } from '@/schemas/createContactSourceModel.generated.tsx'\nimport { CreateContactAddressModel, createContactAddressModel } from '@/schemas/createContactAddressModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type CreateContactModel = /** Request body used to create a new contact */\n{title?: (/** The contact's title  (eg. Mr, Mrs, Miss, Dr) */\nstring) | null | undefined, forename?: (/** The contact's forename */\nstring) | null | undefined, surname: /** The contact's surname */\nstring, dateOfBirth?: (/** The contact's date of birth */\nstring) | null | undefined, active?: (/** A flag determining whether or not the contact is currently active */\nboolean) | null | undefined, marketingConsent: /** The marketing consent status of the contact (grant/deny/notAsked) */\nstring, source?: (CreateContactSourceModel) | null | undefined, homePhone?: (/** The home phone number of the contact (Required when no other contact details are provided) */\nstring) | null | undefined, workPhone?: (/** The work phone number of the contact (Required when no other contact details are provided) */\nstring) | null | undefined, mobilePhone?: (/** The mobile phone number of the contact (Required when no other contact details are provided) */\nstring) | null | undefined, email?: (/** The email address of the contact (Required when no other contact details are provided) */\nstring) | null | undefined, officeIds: /** A collection of unique identifiers of offices attached to the contact. The first item in the collection is considered the primary office */\nArray<string>, negotiatorIds: /** A collection of unique identifiers of negotiators attached to the contact. The first item in the collection is considered the primary negotiator */\nArray<string>, categoryIds?: (/** A collection of categories associated to the contact. */\nArray<string>) | null | undefined, primaryAddress?: (CreateContactAddressModel) | null | undefined, secondaryAddress?: (CreateContactAddressModel) | null | undefined, workAddress?: (CreateContactAddressModel) | null | undefined, communicationPreferenceLetter?: (/** A flag determining whether or not the contact is happy to receive communications by letter */\nboolean) | null | undefined, communicationPreferenceEmail?: (/** A flag determining whether or not the contact is happy to receive communications by email */\nboolean) | null | undefined, communicationPreferencePhone?: (/** A flag determining whether or not the contact is happy to receive communications by phone */\nboolean) | null | undefined, communicationPreferenceSMS?: (/** A flag determining whether or not the contact is happy to receive communications by SMS */\nboolean) | null | undefined, metadata?: (/** App specific metadata to set against the contact */\nRecord<string, Record<string, never>>) | null | undefined};\nexport const createContactModel = /** Request body used to create a new contact */\nz.object({title: /** The contact's title  (eg. Mr, Mrs, Miss, Dr) */\nz.string().optional().nullable(), forename: /** The contact's forename */\nz.string().optional().nullable(), surname: /** The contact's surname */\nz.string().min(1), dateOfBirth: /** The contact's date of birth */\nz.string().optional().nullable(), active: /** A flag determining whether or not the contact is currently active */\nz.boolean().optional().nullable(), marketingConsent: /** The marketing consent status of the contact (grant/deny/notAsked) */\nz.string().min(1), source: createContactSourceModel.optional().nullable(), homePhone: /** The home phone number of the contact (Required when no other contact details are provided) */\nz.string().optional().nullable(), workPhone: /** The work phone number of the contact (Required when no other contact details are provided) */\nz.string().optional().nullable(), mobilePhone: /** The mobile phone number of the contact (Required when no other contact details are provided) */\nz.string().optional().nullable(), email: /** The email address of the contact (Required when no other contact details are provided) */\nz.string().optional().nullable(), officeIds: /** A collection of unique identifiers of offices attached to the contact. The first item in the collection is considered the primary office */\nz.array(z.string().min(1)), negotiatorIds: /** A collection of unique identifiers of negotiators attached to the contact. The first item in the collection is considered the primary negotiator */\nz.array(z.string().min(1)), categoryIds: /** A collection of categories associated to the contact. */\nz.array(z.string().min(1)).optional().nullable(), primaryAddress: createContactAddressModel.optional().nullable(), secondaryAddress: createContactAddressModel.optional().nullable(), workAddress: createContactAddressModel.optional().nullable(), communicationPreferenceLetter: /** A flag determining whether or not the contact is happy to receive communications by letter */\nz.boolean().optional().nullable(), communicationPreferenceEmail: /** A flag determining whether or not the contact is happy to receive communications by email */\nz.boolean().optional().nullable(), communicationPreferencePhone: /** A flag determining whether or not the contact is happy to receive communications by phone */\nz.boolean().optional().nullable(), communicationPreferenceSMS: /** A flag determining whether or not the contact is happy to receive communications by SMS */\nz.boolean().optional().nullable(), metadata: /** App specific metadata to set against the contact */\nz.record(z.string(), z.object({})).optional().nullable()});",
  "src/schemas/createContactSourceModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateContactSourceModel = /** Request body used to set the source of a new contact */\n{id?: (/** The unique identifier of the source of the contact */\nstring) | null | undefined, type?: (/** The source type (office/source) */\nstring) | null | undefined};\nexport const createContactSourceModel = /** Request body used to set the source of a new contact */\nz.object({id: /** The unique identifier of the source of the contact */\nz.string().optional().nullable(), type: /** The source type (office/source) */\nz.string().optional().nullable()});",
  "src/schemas/createContactAddressModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateContactAddressModel = /** Request body used to set an address against a new contact */\n{type?: (/** The type of address (primary/secondary/home/work/forwarding/company/previous) */\nstring) | null | undefined, buildingName?: (/** The building name */\nstring) | null | undefined, buildingNumber?: (/** The building number */\nstring) | null | undefined, line1?: (/** The first line of the address */\nstring) | null | undefined, line2?: (/** The second line of the address */\nstring) | null | undefined, line3?: (/** The third line of the address */\nstring) | null | undefined, line4?: (/** The fourth line of the address */\nstring) | null | undefined, postcode?: (/** The postcode */\nstring) | null | undefined, countryId?: (/** The ISO-3166 country code that the address resides in */\nstring) | null | undefined};\nexport const createContactAddressModel = /** Request body used to set an address against a new contact */\nz.object({type: /** The type of address (primary/secondary/home/work/forwarding/company/previous) */\nz.string().optional().nullable(), buildingName: /** The building name */\nz.string().optional().nullable(), buildingNumber: /** The building number */\nz.string().optional().nullable(), line1: /** The first line of the address */\nz.string().optional().nullable(), line2: /** The second line of the address */\nz.string().optional().nullable(), line3: /** The third line of the address */\nz.string().optional().nullable(), line4: /** The fourth line of the address */\nz.string().optional().nullable(), postcode: /** The postcode */\nz.string().optional().nullable(), countryId: /** The ISO-3166 country code that the address resides in */\nz.string().optional().nullable()});",
  "src/sections/Contacts/config/createContactsConfig.example.tsx": "import { CreateApiContactsBody } from '@/sections/Contacts/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { DateInput } from '@/inputs/DateInput.tsx'\nimport { Switch } from '@/inputs/Switch.tsx'\nimport { OfficesInput } from '@/sections/Offices/inputs/OfficesInput.generated.tsx'\nimport { NegotiatorsInput } from '@/sections/Negotiators/inputs/NegotiatorsInput.generated.tsx'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createContactsConfig: ModelConfig<CreateApiContactsBody> = {title: {\n      key: 'title',\n      label: 'title',\n      defaultValue: '',\n      placeholder: 'title',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, forename: {\n      key: 'forename',\n      label: 'forename',\n      defaultValue: '',\n      placeholder: 'forename',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, surname: {\n      key: 'surname',\n      label: 'surname',\n      defaultValue: '',\n      placeholder: 'surname',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, dateOfBirth: {\n      key: 'dateOfBirth',\n      label: 'dateOfBirth',\n      defaultValue: null,\n      placeholder: 'dateOfBirth',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><DateInput {...props} /></InputWrap>\n    }, active: {\n      key: 'active',\n      label: 'active',\n      defaultValue: false,\n      placeholder: 'active',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><Switch {...props} /></InputWrap>\n    }, marketingConsent: {\n      key: 'marketingConsent',\n      label: 'marketingConsent',\n      defaultValue: '',\n      placeholder: 'marketingConsent',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, source: {\n      key: 'source',\n      label: 'source',\n      defaultValue: null,\n      placeholder: 'source',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, homePhone: {\n      key: 'homePhone',\n      label: 'homePhone',\n      defaultValue: '',\n      placeholder: 'homePhone',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, workPhone: {\n      key: 'workPhone',\n      label: 'workPhone',\n      defaultValue: '',\n      placeholder: 'workPhone',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, mobilePhone: {\n      key: 'mobilePhone',\n      label: 'mobilePhone',\n      defaultValue: '',\n      placeholder: 'mobilePhone',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, email: {\n      key: 'email',\n      label: 'email',\n      defaultValue: '',\n      placeholder: 'email',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, officeIds: {\n      key: 'officeIds',\n      label: 'officeIds',\n      defaultValue: [],\n      placeholder: 'officeIds',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><OfficesInput {...props} /></InputWrap>\n    }, negotiatorIds: {\n      key: 'negotiatorIds',\n      label: 'negotiatorIds',\n      defaultValue: [],\n      placeholder: 'negotiatorIds',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><NegotiatorsInput {...props} /></InputWrap>\n    }, categoryIds: {\n      key: 'categoryIds',\n      label: 'categoryIds',\n      defaultValue: [],\n      placeholder: 'categoryIds',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, primaryAddress: {\n      key: 'primaryAddress',\n      label: 'primaryAddress',\n      defaultValue: null,\n      placeholder: 'primaryAddress',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, secondaryAddress: {\n      key: 'secondaryAddress',\n      label: 'secondaryAddress',\n      defaultValue: null,\n      placeholder: 'secondaryAddress',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, workAddress: {\n      key: 'workAddress',\n      label: 'workAddress',\n      defaultValue: null,\n      placeholder: 'workAddress',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, communicationPreferenceLetter: {\n      key: 'communicationPreferenceLetter',\n      label: 'communicationPreferenceLetter',\n      defaultValue: false,\n      placeholder: 'communicationPreferenceLetter',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><Switch {...props} /></InputWrap>\n    }, communicationPreferenceEmail: {\n      key: 'communicationPreferenceEmail',\n      label: 'communicationPreferenceEmail',\n      defaultValue: false,\n      placeholder: 'communicationPreferenceEmail',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><Switch {...props} /></InputWrap>\n    }, communicationPreferencePhone: {\n      key: 'communicationPreferencePhone',\n      label: 'communicationPreferencePhone',\n      defaultValue: false,\n      placeholder: 'communicationPreferencePhone',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><Switch {...props} /></InputWrap>\n    }, communicationPreferenceSMS: {\n      key: 'communicationPreferenceSMS',\n      label: 'communicationPreferenceSMS',\n      defaultValue: false,\n      placeholder: 'communicationPreferenceSMS',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><Switch {...props} /></InputWrap>\n    }, metadata: {\n      key: 'metadata',\n      label: 'metadata',\n      defaultValue: null,\n      placeholder: 'metadata',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/Contacts/services/useCreateApiContacts.generated.ts": "import { CreateContactModel } from '@/schemas/createContactModel.generated.tsx'\nimport { createApiContactsResponse } from '@/sections/Contacts/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiContactsFnArgs = {body: CreateContactModel};\nexport const createApiContactsFn = async ({body}: CreateApiContactsFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/contacts/${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiContactsResponse.parse(data)\n    };\nexport const useCreateApiContacts = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiContactsFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Contacts']})\n        }\n      })\n    };",
  "src/sections/Contacts/tables/ContactsIdRelationshipsTable.generated.tsx": "import { useGetApiContactsIdRelationships } from '@/sections/Contacts/services/useGetApiContactsIdRelationships.generated.ts'\nimport { useState } from 'react'\nimport { useParams, useNavigate } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\n\nexport type UseContactsIdRelationshipsTableArgs = {id: string};\nexport const useContactsIdRelationshipsTable = (args: UseContactsIdRelationshipsTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiContactsIdRelationships({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const ContactsIdRelationshipsTable = () => {\n  const {id} = useParams()\n    \n    invariant(id, 'Missing id param')\n    \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useContactsIdRelationshipsTable({id}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Contacts',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New contactsIdRelationshipsTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/contacts/${id}/relationships/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Contacts/services/useGetApiContactsIdRelationships.generated.ts": "import { getApiContactsIdRelationshipsResponse } from '@/sections/Contacts/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiContactsIdRelationshipsFnArgs = {id: string, pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined};\nexport const getApiContactsIdRelationshipsFn = async ({id, pageSize, pageNumber}: GetApiContactsIdRelationshipsFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/contacts/${id}/relationships${querySerialiser({args:{pageSize, pageNumber}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiContactsIdRelationshipsResponse.parse(data)\n    };\nexport const useGetApiContactsIdRelationships = ({id, pageSize, pageNumber}: GetApiContactsIdRelationshipsFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Contacts', id, pageSize, pageNumber],\n        queryFn: () => getApiContactsIdRelationshipsFn({id, pageSize, pageNumber}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/schemas/contactRoleModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { contactRoleModel, ContactRoleModel } from '@/schemas/contactRoleModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const contactRoleModelPagedResult = z.object({_embedded: z.array(contactRoleModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type ContactRoleModelPagedResult = {_embedded?: (Array<ContactRoleModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/sections/Contacts/tables/ContactsIdSubscriptionsTable.generated.tsx": "import { useGetApiContactsIdSubscriptions } from '@/sections/Contacts/services/useGetApiContactsIdSubscriptions.generated.ts'\nimport { useState } from 'react'\nimport { useParams, useNavigate } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\n\nexport type UseContactsIdSubscriptionsTableArgs = {id: string, type?: (string) | null | undefined, status?: (string) | null | undefined};\nexport const useContactsIdSubscriptionsTable = (args: UseContactsIdSubscriptionsTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiContactsIdSubscriptions({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const ContactsIdSubscriptionsTable = () => {\n  const {id} = useParams()\n    \n    invariant(id, 'Missing id param')\n    \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useContactsIdSubscriptionsTable({id}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Contacts',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New contactsIdSubscriptionsTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/contacts/${id}/subscriptions/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Contacts/services/useGetApiContactsIdSubscriptions.generated.ts": "import { getApiContactsIdSubscriptionsResponse } from '@/sections/Contacts/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiContactsIdSubscriptionsFnArgs = {id: string, pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, type?: (string) | null | undefined, status?: (string) | null | undefined};\nexport const getApiContactsIdSubscriptionsFn = async ({id, pageSize, pageNumber, type, status}: GetApiContactsIdSubscriptionsFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/contacts/${id}/subscriptions${querySerialiser({args:{pageSize, pageNumber, type, status}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiContactsIdSubscriptionsResponse.parse(data)\n    };\nexport const useGetApiContactsIdSubscriptions = ({id, pageSize, pageNumber, type, status}: GetApiContactsIdSubscriptionsFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Contacts', id, pageSize, pageNumber, type, status],\n        queryFn: () => getApiContactsIdSubscriptionsFn({id, pageSize, pageNumber, type, status}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/schemas/contactSubscriptionModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { contactSubscriptionModel, ContactSubscriptionModel } from '@/schemas/contactSubscriptionModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const contactSubscriptionModelPagedResult = z.object({_embedded: z.array(contactSubscriptionModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type ContactSubscriptionModelPagedResult = {_embedded?: (Array<ContactSubscriptionModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/contactSubscriptionModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\n\nexport const contactSubscriptionModel = /** Representation of an individual contact subscription */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the subscription */\nz.string().optional().nullable(), contactId: /** The unique identifier of the contact the subscription is associated with */\nz.string().optional().nullable(), name: /** The name of the subscription */\nz.string().optional().nullable(), group: /** The name of the group this subscription belongs to, if applicable */\nz.string().optional().nullable(), status: /** The status of the subscription (subscribed/unsubscribed) */\nz.string().optional().nullable(), type: /** The type of subscription (mailing/event) */\nz.string().optional().nullable(), subscribedOn: /** The date and time when the subscription was started for the associated contact */\nz.string().pipe( z.coerce.date() ).optional().nullable(), unsubscribedOn: /** The date and time when the subscription was terminated for the associated contact */\nz.string().pipe( z.coerce.date() ).optional().nullable()});\nexport type ContactSubscriptionModel = /** Representation of an individual contact subscription */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the subscription */\nstring) | null | undefined, contactId?: (/** The unique identifier of the contact the subscription is associated with */\nstring) | null | undefined, name?: (/** The name of the subscription */\nstring) | null | undefined, group?: (/** The name of the group this subscription belongs to, if applicable */\nstring) | null | undefined, status?: (/** The status of the subscription (subscribed/unsubscribed) */\nstring) | null | undefined, type?: (/** The type of subscription (mailing/event) */\nstring) | null | undefined, subscribedOn?: (/** The date and time when the subscription was started for the associated contact */\nDate) | null | undefined, unsubscribedOn?: (/** The date and time when the subscription was terminated for the associated contact */\nDate) | null | undefined};",
  "src/sections/Conveyancing/tables/ConveyancingTable.generated.tsx": "import { useGetApiConveyancing } from '@/sections/Conveyancing/services/useGetApiConveyancing.generated.ts'\nimport { useState } from 'react'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\nimport { useNavigate } from 'react-router-dom'\n\nexport type UseConveyancingTableArgs = {sortBy?: (string) | null | undefined, id?: (Array<string>) | null | undefined, propertyId?: (Array<string>) | null | undefined, buyerId?: (Array<string>) | null | undefined, embed?: (Array<'buyerSolicitor' | 'offer' | 'property' | 'vendor' | 'vendorSolicitor'>) | null | undefined, metadata?: (Array<string>) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined};\nexport const useConveyancingTable = (args: UseConveyancingTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiConveyancing({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const ConveyancingTable = () => {\n  \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useConveyancingTable({}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Conveyancing',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New conveyancingTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/conveyancing/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Conveyancing/services/useGetApiConveyancing.generated.ts": "import { getApiConveyancingResponse } from '@/sections/Conveyancing/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConveyancingFnArgs = {pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, sortBy?: (string) | null | undefined, id?: (Array<string>) | null | undefined, propertyId?: (Array<string>) | null | undefined, buyerId?: (Array<string>) | null | undefined, embed?: (Array<'buyerSolicitor' | 'offer' | 'property' | 'vendor' | 'vendorSolicitor'>) | null | undefined, metadata?: (Array<string>) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined};\nexport const getApiConveyancingFn = async ({pageSize, pageNumber, sortBy, id, propertyId, buyerId, embed, metadata, createdFrom, createdTo, modifiedFrom, modifiedTo}: GetApiConveyancingFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/conveyancing/${querySerialiser({args:{pageSize, pageNumber, sortBy, id, propertyId, buyerId, embed, metadata, createdFrom, createdTo, modifiedFrom, modifiedTo}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConveyancingResponse.parse(data)\n    };\nexport const useGetApiConveyancing = ({pageSize, pageNumber, sortBy, id, propertyId, buyerId, embed, metadata, createdFrom, createdTo, modifiedFrom, modifiedTo}: GetApiConveyancingFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Conveyancing', pageSize, pageNumber, sortBy, id, propertyId, buyerId, embed, metadata, createdFrom, createdTo, modifiedFrom, modifiedTo],\n        queryFn: () => getApiConveyancingFn({pageSize, pageNumber, sortBy, id, propertyId, buyerId, embed, metadata, createdFrom, createdTo, modifiedFrom, modifiedTo}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Conveyancing/services/apiTypes.generated.ts": "import { conveyancingModelPagedResult } from '@/schemas/conveyancingModelPagedResult.generated.tsx'\nimport { CreateDownwardLinkModel, createDownwardLinkModel } from '@/schemas/createDownwardLinkModel.generated.tsx'\nimport { z } from 'zod'\nimport { CreateUpwardLinkModel, createUpwardLinkModel } from '@/schemas/createUpwardLinkModel.generated.tsx'\nimport { conveyancingModel } from '@/schemas/conveyancingModel.generated.tsx'\n\nexport const getApiConveyancingResponse = conveyancingModelPagedResult;\nexport const getApiConveyancingIdChainResponse = conveyancingModelPagedResult;\nexport type CreateApiConveyancingIdDownwardBody = CreateDownwardLinkModel;\nexport const createApiConveyancingIdDownwardBody = createDownwardLinkModel;\nexport const createApiConveyancingIdDownwardResponse = z.void();\nexport type CreateApiConveyancingIdUpwardBody = CreateUpwardLinkModel;\nexport const createApiConveyancingIdUpwardBody = createUpwardLinkModel;\nexport const createApiConveyancingIdUpwardResponse = z.void();\nexport const getApiConveyancingIdResponse = conveyancingModel;\nexport const patchApiConveyancingIdResponse = z.void();\nexport const deleteApiConveyancingIdDownwardResponse = z.void();\nexport const deleteApiConveyancingIdUpwardResponse = z.void();",
  "src/schemas/conveyancingModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { conveyancingModel, ConveyancingModel } from '@/schemas/conveyancingModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const conveyancingModelPagedResult = z.object({_embedded: z.array(conveyancingModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type ConveyancingModelPagedResult = {_embedded?: (Array<ConveyancingModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/conveyancingModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\nimport { checkListItemModel, CheckListItemModel } from '@/schemas/checkListItemModel.generated.tsx'\n\nexport const conveyancingModel = /** Representation of an offers sales progression information */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the offer */\nz.string().optional().nullable(), created: /** The date and time when the offer was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the offer was modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), isExternal: /** Flag set to true if this offer is external */\nz.boolean().optional().nullable(), propertyId: /** The unique identifier of the property that this offer is associated to. Empty if the offer is external and relates to a property not instructed to the agent */\nz.string().optional().nullable(), propertyAddress: /** The address of the property that this offer is associated to */\nz.string().optional().nullable(), vendor: /** The full name of the vendor of the property */\nz.string().optional().nullable(), vendorId: /** The unique identifier of the vendor that this offer is associated to. Empty if the offer is external and relates to a property not instructed to the agent */\nz.string().optional().nullable(), vendorSolicitorId: /** The unique identifier of the solicitor / conveyancer that the vendor has instructed */\nz.string().optional().nullable(), buyer: /** The full name of the buyer who has submitted the offer */\nz.string().optional().nullable(), buyerId: /** The unique identifier of the contact that represents this buyer. Empty if the offer is external and relates to a property not instructed to the agent */\nz.string().optional().nullable(), buyerSolicitorId: /** The unique identifier of the solicitor / conveyancer that the buyer has instructed */\nz.string().optional().nullable(), externalAgent: /** The name of the agent who is marketing the property, where the offer is external and and relates to a property not instructed to the agent */\nz.string().optional().nullable(), externalAgentId: /** The unique identifier of the agent company that holds the property instruction */\nz.string().optional().nullable(), upwardChainId: /** The unique identifier of the offer that sits above this one in the chain (where known) */\nz.string().optional().nullable(), downwardChainId: /** The unique identifier of the offer that sits below this one in the chain (where known) */\nz.string().optional().nullable(), fixturesAndFittingsCompleted: /** The date when the fixtures and fittings form has been completed */\nz.string().optional().nullable(), deedsRequested: /** The date when the title deeds were requested from land registry */\nz.string().optional().nullable(), deedsReceived: /** The date when the title deeds were received from land registry */\nz.string().optional().nullable(), enquiriesSent: /** The date when the legal enquiries raised by the buyers solicitor were sent */\nz.string().optional().nullable(), enquiriesAnswered: /** The date when the legal enquiries raised by the buyers solicitor were answered */\nz.string().optional().nullable(), searchesPaid: /** The date when the buyer paid for conveyancing searches */\nz.string().optional().nullable(), searchesApplied: /** The date when conveyancing searches were applied for */\nz.string().optional().nullable(), searchesReceived: /** The date when conveyancing searches were received for */\nz.string().optional().nullable(), contractSent: /** The date when the draft contract was sent */\nz.string().optional().nullable(), contractReceived: /** The date when the draft contract was received */\nz.string().optional().nullable(), contractApproved: /** The date when the contract was approved */\nz.string().optional().nullable(), contractVendorSigned: /** The date when the vendor signed the approved contract */\nz.string().optional().nullable(), contractBuyerSigned: /** The date when the buyer signed the approved contract */\nz.string().optional().nullable(), mortgageRequired: /** Indication of whether the buyer will require a mortgage to fund the purchase (yes/no/unknown) */\nz.string().optional().nullable(), mortgageLoanPercentage: /** The loan to value percentage of the mortgage required */\nz.number().int().optional().nullable(), mortgageSubmitted: /** The date when the mortgage application was submitted */\nz.string().optional().nullable(), mortgageOfferReceived: /** The date when the mortgage offer was received */\nz.string().optional().nullable(), mortgageLenderId: /** The unique identifier of the company who will provide the mortgage */\nz.string().optional().nullable(), mortgageBrokerId: /** The unique identifier of the company who brokered the mortgage */\nz.string().optional().nullable(), mortgageSurveyDate: /** The date of the mortgage valuation/survey */\nz.string().optional().nullable(), mortgageSurveyorId: /** The unique identifier of the company who will perform the mortgage valuation/survey */\nz.string().optional().nullable(), additionalSurveyRequired: /** Indication of whether the buyer requires that an additional survey take place  (yes/no/unknown) */\nz.string().optional().nullable(), additionalSurveyDate: /** The date of the additional survey */\nz.string().optional().nullable(), additionalSurveyorId: /** The unique identifier of the company who will perform the additional survey */\nz.string().optional().nullable(), exchangedVendor: /** The date when the vendor conveyancer confirms the exchange */\nz.string().optional().nullable(), exchangedBuyer: /** The date when the buyer conveyancer confirms the exchange */\nz.string().optional().nullable(), completion: /** The date when the sale completed */\nz.string().optional().nullable(), checkListItems: /** Check list items to be completed as part of the sales progression process */\nz.array(checkListItemModel).optional().nullable(), _eTag: /** The ETag for the current version of this conveyancing record. Used for managing update concurrency */\nz.string().optional().nullable(), metadata: /** App specific metadata that has been set against this conveyancing record */\nz.record(z.string(), z.object({})).optional().nullable()});\nexport type ConveyancingModel = /** Representation of an offers sales progression information */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the offer */\nstring) | null | undefined, created?: (/** The date and time when the offer was created */\nDate) | null | undefined, modified?: (/** The date and time when the offer was modified */\nDate) | null | undefined, isExternal?: (/** Flag set to true if this offer is external */\nboolean) | null | undefined, propertyId?: (/** The unique identifier of the property that this offer is associated to. Empty if the offer is external and relates to a property not instructed to the agent */\nstring) | null | undefined, propertyAddress?: (/** The address of the property that this offer is associated to */\nstring) | null | undefined, vendor?: (/** The full name of the vendor of the property */\nstring) | null | undefined, vendorId?: (/** The unique identifier of the vendor that this offer is associated to. Empty if the offer is external and relates to a property not instructed to the agent */\nstring) | null | undefined, vendorSolicitorId?: (/** The unique identifier of the solicitor / conveyancer that the vendor has instructed */\nstring) | null | undefined, buyer?: (/** The full name of the buyer who has submitted the offer */\nstring) | null | undefined, buyerId?: (/** The unique identifier of the contact that represents this buyer. Empty if the offer is external and relates to a property not instructed to the agent */\nstring) | null | undefined, buyerSolicitorId?: (/** The unique identifier of the solicitor / conveyancer that the buyer has instructed */\nstring) | null | undefined, externalAgent?: (/** The name of the agent who is marketing the property, where the offer is external and and relates to a property not instructed to the agent */\nstring) | null | undefined, externalAgentId?: (/** The unique identifier of the agent company that holds the property instruction */\nstring) | null | undefined, upwardChainId?: (/** The unique identifier of the offer that sits above this one in the chain (where known) */\nstring) | null | undefined, downwardChainId?: (/** The unique identifier of the offer that sits below this one in the chain (where known) */\nstring) | null | undefined, fixturesAndFittingsCompleted?: (/** The date when the fixtures and fittings form has been completed */\nstring) | null | undefined, deedsRequested?: (/** The date when the title deeds were requested from land registry */\nstring) | null | undefined, deedsReceived?: (/** The date when the title deeds were received from land registry */\nstring) | null | undefined, enquiriesSent?: (/** The date when the legal enquiries raised by the buyers solicitor were sent */\nstring) | null | undefined, enquiriesAnswered?: (/** The date when the legal enquiries raised by the buyers solicitor were answered */\nstring) | null | undefined, searchesPaid?: (/** The date when the buyer paid for conveyancing searches */\nstring) | null | undefined, searchesApplied?: (/** The date when conveyancing searches were applied for */\nstring) | null | undefined, searchesReceived?: (/** The date when conveyancing searches were received for */\nstring) | null | undefined, contractSent?: (/** The date when the draft contract was sent */\nstring) | null | undefined, contractReceived?: (/** The date when the draft contract was received */\nstring) | null | undefined, contractApproved?: (/** The date when the contract was approved */\nstring) | null | undefined, contractVendorSigned?: (/** The date when the vendor signed the approved contract */\nstring) | null | undefined, contractBuyerSigned?: (/** The date when the buyer signed the approved contract */\nstring) | null | undefined, mortgageRequired?: (/** Indication of whether the buyer will require a mortgage to fund the purchase (yes/no/unknown) */\nstring) | null | undefined, mortgageLoanPercentage?: (/** The loan to value percentage of the mortgage required */\nnumber) | null | undefined, mortgageSubmitted?: (/** The date when the mortgage application was submitted */\nstring) | null | undefined, mortgageOfferReceived?: (/** The date when the mortgage offer was received */\nstring) | null | undefined, mortgageLenderId?: (/** The unique identifier of the company who will provide the mortgage */\nstring) | null | undefined, mortgageBrokerId?: (/** The unique identifier of the company who brokered the mortgage */\nstring) | null | undefined, mortgageSurveyDate?: (/** The date of the mortgage valuation/survey */\nstring) | null | undefined, mortgageSurveyorId?: (/** The unique identifier of the company who will perform the mortgage valuation/survey */\nstring) | null | undefined, additionalSurveyRequired?: (/** Indication of whether the buyer requires that an additional survey take place  (yes/no/unknown) */\nstring) | null | undefined, additionalSurveyDate?: (/** The date of the additional survey */\nstring) | null | undefined, additionalSurveyorId?: (/** The unique identifier of the company who will perform the additional survey */\nstring) | null | undefined, exchangedVendor?: (/** The date when the vendor conveyancer confirms the exchange */\nstring) | null | undefined, exchangedBuyer?: (/** The date when the buyer conveyancer confirms the exchange */\nstring) | null | undefined, completion?: (/** The date when the sale completed */\nstring) | null | undefined, checkListItems?: (/** Check list items to be completed as part of the sales progression process */\nArray<CheckListItemModel>) | null | undefined, _eTag?: (/** The ETag for the current version of this conveyancing record. Used for managing update concurrency */\nstring) | null | undefined, metadata?: (/** App specific metadata that has been set against this conveyancing record */\nRecord<string, Record<string, never>>) | null | undefined};",
  "src/schemas/checkListItemModel.generated.tsx": "import { z } from 'zod'\n\nexport const checkListItemModel = /** Representation of a check list item */\nz.object({name: /** The name of the check list item */\nz.string().optional().nullable(), completed: /** A flag to determine if the item is completed */\nz.boolean().optional().nullable(), completedDate: /** The date when the item was completed */\nz.string().optional().nullable()});\nexport type CheckListItemModel = /** Representation of a check list item */\n{name?: (/** The name of the check list item */\nstring) | null | undefined, completed?: (/** A flag to determine if the item is completed */\nboolean) | null | undefined, completedDate?: (/** The date when the item was completed */\nstring) | null | undefined};",
  "src/sections/Conveyancing/tables/ConveyancingIdChainTable.generated.tsx": "import { useGetApiConveyancingIdChain } from '@/sections/Conveyancing/services/useGetApiConveyancingIdChain.generated.ts'\nimport { useState } from 'react'\nimport { useParams, useNavigate } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\n\nexport type UseConveyancingIdChainTableArgs = {id: string, sortBy?: (string) | null | undefined};\nexport const useConveyancingIdChainTable = (args: UseConveyancingIdChainTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiConveyancingIdChain({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const ConveyancingIdChainTable = () => {\n  const {id} = useParams()\n    \n    invariant(id, 'Missing id param')\n    \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useConveyancingIdChainTable({id}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Conveyancing',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New conveyancingIdChainTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/conveyancing/${id}/chain/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Conveyancing/services/useGetApiConveyancingIdChain.generated.ts": "import { getApiConveyancingIdChainResponse } from '@/sections/Conveyancing/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConveyancingIdChainFnArgs = {id: string, pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, sortBy?: (string) | null | undefined};\nexport const getApiConveyancingIdChainFn = async ({id, pageSize, pageNumber, sortBy}: GetApiConveyancingIdChainFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/conveyancing/${id}/chain${querySerialiser({args:{pageSize, pageNumber, sortBy}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConveyancingIdChainResponse.parse(data)\n    };\nexport const useGetApiConveyancingIdChain = ({id, pageSize, pageNumber, sortBy}: GetApiConveyancingIdChainFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Conveyancing', id, pageSize, pageNumber, sortBy],\n        queryFn: () => getApiConveyancingIdChainFn({id, pageSize, pageNumber, sortBy}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Conveyancing/forms/CreateConveyancingIdDownward.example.tsx": "import { CreateConveyancingIdDownwardForm, fieldNames, CreateConveyancingIdDownwardFormFields } from '@/sections/Conveyancing/forms/CreateConveyancingIdDownwardForm.generated.tsx'\nimport { useParams } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateConveyancingIdDownward = () => {\n      const { id } = useParams()\n\n      invariant(id, 'Expected id to be defined')\n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateConveyancingIdDownwardForm id={id}>\n              <FormLayout>\n                <CreateConveyancingIdDownwardFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateConveyancingIdDownwardForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Conveyancing/forms/CreateConveyancingIdDownwardForm.generated.tsx": "import { CreateApiConveyancingIdDownwardBody, createApiConveyancingIdDownwardBody } from '@/sections/Conveyancing/services/apiTypes.generated.ts'\nimport { createConveyancingIdDownwardConfig } from '@/sections/Conveyancing/config/createConveyancingIdDownwardConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiConveyancingIdDownward } from '@/sections/Conveyancing/services/useCreateApiConveyancingIdDownward.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateConveyancingIdDownwardFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiConveyancingIdDownwardBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createConveyancingIdDownwardConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateConveyancingIdDownwardFormProps = {id: string, children: ReactNode, defaultValues?: CreateApiConveyancingIdDownwardBody, onSuccess?: () => void};\nexport const CreateConveyancingIdDownwardForm = (props: CreateConveyancingIdDownwardFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiConveyancingIdDownwardBody>({\n        resolver: zodResolver(createApiConveyancingIdDownwardBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiConveyancingIdDownward()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiConveyancingIdDownwardBody>({offerId: true, propertyAddress: true, agent: true, buyer: true, buyerSolicitorId: true});",
  "src/schemas/createDownwardLinkModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateDownwardLinkModel = /** Request body for associating this offer to another one below it in the chain */\n{offerId?: (/** The unique identifier of the offer below this one in the chain. Should be left empty if the upward property is external (instructed by another agent) */\nstring) | null | undefined, propertyAddress?: (/** The address of the property below this one in the chain. (Required when 'offerId' is not provided) */\nstring) | null | undefined, agent?: (/** The name of the agent managing the sale of the property. (Required when 'offerId' is not provided) */\nstring) | null | undefined, buyer?: (/** The name of the buyer purchasing the property. (Required when 'offerId' is not provided) */\nstring) | null | undefined, buyerSolicitorId?: (/** The unique identifier of the solicitor / conveyancer that the buyer has instructed. (Required when 'offerId' is not provided) */\nstring) | null | undefined};\nexport const createDownwardLinkModel = /** Request body for associating this offer to another one below it in the chain */\nz.object({offerId: /** The unique identifier of the offer below this one in the chain. Should be left empty if the upward property is external (instructed by another agent) */\nz.string().optional().nullable(), propertyAddress: /** The address of the property below this one in the chain. (Required when 'offerId' is not provided) */\nz.string().optional().nullable(), agent: /** The name of the agent managing the sale of the property. (Required when 'offerId' is not provided) */\nz.string().optional().nullable(), buyer: /** The name of the buyer purchasing the property. (Required when 'offerId' is not provided) */\nz.string().optional().nullable(), buyerSolicitorId: /** The unique identifier of the solicitor / conveyancer that the buyer has instructed. (Required when 'offerId' is not provided) */\nz.string().optional().nullable()});",
  "src/sections/Conveyancing/config/createConveyancingIdDownwardConfig.example.tsx": "import { CreateApiConveyancingIdDownwardBody } from '@/sections/Conveyancing/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createConveyancingIdDownwardConfig: ModelConfig<CreateApiConveyancingIdDownwardBody> = {offerId: {\n      key: 'offerId',\n      label: 'offerId',\n      defaultValue: '',\n      placeholder: 'offerId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, propertyAddress: {\n      key: 'propertyAddress',\n      label: 'propertyAddress',\n      defaultValue: '',\n      placeholder: 'propertyAddress',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, agent: {\n      key: 'agent',\n      label: 'agent',\n      defaultValue: '',\n      placeholder: 'agent',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, buyer: {\n      key: 'buyer',\n      label: 'buyer',\n      defaultValue: '',\n      placeholder: 'buyer',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, buyerSolicitorId: {\n      key: 'buyerSolicitorId',\n      label: 'buyerSolicitorId',\n      defaultValue: '',\n      placeholder: 'buyerSolicitorId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/Conveyancing/services/useCreateApiConveyancingIdDownward.generated.ts": "import { CreateDownwardLinkModel } from '@/schemas/createDownwardLinkModel.generated.tsx'\nimport { createApiConveyancingIdDownwardResponse } from '@/sections/Conveyancing/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiConveyancingIdDownwardFnArgs = {id: string, body: CreateDownwardLinkModel};\nexport const createApiConveyancingIdDownwardFn = async ({id, body}: CreateApiConveyancingIdDownwardFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/conveyancing/${id}/downward${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiConveyancingIdDownwardResponse.parse(data)\n    };\nexport const useCreateApiConveyancingIdDownward = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiConveyancingIdDownwardFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Conveyancing']})\n        }\n      })\n    };",
  "src/sections/Conveyancing/forms/CreateConveyancingIdUpward.example.tsx": "import { CreateConveyancingIdUpwardForm, fieldNames, CreateConveyancingIdUpwardFormFields } from '@/sections/Conveyancing/forms/CreateConveyancingIdUpwardForm.generated.tsx'\nimport { useParams } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateConveyancingIdUpward = () => {\n      const { id } = useParams()\n\n      invariant(id, 'Expected id to be defined')\n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateConveyancingIdUpwardForm id={id}>\n              <FormLayout>\n                <CreateConveyancingIdUpwardFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateConveyancingIdUpwardForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Conveyancing/forms/CreateConveyancingIdUpwardForm.generated.tsx": "import { CreateApiConveyancingIdUpwardBody, createApiConveyancingIdUpwardBody } from '@/sections/Conveyancing/services/apiTypes.generated.ts'\nimport { createConveyancingIdUpwardConfig } from '@/sections/Conveyancing/config/createConveyancingIdUpwardConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiConveyancingIdUpward } from '@/sections/Conveyancing/services/useCreateApiConveyancingIdUpward.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateConveyancingIdUpwardFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiConveyancingIdUpwardBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createConveyancingIdUpwardConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateConveyancingIdUpwardFormProps = {id: string, children: ReactNode, defaultValues?: CreateApiConveyancingIdUpwardBody, onSuccess?: () => void};\nexport const CreateConveyancingIdUpwardForm = (props: CreateConveyancingIdUpwardFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiConveyancingIdUpwardBody>({\n        resolver: zodResolver(createApiConveyancingIdUpwardBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiConveyancingIdUpward()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiConveyancingIdUpwardBody>({offerId: true, propertyAddress: true, agent: true, vendor: true, vendorSolicitorId: true});",
  "src/schemas/createUpwardLinkModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateUpwardLinkModel = /** Request body for associating this offer to another one above it in the chain */\n{offerId?: (/** The unique identifier of the offer above this one in the chain. Should be left empty if the upward property is external (instructed by another agent) */\nstring) | null | undefined, propertyAddress?: (/** The address of the property above this one in the chain. (Required when 'offerId' is not provided) */\nstring) | null | undefined, agent?: (/** The name of the agent managing the sale of the property. (Required when 'offerId' is not provided) */\nstring) | null | undefined, vendor?: (/** The name of the vendor selling the property. (Required when 'offerId' is not provided) */\nstring) | null | undefined, vendorSolicitorId?: (/** The unique identifier of the solicitor / conveyancer that the vendor has instructed. (Required when 'offerId' is not provided) */\nstring) | null | undefined};\nexport const createUpwardLinkModel = /** Request body for associating this offer to another one above it in the chain */\nz.object({offerId: /** The unique identifier of the offer above this one in the chain. Should be left empty if the upward property is external (instructed by another agent) */\nz.string().optional().nullable(), propertyAddress: /** The address of the property above this one in the chain. (Required when 'offerId' is not provided) */\nz.string().optional().nullable(), agent: /** The name of the agent managing the sale of the property. (Required when 'offerId' is not provided) */\nz.string().optional().nullable(), vendor: /** The name of the vendor selling the property. (Required when 'offerId' is not provided) */\nz.string().optional().nullable(), vendorSolicitorId: /** The unique identifier of the solicitor / conveyancer that the vendor has instructed. (Required when 'offerId' is not provided) */\nz.string().optional().nullable()});",
  "src/sections/Conveyancing/config/createConveyancingIdUpwardConfig.example.tsx": "import { CreateApiConveyancingIdUpwardBody } from '@/sections/Conveyancing/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createConveyancingIdUpwardConfig: ModelConfig<CreateApiConveyancingIdUpwardBody> = {offerId: {\n      key: 'offerId',\n      label: 'offerId',\n      defaultValue: '',\n      placeholder: 'offerId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, propertyAddress: {\n      key: 'propertyAddress',\n      label: 'propertyAddress',\n      defaultValue: '',\n      placeholder: 'propertyAddress',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, agent: {\n      key: 'agent',\n      label: 'agent',\n      defaultValue: '',\n      placeholder: 'agent',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, vendor: {\n      key: 'vendor',\n      label: 'vendor',\n      defaultValue: '',\n      placeholder: 'vendor',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, vendorSolicitorId: {\n      key: 'vendorSolicitorId',\n      label: 'vendorSolicitorId',\n      defaultValue: '',\n      placeholder: 'vendorSolicitorId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/Conveyancing/services/useCreateApiConveyancingIdUpward.generated.ts": "import { CreateUpwardLinkModel } from '@/schemas/createUpwardLinkModel.generated.tsx'\nimport { createApiConveyancingIdUpwardResponse } from '@/sections/Conveyancing/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiConveyancingIdUpwardFnArgs = {id: string, body: CreateUpwardLinkModel};\nexport const createApiConveyancingIdUpwardFn = async ({id, body}: CreateApiConveyancingIdUpwardFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/conveyancing/${id}/upward${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiConveyancingIdUpwardResponse.parse(data)\n    };\nexport const useCreateApiConveyancingIdUpward = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiConveyancingIdUpwardFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Conveyancing']})\n        }\n      })\n    };",
  "src/sections/Departments/tables/DepartmentsTable.generated.tsx": "import { useGetApiDepartments } from '@/sections/Departments/services/useGetApiDepartments.generated.ts'\nimport { useState } from 'react'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\nimport { useNavigate } from 'react-router-dom'\n\nexport type UseDepartmentsTableArgs = {id?: (Array<string>) | null | undefined, name?: (string) | null | undefined};\nexport const useDepartmentsTable = (args: UseDepartmentsTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiDepartments({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const DepartmentsTable = () => {\n  \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useDepartmentsTable({}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Departments',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New departmentsTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/departments/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Departments/services/useGetApiDepartments.generated.ts": "import { getApiDepartmentsResponse } from '@/sections/Departments/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiDepartmentsFnArgs = {pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, id?: (Array<string>) | null | undefined, name?: (string) | null | undefined};\nexport const getApiDepartmentsFn = async ({pageSize, pageNumber, id, name}: GetApiDepartmentsFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/departments/${querySerialiser({args:{pageSize, pageNumber, id, name}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiDepartmentsResponse.parse(data)\n    };\nexport const useGetApiDepartments = ({pageSize, pageNumber, id, name}: GetApiDepartmentsFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Departments', pageSize, pageNumber, id, name],\n        queryFn: () => getApiDepartmentsFn({pageSize, pageNumber, id, name}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Departments/services/apiTypes.generated.ts": "import { departmentModelPagedResult } from '@/schemas/departmentModelPagedResult.generated.tsx'\nimport { departmentModel } from '@/schemas/departmentModel.generated.tsx'\n\nexport const getApiDepartmentsResponse = departmentModelPagedResult;\nexport const getApiDepartmentsIdResponse = departmentModel;",
  "src/schemas/departmentModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { departmentModel, DepartmentModel } from '@/schemas/departmentModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const departmentModelPagedResult = z.object({_embedded: z.array(departmentModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type DepartmentModelPagedResult = {_embedded?: (Array<DepartmentModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/departmentModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\n\nexport const departmentModel = /** Representation of a department */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the department */\nz.string().optional().nullable(), created: /** The date and time when the department was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the department was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), name: /** The name of the department */\nz.string().optional().nullable(), typeOptions: /** A collection of property type values that will be accepted by other services\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nz.array(z.string().min(1)).optional().nullable(), styleOptions: /** A collection of property style values that will be accepted by other services\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nz.array(z.string().min(1)).optional().nullable(), situationOptions: /** A collection of property situation values that will be accepted by other services\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nz.array(z.string().min(1)).optional().nullable(), parkingOptions: /** A collection of property parking values that will be accepted by other services\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nz.array(z.string().min(1)).optional().nullable(), ageOptions: /** A collection of property age values that will be accepted by other services\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nz.array(z.string().min(1)).optional().nullable(), localityOptions: /** A collection of property locality values that will be accepted by other services\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nz.array(z.string().min(1)).optional().nullable(), specialFeaturesOptions: /** A collection of special property feature values that will be presented by other services */\nz.array(z.string().min(1)).optional().nullable(), commercialUseClassOptions: /** A collection of commercial use class values that will be accepted by other services */\nz.array(z.string().min(1)).optional().nullable(), commercialFloorLevelOptions: /** A collection of commercial floor level values that will be accepted by other services */\nz.array(z.string().min(1)).optional().nullable(), hasBedrooms: /** A flag to determing if the department has bedrooms configured */\nz.boolean().optional().nullable(), hasBathrooms: /** A flag to determing if the department has bathrooms configured */\nz.boolean().optional().nullable(), hasReceptionRooms: /** A flag to determing if the department has reception rooms configured */\nz.boolean().optional().nullable(), hasParkingSpaces: /** A flag to determing if the department has parking spaces configured */\nz.boolean().optional().nullable(), hasFloorLevelEnabled: /** A flag to determing if the department allows the floor level property to be set */\nz.boolean().optional().nullable(), hasInternalFloorsEnabled: /** A flag to determing if the department allows the internal floors property to be set */\nz.boolean().optional().nullable(), hasTotalFloorsEnabled: /** A flag to determing if the department allows the total floors property to be set */\nz.boolean().optional().nullable(), _eTag: /** The ETag for the current version of the department. Used for managing update concurrency */\nz.string().optional().nullable()});\nexport type DepartmentModel = /** Representation of a department */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the department */\nstring) | null | undefined, created?: (/** The date and time when the department was created */\nDate) | null | undefined, modified?: (/** The date and time when the department was last modified */\nDate) | null | undefined, name?: (/** The name of the department */\nstring) | null | undefined, typeOptions?: (/** A collection of property type values that will be accepted by other services\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nArray<string>) | null | undefined, styleOptions?: (/** A collection of property style values that will be accepted by other services\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nArray<string>) | null | undefined, situationOptions?: (/** A collection of property situation values that will be accepted by other services\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nArray<string>) | null | undefined, parkingOptions?: (/** A collection of property parking values that will be accepted by other services\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nArray<string>) | null | undefined, ageOptions?: (/** A collection of property age values that will be accepted by other services\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nArray<string>) | null | undefined, localityOptions?: (/** A collection of property locality values that will be accepted by other services\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nArray<string>) | null | undefined, specialFeaturesOptions?: (/** A collection of special property feature values that will be presented by other services */\nArray<string>) | null | undefined, commercialUseClassOptions?: (/** A collection of commercial use class values that will be accepted by other services */\nArray<string>) | null | undefined, commercialFloorLevelOptions?: (/** A collection of commercial floor level values that will be accepted by other services */\nArray<string>) | null | undefined, hasBedrooms?: (/** A flag to determing if the department has bedrooms configured */\nboolean) | null | undefined, hasBathrooms?: (/** A flag to determing if the department has bathrooms configured */\nboolean) | null | undefined, hasReceptionRooms?: (/** A flag to determing if the department has reception rooms configured */\nboolean) | null | undefined, hasParkingSpaces?: (/** A flag to determing if the department has parking spaces configured */\nboolean) | null | undefined, hasFloorLevelEnabled?: (/** A flag to determing if the department allows the floor level property to be set */\nboolean) | null | undefined, hasInternalFloorsEnabled?: (/** A flag to determing if the department allows the internal floors property to be set */\nboolean) | null | undefined, hasTotalFloorsEnabled?: (/** A flag to determing if the department allows the total floors property to be set */\nboolean) | null | undefined, _eTag?: (/** The ETag for the current version of the department. Used for managing update concurrency */\nstring) | null | undefined};",
  "src/sections/Documents/tables/DocumentsTable.generated.tsx": "import { useGetApiDocuments } from '@/sections/Documents/services/useGetApiDocuments.generated.ts'\nimport { useState } from 'react'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\nimport { useNavigate } from 'react-router-dom'\n\nexport type UseDocumentsTableArgs = {sortBy?: (string) | null | undefined, embed?: (Array<'documentType'>) | null | undefined, id?: (Array<string>) | null | undefined, associatedId?: (Array<string>) | null | undefined, associatedType?: (Array<'appliance' | 'applicant' | 'bankStatement' | 'batch' | 'certificate' | 'contact' | 'depositCertificate' | 'estate' | 'estateUnit' | 'idCheck' | 'keySet' | 'landlord' | 'nominalTransaction' | 'property' | 'tenancy' | 'tenancyCheck' | 'tenancyRenewal' | 'worksOrder'>) | null | undefined, typeId?: (Array<string>) | null | undefined, includeRoleDocuments?: (boolean) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, metadata?: (Array<string>) | null | undefined};\nexport const useDocumentsTable = (args: UseDocumentsTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiDocuments({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const DocumentsTable = () => {\n  \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useDocumentsTable({}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Documents',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New documentsTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/documents/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Documents/services/useGetApiDocuments.generated.ts": "import { getApiDocumentsResponse } from '@/sections/Documents/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiDocumentsFnArgs = {pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, sortBy?: (string) | null | undefined, embed?: (Array<'documentType'>) | null | undefined, id?: (Array<string>) | null | undefined, associatedId?: (Array<string>) | null | undefined, associatedType?: (Array<'appliance' | 'applicant' | 'bankStatement' | 'batch' | 'certificate' | 'contact' | 'depositCertificate' | 'estate' | 'estateUnit' | 'idCheck' | 'keySet' | 'landlord' | 'nominalTransaction' | 'property' | 'tenancy' | 'tenancyCheck' | 'tenancyRenewal' | 'worksOrder'>) | null | undefined, typeId?: (Array<string>) | null | undefined, includeRoleDocuments?: (boolean) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, metadata?: (Array<string>) | null | undefined};\nexport const getApiDocumentsFn = async ({pageSize, pageNumber, sortBy, embed, id, associatedId, associatedType, typeId, includeRoleDocuments, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata}: GetApiDocumentsFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/documents/${querySerialiser({args:{pageSize, pageNumber, sortBy, embed, id, associatedId, associatedType, typeId, includeRoleDocuments, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiDocumentsResponse.parse(data)\n    };\nexport const useGetApiDocuments = ({pageSize, pageNumber, sortBy, embed, id, associatedId, associatedType, typeId, includeRoleDocuments, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata}: GetApiDocumentsFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Documents', pageSize, pageNumber, sortBy, embed, id, associatedId, associatedType, typeId, includeRoleDocuments, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata],\n        queryFn: () => getApiDocumentsFn({pageSize, pageNumber, sortBy, embed, id, associatedId, associatedType, typeId, includeRoleDocuments, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Documents/services/apiTypes.generated.ts": "import { documentModelPagedResult } from '@/schemas/documentModelPagedResult.generated.tsx'\nimport { CreateDocumentModel, createDocumentModel } from '@/schemas/createDocumentModel.generated.tsx'\nimport { z } from 'zod'\nimport { CreatePreSignedUrlsModel, createPreSignedUrlsModel } from '@/schemas/createPreSignedUrlsModel.generated.tsx'\nimport { documentModel } from '@/schemas/documentModel.generated.tsx'\n\nexport const getApiDocumentsResponse = documentModelPagedResult;\nexport type CreateApiDocumentsBody = CreateDocumentModel;\nexport const createApiDocumentsBody = createDocumentModel;\nexport const createApiDocumentsResponse = z.void();\nexport type CreateApiDocumentsSignedUrlBody = CreatePreSignedUrlsModel;\nexport const createApiDocumentsSignedUrlBody = createPreSignedUrlsModel;\nexport const createApiDocumentsSignedUrlResponse = createPreSignedUrlsModel;\nexport const getApiDocumentsIdResponse = documentModel;\nexport const deleteApiDocumentsIdResponse = z.void();\nexport const patchApiDocumentsIdResponse = z.void();\nexport const getApiDocumentsIdDownloadResponse = z.void();",
  "src/schemas/documentModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { documentModel, DocumentModel } from '@/schemas/documentModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const documentModelPagedResult = z.object({_embedded: z.array(documentModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type DocumentModelPagedResult = {_embedded?: (Array<DocumentModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/documentModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\n\nexport const documentModel = /** Representation of a document */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the document */\nz.string().optional().nullable(), created: /** The date and time when the document was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the document was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), associatedType: /** The type of entity that the document is associated with */\nz.string().optional().nullable(), isPrivate: /** A flag denoting whether or not the document is private */\nz.boolean().optional().nullable(), associatedId: /** The unique identifier of the entity that the document is associated with */\nz.string().optional().nullable(), typeId: /** The unique identifier of the type of document */\nz.string().optional().nullable(), name: /** The filename of the document */\nz.string().optional().nullable(), metadata: /** App specific metadata that has been set against the document */\nz.record(z.string(), z.object({})).optional().nullable(), _eTag: /** The ETag for the current version of the document. Used for managing update concurrency */\nz.string().optional().nullable()});\nexport type DocumentModel = /** Representation of a document */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the document */\nstring) | null | undefined, created?: (/** The date and time when the document was created */\nDate) | null | undefined, modified?: (/** The date and time when the document was last modified */\nDate) | null | undefined, associatedType?: (/** The type of entity that the document is associated with */\nstring) | null | undefined, isPrivate?: (/** A flag denoting whether or not the document is private */\nboolean) | null | undefined, associatedId?: (/** The unique identifier of the entity that the document is associated with */\nstring) | null | undefined, typeId?: (/** The unique identifier of the type of document */\nstring) | null | undefined, name?: (/** The filename of the document */\nstring) | null | undefined, metadata?: (/** App specific metadata that has been set against the document */\nRecord<string, Record<string, never>>) | null | undefined, _eTag?: (/** The ETag for the current version of the document. Used for managing update concurrency */\nstring) | null | undefined};",
  "src/sections/Documents/forms/CreateDocuments.example.tsx": "import { CreateDocumentsForm, fieldNames, CreateDocumentsFormFields } from '@/sections/Documents/forms/CreateDocumentsForm.generated.tsx'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateDocuments = () => {\n      \n\n      \n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateDocumentsForm >\n              <FormLayout>\n                <CreateDocumentsFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateDocumentsForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Documents/forms/CreateDocumentsForm.generated.tsx": "import { CreateApiDocumentsBody, createApiDocumentsBody } from '@/sections/Documents/services/apiTypes.generated.ts'\nimport { createDocumentsConfig } from '@/sections/Documents/config/createDocumentsConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiDocuments } from '@/sections/Documents/services/useCreateApiDocuments.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateDocumentsFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiDocumentsBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createDocumentsConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateDocumentsFormProps = {children: ReactNode, defaultValues?: CreateApiDocumentsBody, onSuccess?: () => void};\nexport const CreateDocumentsForm = (props: CreateDocumentsFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiDocumentsBody>({\n        resolver: zodResolver(createApiDocumentsBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiDocuments()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiDocumentsBody>({associatedType: true, associatedId: true, typeId: true, name: true, isPrivate: true, fileData: true, fileUrl: true, metadata: true});",
  "src/schemas/createDocumentModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateDocumentModel = /** Request body used to create a new document */\n{associatedType: /** The type of entity that the document is associated with (appliance/applicant/bankStatement/batch/certificate/contact/depositCertificate/estate/estateUnit/idCheck/keySet/landlord/nominalTransaction/property/supplierInvoice/tenancy/tenancyCheck/tenancyRenewal/worksOrder/renewalNegotiation) */\nstring, associatedId: /** The unique identifier of the entity that the document is associated with */\nstring, typeId: /** The unique identifier of the type of document */\nstring, name: /** The filename of the document */\nstring, isPrivate?: (/** A flag denoting whether or not the document is private */\nboolean) | null | undefined, fileData?: (/** The base64 encoded document content, prefixed with the content type (eg. data:text/plain;base64,VGVzdCBmaWxl)\r\nThis supports upto 6MB */\nstring) | null | undefined, fileUrl?: (/** The presigned s3 url which a document has been uploaded to (This supports files up to 30MB) */\nstring) | null | undefined, metadata?: (/** App specific metadata to set against the document */\nRecord<string, Record<string, never>>) | null | undefined};\nexport const createDocumentModel = /** Request body used to create a new document */\nz.object({associatedType: /** The type of entity that the document is associated with (appliance/applicant/bankStatement/batch/certificate/contact/depositCertificate/estate/estateUnit/idCheck/keySet/landlord/nominalTransaction/property/supplierInvoice/tenancy/tenancyCheck/tenancyRenewal/worksOrder/renewalNegotiation) */\nz.string().min(1), associatedId: /** The unique identifier of the entity that the document is associated with */\nz.string().min(1), typeId: /** The unique identifier of the type of document */\nz.string().min(1), name: /** The filename of the document */\nz.string().min(1), isPrivate: /** A flag denoting whether or not the document is private */\nz.boolean().optional().nullable(), fileData: /** The base64 encoded document content, prefixed with the content type (eg. data:text/plain;base64,VGVzdCBmaWxl)\r\nThis supports upto 6MB */\nz.string().optional().nullable(), fileUrl: /** The presigned s3 url which a document has been uploaded to (This supports files up to 30MB) */\nz.string().optional().nullable(), metadata: /** App specific metadata to set against the document */\nz.record(z.string(), z.object({})).optional().nullable()});",
  "src/sections/Documents/config/createDocumentsConfig.example.tsx": "import { CreateApiDocumentsBody } from '@/sections/Documents/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { Switch } from '@/inputs/Switch.tsx'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createDocumentsConfig: ModelConfig<CreateApiDocumentsBody> = {associatedType: {\n      key: 'associatedType',\n      label: 'associatedType',\n      defaultValue: '',\n      placeholder: 'associatedType',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, associatedId: {\n      key: 'associatedId',\n      label: 'associatedId',\n      defaultValue: '',\n      placeholder: 'associatedId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, typeId: {\n      key: 'typeId',\n      label: 'typeId',\n      defaultValue: '',\n      placeholder: 'typeId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, name: {\n      key: 'name',\n      label: 'name',\n      defaultValue: '',\n      placeholder: 'name',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, isPrivate: {\n      key: 'isPrivate',\n      label: 'isPrivate',\n      defaultValue: false,\n      placeholder: 'isPrivate',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><Switch {...props} /></InputWrap>\n    }, fileData: {\n      key: 'fileData',\n      label: 'fileData',\n      defaultValue: '',\n      placeholder: 'fileData',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, fileUrl: {\n      key: 'fileUrl',\n      label: 'fileUrl',\n      defaultValue: '',\n      placeholder: 'fileUrl',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, metadata: {\n      key: 'metadata',\n      label: 'metadata',\n      defaultValue: null,\n      placeholder: 'metadata',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/Documents/services/useCreateApiDocuments.generated.ts": "import { CreateDocumentModel } from '@/schemas/createDocumentModel.generated.tsx'\nimport { createApiDocumentsResponse } from '@/sections/Documents/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiDocumentsFnArgs = {body: CreateDocumentModel};\nexport const createApiDocumentsFn = async ({body}: CreateApiDocumentsFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/documents/${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiDocumentsResponse.parse(data)\n    };\nexport const useCreateApiDocuments = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiDocumentsFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Documents']})\n        }\n      })\n    };",
  "src/sections/Documents/forms/CreateDocumentsSignedUrl.example.tsx": "import { CreateDocumentsSignedUrlForm, fieldNames, CreateDocumentsSignedUrlFormFields } from '@/sections/Documents/forms/CreateDocumentsSignedUrlForm.generated.tsx'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateDocumentsSignedUrl = () => {\n      \n\n      \n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateDocumentsSignedUrlForm >\n              <FormLayout>\n                <CreateDocumentsSignedUrlFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateDocumentsSignedUrlForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Documents/forms/CreateDocumentsSignedUrlForm.generated.tsx": "import { CreateApiDocumentsSignedUrlBody, createApiDocumentsSignedUrlBody } from '@/sections/Documents/services/apiTypes.generated.ts'\nimport { createDocumentsSignedUrlConfig } from '@/sections/Documents/config/createDocumentsSignedUrlConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiDocumentsSignedUrl } from '@/sections/Documents/services/useCreateApiDocumentsSignedUrl.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateDocumentsSignedUrlFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiDocumentsSignedUrlBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createDocumentsSignedUrlConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateDocumentsSignedUrlFormProps = {children: ReactNode, defaultValues?: CreateApiDocumentsSignedUrlBody, onSuccess?: () => void};\nexport const CreateDocumentsSignedUrlForm = (props: CreateDocumentsSignedUrlFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiDocumentsSignedUrlBody>({\n        resolver: zodResolver(createApiDocumentsSignedUrlBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiDocumentsSignedUrl()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiDocumentsSignedUrlBody>({amount: true});",
  "src/schemas/createPreSignedUrlsModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreatePreSignedUrlsModel = /** Request body used to create pre signed urls to upload files between 6MB and 30MB */\n{amount: /** The number of pre signed urls to create */\nnumber};\nexport const createPreSignedUrlsModel = /** Request body used to create pre signed urls to upload files between 6MB and 30MB */\nz.object({amount: /** The number of pre signed urls to create */\nz.number().int()});",
  "src/sections/Documents/config/createDocumentsSignedUrlConfig.example.tsx": "import { CreateApiDocumentsSignedUrlBody } from '@/sections/Documents/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createDocumentsSignedUrlConfig: ModelConfig<CreateApiDocumentsSignedUrlBody> = {amount: {\n      key: 'amount',\n      label: 'amount',\n      defaultValue: null,\n      placeholder: 'amount',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/Documents/services/useCreateApiDocumentsSignedUrl.generated.ts": "import { CreatePreSignedUrlsModel } from '@/schemas/createPreSignedUrlsModel.generated.tsx'\nimport { createApiDocumentsSignedUrlResponse } from '@/sections/Documents/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiDocumentsSignedUrlFnArgs = {body: CreatePreSignedUrlsModel};\nexport const createApiDocumentsSignedUrlFn = async ({body}: CreateApiDocumentsSignedUrlFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/documents/signedUrl${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiDocumentsSignedUrlResponse.parse(data)\n    };\nexport const useCreateApiDocumentsSignedUrl = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiDocumentsSignedUrlFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Documents']})\n        }\n      })\n    };",
  "src/sections/Enquiries/tables/EnquiriesTable.generated.tsx": "import { useGetApiEnquiries } from '@/sections/Enquiries/services/useGetApiEnquiries.generated.ts'\nimport { useState } from 'react'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\nimport { useNavigate } from 'react-router-dom'\n\nexport type UseEnquiriesTableArgs = {sortBy?: (string) | null | undefined, enquiryType?: (string) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined};\nexport const useEnquiriesTable = (args: UseEnquiriesTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiEnquiries({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const EnquiriesTable = () => {\n  \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useEnquiriesTable({}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Enquiries',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New enquiriesTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/enquiries/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Enquiries/services/useGetApiEnquiries.generated.ts": "import { getApiEnquiriesResponse } from '@/sections/Enquiries/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiEnquiriesFnArgs = {pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, sortBy?: (string) | null | undefined, enquiryType?: (string) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined};\nexport const getApiEnquiriesFn = async ({pageSize, pageNumber, sortBy, enquiryType, createdFrom, createdTo, modifiedFrom, modifiedTo}: GetApiEnquiriesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/enquiries/${querySerialiser({args:{pageSize, pageNumber, sortBy, enquiryType, createdFrom, createdTo, modifiedFrom, modifiedTo}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiEnquiriesResponse.parse(data)\n    };\nexport const useGetApiEnquiries = ({pageSize, pageNumber, sortBy, enquiryType, createdFrom, createdTo, modifiedFrom, modifiedTo}: GetApiEnquiriesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Enquiries', pageSize, pageNumber, sortBy, enquiryType, createdFrom, createdTo, modifiedFrom, modifiedTo],\n        queryFn: () => getApiEnquiriesFn({pageSize, pageNumber, sortBy, enquiryType, createdFrom, createdTo, modifiedFrom, modifiedTo}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Enquiries/services/apiTypes.generated.ts": "import { enquiryModelPagedResult } from '@/schemas/enquiryModelPagedResult.generated.tsx'\nimport { CreateEnquiryModel, createEnquiryModel } from '@/schemas/createEnquiryModel.generated.tsx'\nimport { z } from 'zod'\nimport { enquiryModel } from '@/schemas/enquiryModel.generated.tsx'\n\nexport const getApiEnquiriesResponse = enquiryModelPagedResult;\nexport type CreateApiEnquiriesBody = CreateEnquiryModel;\nexport const createApiEnquiriesBody = createEnquiryModel;\nexport const createApiEnquiriesResponse = z.void();\nexport const getApiEnquiriesIdResponse = enquiryModel;\nexport const patchApiEnquiriesIdResponse = z.void();",
  "src/schemas/enquiryModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { enquiryModel, EnquiryModel } from '@/schemas/enquiryModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const enquiryModelPagedResult = z.object({_embedded: z.array(enquiryModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type EnquiryModelPagedResult = {_embedded?: (Array<EnquiryModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/enquiryModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\nimport { enquiryAddressModel, EnquiryAddressModel } from '@/schemas/enquiryAddressModel.generated.tsx'\nimport { enquiryBuyingModel, EnquiryBuyingModel } from '@/schemas/enquiryBuyingModel.generated.tsx'\nimport { enquiryRentingModel, EnquiryRentingModel } from '@/schemas/enquiryRentingModel.generated.tsx'\n\nexport const enquiryModel = /** Representation of an enquiry */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the enquiry */\nz.number().int().optional().nullable(), created: /** The date and time when the enquiry was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the enquiry was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), title: /** The title of the individual making the enquiry */\nz.string().optional().nullable(), forename: /** The forename of the individual making the enquiry */\nz.string().optional().nullable(), surname: /** The surname of the individual making the enquiry */\nz.string().optional().nullable(), enquiryType: /** The type of enquiry. Enquiries can created for applicants interested in buying/renting, as well as prospective vendors and landlords (salesApplicant/lettingsApplicant/salesProperty/lettingsProperty) */\nz.string().optional().nullable(), message: /** Textual information about the nature of the enquiry - usually the message text from the individual making the enquiry */\nz.string().optional().nullable(), status: /** The status of the enquiry (pending/added/rejected/alreadyExists/duplicateEntry/spam) */\nz.string().optional().nullable(), marketingConsent: /** The marketing consent status of the individual making the enquiry (grant/deny/notAsked) */\nz.string().optional().nullable(), position: /** The selling position of the individual making the enquiry (renting/instructedThisAgent/instructedOtherAgent/privateSale/notOnMarket) */\nz.string().optional().nullable(), officeId: /** The unique identifier of the office related to the enquiry */\nz.string().optional().nullable(), applicantId: /** The unique identifier of the applicant related to the enquiry */\nz.string().optional().nullable(), negotiatorId: /** The unique identifier of the negotiator related to the enquiry */\nz.string().optional().nullable(), sourceName: /** The name of the source that the enquiry was generated by */\nz.string().optional().nullable(), homePhone: /** The home phone number of the individual making the enquiry */\nz.string().optional().nullable(), workPhone: /** The work phone number of the individual making the enquiry */\nz.string().optional().nullable(), mobilePhone: /** The mobile phone number of the individual making the enquiry */\nz.string().optional().nullable(), email: /** The email of the individual making the enquiry */\nz.string().optional().nullable(), address: enquiryAddressModel.optional().nullable(), buying: enquiryBuyingModel.optional().nullable(), renting: enquiryRentingModel.optional().nullable(), bedrooms: /** The number of bedrooms the prospective buyer or tenant requires */\nz.number().int().optional().nullable(), propertyIds: /** A list of unique property identifiers that this enquiry relates to. Used to indicate the properties that a sales or lettings applicant has expressed an interest in */\nz.array(z.string().min(1)).optional().nullable(), _eTag: /** The ETag for the current version of the enquiry. Used for managing update concurrency */\nz.string().optional().nullable()});\nexport type EnquiryModel = /** Representation of an enquiry */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the enquiry */\nnumber) | null | undefined, created?: (/** The date and time when the enquiry was created */\nDate) | null | undefined, modified?: (/** The date and time when the enquiry was last modified */\nDate) | null | undefined, title?: (/** The title of the individual making the enquiry */\nstring) | null | undefined, forename?: (/** The forename of the individual making the enquiry */\nstring) | null | undefined, surname?: (/** The surname of the individual making the enquiry */\nstring) | null | undefined, enquiryType?: (/** The type of enquiry. Enquiries can created for applicants interested in buying/renting, as well as prospective vendors and landlords (salesApplicant/lettingsApplicant/salesProperty/lettingsProperty) */\nstring) | null | undefined, message?: (/** Textual information about the nature of the enquiry - usually the message text from the individual making the enquiry */\nstring) | null | undefined, status?: (/** The status of the enquiry (pending/added/rejected/alreadyExists/duplicateEntry/spam) */\nstring) | null | undefined, marketingConsent?: (/** The marketing consent status of the individual making the enquiry (grant/deny/notAsked) */\nstring) | null | undefined, position?: (/** The selling position of the individual making the enquiry (renting/instructedThisAgent/instructedOtherAgent/privateSale/notOnMarket) */\nstring) | null | undefined, officeId?: (/** The unique identifier of the office related to the enquiry */\nstring) | null | undefined, applicantId?: (/** The unique identifier of the applicant related to the enquiry */\nstring) | null | undefined, negotiatorId?: (/** The unique identifier of the negotiator related to the enquiry */\nstring) | null | undefined, sourceName?: (/** The name of the source that the enquiry was generated by */\nstring) | null | undefined, homePhone?: (/** The home phone number of the individual making the enquiry */\nstring) | null | undefined, workPhone?: (/** The work phone number of the individual making the enquiry */\nstring) | null | undefined, mobilePhone?: (/** The mobile phone number of the individual making the enquiry */\nstring) | null | undefined, email?: (/** The email of the individual making the enquiry */\nstring) | null | undefined, address?: (EnquiryAddressModel) | null | undefined, buying?: (EnquiryBuyingModel) | null | undefined, renting?: (EnquiryRentingModel) | null | undefined, bedrooms?: (/** The number of bedrooms the prospective buyer or tenant requires */\nnumber) | null | undefined, propertyIds?: (/** A list of unique property identifiers that this enquiry relates to. Used to indicate the properties that a sales or lettings applicant has expressed an interest in */\nArray<string>) | null | undefined, _eTag?: (/** The ETag for the current version of the enquiry. Used for managing update concurrency */\nstring) | null | undefined};",
  "src/schemas/enquiryAddressModel.generated.tsx": "import { z } from 'zod'\n\nexport const enquiryAddressModel = /** Representation of the physical address of a building or premise */\nz.object({buildingName: /** The building name */\nz.string().optional().nullable(), buildingNumber: /** The building number */\nz.string().optional().nullable(), line1: /** The first line of the address */\nz.string().optional().nullable(), line2: /** The second line of the address */\nz.string().optional().nullable(), line3: /** The third line of the address */\nz.string().optional().nullable(), line4: /** The fourth line of the address */\nz.string().optional().nullable(), postcode: /** The postcode */\nz.string().optional().nullable(), countryId: /** The ISO-3166 country code that the address resides within */\nz.string().optional().nullable()});\nexport type EnquiryAddressModel = /** Representation of the physical address of a building or premise */\n{buildingName?: (/** The building name */\nstring) | null | undefined, buildingNumber?: (/** The building number */\nstring) | null | undefined, line1?: (/** The first line of the address */\nstring) | null | undefined, line2?: (/** The second line of the address */\nstring) | null | undefined, line3?: (/** The third line of the address */\nstring) | null | undefined, line4?: (/** The fourth line of the address */\nstring) | null | undefined, postcode?: (/** The postcode */\nstring) | null | undefined, countryId?: (/** The ISO-3166 country code that the address resides within */\nstring) | null | undefined};",
  "src/schemas/enquiryBuyingModel.generated.tsx": "import { z } from 'zod'\n\nexport const enquiryBuyingModel = /** Request body used to create a buying enquiry */\nz.object({priceFrom: /** The lower bound of the prospective buyer's budget */\nz.number().int().optional().nullable(), priceTo: /** The upper bound of the prospective buyer's budget */\nz.number().int().optional().nullable()});\nexport type EnquiryBuyingModel = /** Request body used to create a buying enquiry */\n{priceFrom?: (/** The lower bound of the prospective buyer's budget */\nnumber) | null | undefined, priceTo?: (/** The upper bound of the prospective buyer's budget */\nnumber) | null | undefined};",
  "src/schemas/enquiryRentingModel.generated.tsx": "import { z } from 'zod'\n\nexport const enquiryRentingModel = /** The details specific to enquiries with a type of lettingsApplicant */\nz.object({rentFrom: /** The lower bound of the prospective tenant's budget */\nz.number().optional().nullable(), rentTo: /** The upper bound of the prospective tenant's budget */\nz.number().optional().nullable(), rentFrequency: /** How often the tenant would like to pay the rent (weekly/monthly/annually) */\nz.string().optional().nullable()});\nexport type EnquiryRentingModel = /** The details specific to enquiries with a type of lettingsApplicant */\n{rentFrom?: (/** The lower bound of the prospective tenant's budget */\nnumber) | null | undefined, rentTo?: (/** The upper bound of the prospective tenant's budget */\nnumber) | null | undefined, rentFrequency?: (/** How often the tenant would like to pay the rent (weekly/monthly/annually) */\nstring) | null | undefined};",
  "src/sections/Enquiries/forms/CreateEnquiries.example.tsx": "import { CreateEnquiriesForm, fieldNames, CreateEnquiriesFormFields } from '@/sections/Enquiries/forms/CreateEnquiriesForm.generated.tsx'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateEnquiries = () => {\n      \n\n      \n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateEnquiriesForm >\n              <FormLayout>\n                <CreateEnquiriesFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateEnquiriesForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Enquiries/forms/CreateEnquiriesForm.generated.tsx": "import { CreateApiEnquiriesBody, createApiEnquiriesBody } from '@/sections/Enquiries/services/apiTypes.generated.ts'\nimport { createEnquiriesConfig } from '@/sections/Enquiries/config/createEnquiriesConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiEnquiries } from '@/sections/Enquiries/services/useCreateApiEnquiries.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateEnquiriesFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiEnquiriesBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createEnquiriesConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateEnquiriesFormProps = {children: ReactNode, defaultValues?: CreateApiEnquiriesBody, onSuccess?: () => void};\nexport const CreateEnquiriesForm = (props: CreateEnquiriesFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiEnquiriesBody>({\n        resolver: zodResolver(createApiEnquiriesBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiEnquiries()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiEnquiriesBody>({title: true, forename: true, surname: true, position: true, enquiryType: true, message: true, officeId: true, marketingConsent: true, sourceName: true, homePhone: true, workPhone: true, mobilePhone: true, email: true, address: true, buying: true, renting: true, bedrooms: true, propertyIds: true});",
  "src/schemas/createEnquiryModel.generated.tsx": "import { CreateEnquiryAddressModel, createEnquiryAddressModel } from '@/schemas/createEnquiryAddressModel.generated.tsx'\nimport { CreateEnquiryBuyingModel, createEnquiryBuyingModel } from '@/schemas/createEnquiryBuyingModel.generated.tsx'\nimport { CreateEnquiryRentingModel, createEnquiryRentingModel } from '@/schemas/createEnquiryRentingModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type CreateEnquiryModel = /** Request body used to create an enquiry */\n{title: /** The title of the individual making the enquiry */\nstring, forename: /** The forename of the individual making the enquiry */\nstring, surname: /** The surname of the individual making the enquiry */\nstring, position?: (/** The selling position of the individual making the enquiry (renting/instructedThisAgent/instructedOtherAgent/privateSale/notOnMarket) */\nstring) | null | undefined, enquiryType: /** The type of enquiry. Enquiries can created for applicants interested in buying/renting, as well as prospective vendors and landlords (salesApplicant/lettingsApplicant/salesProperty/lettingsProperty) */\nstring, message: /** Textual information about the nature of the enquiry - usually the message text from the individual making the enquiry */\nstring, officeId: /** The unique identifier of the related office */\nstring, marketingConsent: /** The marketing consent status of the individual making the enquiry (grant/deny/notAsked) */\nstring, sourceName: /** The name of the source that the enquiry was generated from */\nstring, homePhone?: (/** The home phone number of the individual making the enquiry (Required when no other contact details are given) */\nstring) | null | undefined, workPhone?: (/** The work phone number of the individual making the enquiry (Required when no other contact details are given) */\nstring) | null | undefined, mobilePhone?: (/** The mobile phone number of the individual making the enquiry (Required when no other contact details are given) */\nstring) | null | undefined, email?: (/** The email of the individual making the enquiry (Required when no other contact details are given) */\nstring) | null | undefined, address?: (CreateEnquiryAddressModel) | null | undefined, buying?: (CreateEnquiryBuyingModel) | null | undefined, renting?: (CreateEnquiryRentingModel) | null | undefined, bedrooms?: (/** The number of bedrooms the prospective buyer or tenant requires */\nnumber) | null | undefined, propertyIds?: (/** A list of unique property identifiers that the enquiry relates to. Used to indicate the properties that a sales or lettings applicant has expressed an interest in */\nArray<string>) | null | undefined};\nexport const createEnquiryModel = /** Request body used to create an enquiry */\nz.object({title: /** The title of the individual making the enquiry */\nz.string().min(1), forename: /** The forename of the individual making the enquiry */\nz.string().min(1), surname: /** The surname of the individual making the enquiry */\nz.string().min(1), position: /** The selling position of the individual making the enquiry (renting/instructedThisAgent/instructedOtherAgent/privateSale/notOnMarket) */\nz.string().optional().nullable(), enquiryType: /** The type of enquiry. Enquiries can created for applicants interested in buying/renting, as well as prospective vendors and landlords (salesApplicant/lettingsApplicant/salesProperty/lettingsProperty) */\nz.string().min(1), message: /** Textual information about the nature of the enquiry - usually the message text from the individual making the enquiry */\nz.string().min(1), officeId: /** The unique identifier of the related office */\nz.string().min(1), marketingConsent: /** The marketing consent status of the individual making the enquiry (grant/deny/notAsked) */\nz.string().min(1), sourceName: /** The name of the source that the enquiry was generated from */\nz.string().min(1), homePhone: /** The home phone number of the individual making the enquiry (Required when no other contact details are given) */\nz.string().optional().nullable(), workPhone: /** The work phone number of the individual making the enquiry (Required when no other contact details are given) */\nz.string().optional().nullable(), mobilePhone: /** The mobile phone number of the individual making the enquiry (Required when no other contact details are given) */\nz.string().optional().nullable(), email: /** The email of the individual making the enquiry (Required when no other contact details are given) */\nz.string().optional().nullable(), address: createEnquiryAddressModel.optional().nullable(), buying: createEnquiryBuyingModel.optional().nullable(), renting: createEnquiryRentingModel.optional().nullable(), bedrooms: /** The number of bedrooms the prospective buyer or tenant requires */\nz.number().int().optional().nullable(), propertyIds: /** A list of unique property identifiers that the enquiry relates to. Used to indicate the properties that a sales or lettings applicant has expressed an interest in */\nz.array(z.string().min(1)).optional().nullable()});",
  "src/schemas/createEnquiryAddressModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateEnquiryAddressModel = /** Request body used to create a enquiries address */\n{buildingName?: (/** Sets the building name */\nstring) | null | undefined, buildingNumber?: (/** Sets the building number */\nstring) | null | undefined, line1?: (/** Sets the first line of the address */\nstring) | null | undefined, line2?: (/** Sets the second line of the address */\nstring) | null | undefined, line3?: (/** Sets the third line of the address */\nstring) | null | undefined, line4?: (/** Sets the fourth line of the address */\nstring) | null | undefined, postcode?: (/** Sets the postcode */\nstring) | null | undefined, countryId?: (/** Sets the ISO-3166 country code that the address resides within */\nstring) | null | undefined};\nexport const createEnquiryAddressModel = /** Request body used to create a enquiries address */\nz.object({buildingName: /** Sets the building name */\nz.string().optional().nullable(), buildingNumber: /** Sets the building number */\nz.string().optional().nullable(), line1: /** Sets the first line of the address */\nz.string().optional().nullable(), line2: /** Sets the second line of the address */\nz.string().optional().nullable(), line3: /** Sets the third line of the address */\nz.string().optional().nullable(), line4: /** Sets the fourth line of the address */\nz.string().optional().nullable(), postcode: /** Sets the postcode */\nz.string().optional().nullable(), countryId: /** Sets the ISO-3166 country code that the address resides within */\nz.string().optional().nullable()});",
  "src/schemas/createEnquiryBuyingModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateEnquiryBuyingModel = /** The details specific to a buying enquiry */\n{priceFrom?: (/** The lower bound of the prospective buyer's budget */\nnumber) | null | undefined, priceTo?: (/** The upper bound of the prospective buyer's budget */\nnumber) | null | undefined};\nexport const createEnquiryBuyingModel = /** The details specific to a buying enquiry */\nz.object({priceFrom: /** The lower bound of the prospective buyer's budget */\nz.number().int().optional().nullable(), priceTo: /** The upper bound of the prospective buyer's budget */\nz.number().int().optional().nullable()});",
  "src/schemas/createEnquiryRentingModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateEnquiryRentingModel = /** The details specific to renting enquiry. When type is renting. */\n{rentFrom?: (/** The lower bound of the prospective tenant's budget */\nnumber) | null | undefined, rentTo?: (/** The upper bound of the prospective tenant's budget */\nnumber) | null | undefined, rentFrequency?: (/** The desired rent collection frequency specified by the prospective tenant (weekly/monthly/annually). */\nstring) | null | undefined};\nexport const createEnquiryRentingModel = /** The details specific to renting enquiry. When type is renting. */\nz.object({rentFrom: /** The lower bound of the prospective tenant's budget */\nz.number().int().optional().nullable(), rentTo: /** The upper bound of the prospective tenant's budget */\nz.number().int().optional().nullable(), rentFrequency: /** The desired rent collection frequency specified by the prospective tenant (weekly/monthly/annually). */\nz.string().optional().nullable()});",
  "src/sections/Enquiries/config/createEnquiriesConfig.example.tsx": "import { CreateApiEnquiriesBody } from '@/sections/Enquiries/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createEnquiriesConfig: ModelConfig<CreateApiEnquiriesBody> = {title: {\n      key: 'title',\n      label: 'title',\n      defaultValue: '',\n      placeholder: 'title',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, forename: {\n      key: 'forename',\n      label: 'forename',\n      defaultValue: '',\n      placeholder: 'forename',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, surname: {\n      key: 'surname',\n      label: 'surname',\n      defaultValue: '',\n      placeholder: 'surname',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, position: {\n      key: 'position',\n      label: 'position',\n      defaultValue: '',\n      placeholder: 'position',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, enquiryType: {\n      key: 'enquiryType',\n      label: 'enquiryType',\n      defaultValue: '',\n      placeholder: 'enquiryType',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, message: {\n      key: 'message',\n      label: 'message',\n      defaultValue: '',\n      placeholder: 'message',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, officeId: {\n      key: 'officeId',\n      label: 'officeId',\n      defaultValue: '',\n      placeholder: 'officeId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, marketingConsent: {\n      key: 'marketingConsent',\n      label: 'marketingConsent',\n      defaultValue: '',\n      placeholder: 'marketingConsent',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, sourceName: {\n      key: 'sourceName',\n      label: 'sourceName',\n      defaultValue: '',\n      placeholder: 'sourceName',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, homePhone: {\n      key: 'homePhone',\n      label: 'homePhone',\n      defaultValue: '',\n      placeholder: 'homePhone',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, workPhone: {\n      key: 'workPhone',\n      label: 'workPhone',\n      defaultValue: '',\n      placeholder: 'workPhone',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, mobilePhone: {\n      key: 'mobilePhone',\n      label: 'mobilePhone',\n      defaultValue: '',\n      placeholder: 'mobilePhone',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, email: {\n      key: 'email',\n      label: 'email',\n      defaultValue: '',\n      placeholder: 'email',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, address: {\n      key: 'address',\n      label: 'address',\n      defaultValue: null,\n      placeholder: 'address',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, buying: {\n      key: 'buying',\n      label: 'buying',\n      defaultValue: null,\n      placeholder: 'buying',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, renting: {\n      key: 'renting',\n      label: 'renting',\n      defaultValue: null,\n      placeholder: 'renting',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, bedrooms: {\n      key: 'bedrooms',\n      label: 'bedrooms',\n      defaultValue: null,\n      placeholder: 'bedrooms',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, propertyIds: {\n      key: 'propertyIds',\n      label: 'propertyIds',\n      defaultValue: [],\n      placeholder: 'propertyIds',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/Enquiries/services/useCreateApiEnquiries.generated.ts": "import { CreateEnquiryModel } from '@/schemas/createEnquiryModel.generated.tsx'\nimport { createApiEnquiriesResponse } from '@/sections/Enquiries/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiEnquiriesFnArgs = {body: CreateEnquiryModel};\nexport const createApiEnquiriesFn = async ({body}: CreateApiEnquiriesFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/enquiries/${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiEnquiriesResponse.parse(data)\n    };\nexport const useCreateApiEnquiries = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiEnquiriesFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Enquiries']})\n        }\n      })\n    };",
  "src/sections/IdentityChecks/tables/IdentityChecksTable.generated.tsx": "import { useGetApiIdentityChecks } from '@/sections/IdentityChecks/services/useGetApiIdentityChecks.generated.ts'\nimport { useState } from 'react'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\nimport { useNavigate } from 'react-router-dom'\n\nexport type UseIdentityChecksTableArgs = {sortBy?: (string) | null | undefined, embed?: (Array<'contact' | 'document1' | 'document2' | 'documentType1' | 'documentType2'>) | null | undefined, id?: (Array<string>) | null | undefined, contactId?: (Array<string>) | null | undefined, negotiatorId?: (Array<string>) | null | undefined, status?: (Array<'unknown' | 'unchecked' | 'pending' | 'fail' | 'cancelled' | 'warnings' | 'pass'>) | null | undefined, checkDateFrom?: (Date) | null | undefined, checkDateTo?: (Date) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, metadata?: (Array<string>) | null | undefined};\nexport const useIdentityChecksTable = (args: UseIdentityChecksTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiIdentityChecks({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const IdentityChecksTable = () => {\n  \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useIdentityChecksTable({}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'IdentityChecks',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New identityChecksTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/identityChecks/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/IdentityChecks/services/useGetApiIdentityChecks.generated.ts": "import { getApiIdentityChecksResponse } from '@/sections/IdentityChecks/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiIdentityChecksFnArgs = {pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, sortBy?: (string) | null | undefined, embed?: (Array<'contact' | 'document1' | 'document2' | 'documentType1' | 'documentType2'>) | null | undefined, id?: (Array<string>) | null | undefined, contactId?: (Array<string>) | null | undefined, negotiatorId?: (Array<string>) | null | undefined, status?: (Array<'unknown' | 'unchecked' | 'pending' | 'fail' | 'cancelled' | 'warnings' | 'pass'>) | null | undefined, checkDateFrom?: (Date) | null | undefined, checkDateTo?: (Date) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, metadata?: (Array<string>) | null | undefined};\nexport const getApiIdentityChecksFn = async ({pageSize, pageNumber, sortBy, embed, id, contactId, negotiatorId, status, checkDateFrom, checkDateTo, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata}: GetApiIdentityChecksFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/identityChecks/${querySerialiser({args:{pageSize, pageNumber, sortBy, embed, id, contactId, negotiatorId, status, checkDateFrom, checkDateTo, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiIdentityChecksResponse.parse(data)\n    };\nexport const useGetApiIdentityChecks = ({pageSize, pageNumber, sortBy, embed, id, contactId, negotiatorId, status, checkDateFrom, checkDateTo, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata}: GetApiIdentityChecksFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['IdentityChecks', pageSize, pageNumber, sortBy, embed, id, contactId, negotiatorId, status, checkDateFrom, checkDateTo, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata],\n        queryFn: () => getApiIdentityChecksFn({pageSize, pageNumber, sortBy, embed, id, contactId, negotiatorId, status, checkDateFrom, checkDateTo, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/IdentityChecks/services/apiTypes.generated.ts": "import { identityCheckModelPagedResult } from '@/schemas/identityCheckModelPagedResult.generated.tsx'\nimport { CreateIdentityCheckModel, createIdentityCheckModel } from '@/schemas/createIdentityCheckModel.generated.tsx'\nimport { z } from 'zod'\nimport { CreatePreSignedUrlsModel, createPreSignedUrlsModel } from '@/schemas/createPreSignedUrlsModel.generated.tsx'\nimport { identityCheckModel } from '@/schemas/identityCheckModel.generated.tsx'\n\nexport const getApiIdentityChecksResponse = identityCheckModelPagedResult;\nexport type CreateApiIdentityChecksBody = CreateIdentityCheckModel;\nexport const createApiIdentityChecksBody = createIdentityCheckModel;\nexport const createApiIdentityChecksResponse = z.void();\nexport type CreateApiIdentityChecksSignedUrlBody = CreatePreSignedUrlsModel;\nexport const createApiIdentityChecksSignedUrlBody = createPreSignedUrlsModel;\nexport const createApiIdentityChecksSignedUrlResponse = createPreSignedUrlsModel;\nexport const getApiIdentityChecksIdResponse = identityCheckModel;\nexport const patchApiIdentityChecksIdResponse = z.void();",
  "src/schemas/identityCheckModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { identityCheckModel, IdentityCheckModel } from '@/schemas/identityCheckModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const identityCheckModelPagedResult = z.object({_embedded: z.array(identityCheckModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type IdentityCheckModelPagedResult = {_embedded?: (Array<IdentityCheckModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/identityCheckModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\nimport { identityDocumentModel, IdentityDocumentModel } from '@/schemas/identityDocumentModel.generated.tsx'\n\nexport const identityCheckModel = /** Representation of a contact identity check */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the identity check */\nz.string().optional().nullable(), contactId: /** The unique identifier of the contact associated to the identity check */\nz.string().optional().nullable(), created: /** The date and time when the identity check was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the identity check was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), checkDate: /** The date when the identity check was performed. This may differ to the date when the check was created */\nz.string().optional().nullable(), status: /** The current status of the identity check (pass/fail/pending/cancelled/warnings/unchecked) */\nz.string().optional().nullable(), negotiatorId: /** The unique identifier of the negotiator that initiated the identity check */\nz.string().optional().nullable(), identityDocument1: identityDocumentModel.optional().nullable(), identityDocument2: identityDocumentModel.optional().nullable(), metadata: /** App specific metadata that has been set against the identity check */\nz.record(z.string(), z.object({})).optional().nullable(), _eTag: /** The ETag for the current version of the identity check. Used for managing update concurrency */\nz.string().optional().nullable()});\nexport type IdentityCheckModel = /** Representation of a contact identity check */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the identity check */\nstring) | null | undefined, contactId?: (/** The unique identifier of the contact associated to the identity check */\nstring) | null | undefined, created?: (/** The date and time when the identity check was created */\nDate) | null | undefined, modified?: (/** The date and time when the identity check was last modified */\nDate) | null | undefined, checkDate?: (/** The date when the identity check was performed. This may differ to the date when the check was created */\nstring) | null | undefined, status?: (/** The current status of the identity check (pass/fail/pending/cancelled/warnings/unchecked) */\nstring) | null | undefined, negotiatorId?: (/** The unique identifier of the negotiator that initiated the identity check */\nstring) | null | undefined, identityDocument1?: (IdentityDocumentModel) | null | undefined, identityDocument2?: (IdentityDocumentModel) | null | undefined, metadata?: (/** App specific metadata that has been set against the identity check */\nRecord<string, Record<string, never>>) | null | undefined, _eTag?: (/** The ETag for the current version of the identity check. Used for managing update concurrency */\nstring) | null | undefined};",
  "src/schemas/identityDocumentModel.generated.tsx": "import { z } from 'zod'\n\nexport const identityDocumentModel = /** Representation of a single identity document that was provided as part of a contact identity check (eg. passport) */\nz.object({documentId: /** The unique identifier of the identity document */\nz.string().optional().nullable(), typeId: /** The unique identifier of the type of identity document provided */\nz.string().optional().nullable(), expiry: /** The date when the document expires and becomes invalid */\nz.string().optional().nullable(), details: /** Details regarding the identity document (eg. passport number) */\nz.string().optional().nullable()});\nexport type IdentityDocumentModel = /** Representation of a single identity document that was provided as part of a contact identity check (eg. passport) */\n{documentId?: (/** The unique identifier of the identity document */\nstring) | null | undefined, typeId?: (/** The unique identifier of the type of identity document provided */\nstring) | null | undefined, expiry?: (/** The date when the document expires and becomes invalid */\nstring) | null | undefined, details?: (/** Details regarding the identity document (eg. passport number) */\nstring) | null | undefined};",
  "src/sections/IdentityChecks/forms/CreateIdentityChecks.example.tsx": "import { CreateIdentityChecksForm, fieldNames, CreateIdentityChecksFormFields } from '@/sections/IdentityChecks/forms/CreateIdentityChecksForm.generated.tsx'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateIdentityChecks = () => {\n      \n\n      \n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateIdentityChecksForm >\n              <FormLayout>\n                <CreateIdentityChecksFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateIdentityChecksForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/IdentityChecks/forms/CreateIdentityChecksForm.generated.tsx": "import { CreateApiIdentityChecksBody, createApiIdentityChecksBody } from '@/sections/IdentityChecks/services/apiTypes.generated.ts'\nimport { createIdentityChecksConfig } from '@/sections/IdentityChecks/config/createIdentityChecksConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiIdentityChecks } from '@/sections/IdentityChecks/services/useCreateApiIdentityChecks.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateIdentityChecksFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiIdentityChecksBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createIdentityChecksConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateIdentityChecksFormProps = {children: ReactNode, defaultValues?: CreateApiIdentityChecksBody, onSuccess?: () => void};\nexport const CreateIdentityChecksForm = (props: CreateIdentityChecksFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiIdentityChecksBody>({\n        resolver: zodResolver(createApiIdentityChecksBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiIdentityChecks()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiIdentityChecksBody>({contactId: true, checkDate: true, status: true, negotiatorId: true, identityDocument1: true, identityDocument2: true, metadata: true});",
  "src/schemas/createIdentityCheckModel.generated.tsx": "import { CreateIdentityDocumentModel, createIdentityDocumentModel } from '@/schemas/createIdentityDocumentModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type CreateIdentityCheckModel = /** Request body used to create a new contact identity check */\n{contactId: /** The unique identifier of the contact associated to the identity check */\nstring, checkDate: /** The date when the identity check was performed. This may differ to the date when the check was created */\nstring, status: /** The current status of the identity check (pass/fail/pending/cancelled/warnings/unchecked) */\nstring, negotiatorId: /** The unique identifier of the negotiator that initiated the identity check */\nstring, identityDocument1?: (CreateIdentityDocumentModel) | null | undefined, identityDocument2?: (CreateIdentityDocumentModel) | null | undefined, metadata?: (/** App specific metadata to set against the identity check */\nRecord<string, Record<string, never>>) | null | undefined};\nexport const createIdentityCheckModel = /** Request body used to create a new contact identity check */\nz.object({contactId: /** The unique identifier of the contact associated to the identity check */\nz.string().min(1), checkDate: /** The date when the identity check was performed. This may differ to the date when the check was created */\nz.string().min(1), status: /** The current status of the identity check (pass/fail/pending/cancelled/warnings/unchecked) */\nz.string().min(1), negotiatorId: /** The unique identifier of the negotiator that initiated the identity check */\nz.string().min(1), identityDocument1: createIdentityDocumentModel.optional().nullable(), identityDocument2: createIdentityDocumentModel.optional().nullable(), metadata: /** App specific metadata to set against the identity check */\nz.record(z.string(), z.object({})).optional().nullable()});",
  "src/schemas/createIdentityDocumentModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateIdentityDocumentModel = /** Request body to attach an identity document to a new contact identity check\r\nA second identity document is not required and can be ignored by being set to null */\n{typeId: /** The unique identifier of the type of identity document provided */\nstring, expiry?: (/** The date when the document expires and becomes invalid */\nstring) | null | undefined, details?: (/** Details regarding the identity document (eg. passport number) (Required when 'fileData' is not given) */\nstring) | null | undefined, fileData?: (/** The base64 encoded identity document content, prefixed with the content type (eg. data:text/plain;base64,VGVzdCBmaWxl) (Required when 'details' are not given)\r\nThe total request payload cannot exceed 6Mb, regardless of the number of documents being sent */\nstring) | null | undefined, fileUrl?: (/** The presigned s3 url which a document has been uploaded to (This supports files up to 30MB) */\nstring) | null | undefined, name?: (/** The filename to store the document as (Required when 'details' are not given) */\nstring) | null | undefined};\nexport const createIdentityDocumentModel = /** Request body to attach an identity document to a new contact identity check\r\nA second identity document is not required and can be ignored by being set to null */\nz.object({typeId: /** The unique identifier of the type of identity document provided */\nz.string().min(1), expiry: /** The date when the document expires and becomes invalid */\nz.string().optional().nullable(), details: /** Details regarding the identity document (eg. passport number) (Required when 'fileData' is not given) */\nz.string().optional().nullable(), fileData: /** The base64 encoded identity document content, prefixed with the content type (eg. data:text/plain;base64,VGVzdCBmaWxl) (Required when 'details' are not given)\r\nThe total request payload cannot exceed 6Mb, regardless of the number of documents being sent */\nz.string().optional().nullable(), fileUrl: /** The presigned s3 url which a document has been uploaded to (This supports files up to 30MB) */\nz.string().optional().nullable(), name: /** The filename to store the document as (Required when 'details' are not given) */\nz.string().optional().nullable()});",
  "src/sections/IdentityChecks/config/createIdentityChecksConfig.example.tsx": "import { CreateApiIdentityChecksBody } from '@/sections/IdentityChecks/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { DateInput } from '@/inputs/DateInput.tsx'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createIdentityChecksConfig: ModelConfig<CreateApiIdentityChecksBody> = {contactId: {\n      key: 'contactId',\n      label: 'contactId',\n      defaultValue: '',\n      placeholder: 'contactId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, checkDate: {\n      key: 'checkDate',\n      label: 'checkDate',\n      defaultValue: null,\n      placeholder: 'checkDate',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><DateInput {...props} /></InputWrap>\n    }, status: {\n      key: 'status',\n      label: 'status',\n      defaultValue: '',\n      placeholder: 'status',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, negotiatorId: {\n      key: 'negotiatorId',\n      label: 'negotiatorId',\n      defaultValue: '',\n      placeholder: 'negotiatorId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, identityDocument1: {\n      key: 'identityDocument1',\n      label: 'identityDocument1',\n      defaultValue: null,\n      placeholder: 'identityDocument1',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, identityDocument2: {\n      key: 'identityDocument2',\n      label: 'identityDocument2',\n      defaultValue: null,\n      placeholder: 'identityDocument2',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, metadata: {\n      key: 'metadata',\n      label: 'metadata',\n      defaultValue: null,\n      placeholder: 'metadata',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/IdentityChecks/services/useCreateApiIdentityChecks.generated.ts": "import { CreateIdentityCheckModel } from '@/schemas/createIdentityCheckModel.generated.tsx'\nimport { createApiIdentityChecksResponse } from '@/sections/IdentityChecks/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiIdentityChecksFnArgs = {body: CreateIdentityCheckModel};\nexport const createApiIdentityChecksFn = async ({body}: CreateApiIdentityChecksFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/identityChecks/${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiIdentityChecksResponse.parse(data)\n    };\nexport const useCreateApiIdentityChecks = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiIdentityChecksFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['IdentityChecks']})\n        }\n      })\n    };",
  "src/sections/IdentityChecks/forms/CreateIdentityChecksSignedUrl.example.tsx": "import { CreateIdentityChecksSignedUrlForm, fieldNames, CreateIdentityChecksSignedUrlFormFields } from '@/sections/IdentityChecks/forms/CreateIdentityChecksSignedUrlForm.generated.tsx'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateIdentityChecksSignedUrl = () => {\n      \n\n      \n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateIdentityChecksSignedUrlForm >\n              <FormLayout>\n                <CreateIdentityChecksSignedUrlFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateIdentityChecksSignedUrlForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/IdentityChecks/forms/CreateIdentityChecksSignedUrlForm.generated.tsx": "import { CreateApiIdentityChecksSignedUrlBody, createApiIdentityChecksSignedUrlBody } from '@/sections/IdentityChecks/services/apiTypes.generated.ts'\nimport { createIdentityChecksSignedUrlConfig } from '@/sections/IdentityChecks/config/createIdentityChecksSignedUrlConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiIdentityChecksSignedUrl } from '@/sections/IdentityChecks/services/useCreateApiIdentityChecksSignedUrl.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateIdentityChecksSignedUrlFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiIdentityChecksSignedUrlBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createIdentityChecksSignedUrlConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateIdentityChecksSignedUrlFormProps = {children: ReactNode, defaultValues?: CreateApiIdentityChecksSignedUrlBody, onSuccess?: () => void};\nexport const CreateIdentityChecksSignedUrlForm = (props: CreateIdentityChecksSignedUrlFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiIdentityChecksSignedUrlBody>({\n        resolver: zodResolver(createApiIdentityChecksSignedUrlBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiIdentityChecksSignedUrl()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiIdentityChecksSignedUrlBody>({amount: true});",
  "src/sections/IdentityChecks/config/createIdentityChecksSignedUrlConfig.example.tsx": "import { CreateApiIdentityChecksSignedUrlBody } from '@/sections/IdentityChecks/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createIdentityChecksSignedUrlConfig: ModelConfig<CreateApiIdentityChecksSignedUrlBody> = {amount: {\n      key: 'amount',\n      label: 'amount',\n      defaultValue: null,\n      placeholder: 'amount',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/IdentityChecks/services/useCreateApiIdentityChecksSignedUrl.generated.ts": "import { CreatePreSignedUrlsModel } from '@/schemas/createPreSignedUrlsModel.generated.tsx'\nimport { createApiIdentityChecksSignedUrlResponse } from '@/sections/IdentityChecks/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiIdentityChecksSignedUrlFnArgs = {body: CreatePreSignedUrlsModel};\nexport const createApiIdentityChecksSignedUrlFn = async ({body}: CreateApiIdentityChecksSignedUrlFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/identityChecks/signedUrl${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiIdentityChecksSignedUrlResponse.parse(data)\n    };\nexport const useCreateApiIdentityChecksSignedUrl = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiIdentityChecksSignedUrlFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['IdentityChecks']})\n        }\n      })\n    };",
  "src/sections/Invoices/tables/InvoicesTable.generated.tsx": "import { useGetApiInvoices } from '@/sections/Invoices/services/useGetApiInvoices.generated.ts'\nimport { useState } from 'react'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\nimport { useNavigate } from 'react-router-dom'\n\nexport type UseInvoicesTableArgs = {sortBy?: (string) | null | undefined, negotiatorId?: (Array<string>) | null | undefined, propertyId?: (Array<string>) | null | undefined, status?: (Array<'pending' | 'raised' | 'partPaid' | 'partCredited' | 'credited' | 'paid'>) | null | undefined, dateFrom?: (Date) | null | undefined, dateTo?: (Date) | null | undefined, dueDateFrom?: (Date) | null | undefined, dueDateTo?: (Date) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined};\nexport const useInvoicesTable = (args: UseInvoicesTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiInvoices({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const InvoicesTable = () => {\n  \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useInvoicesTable({}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Invoices',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New invoicesTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/invoices/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Invoices/services/useGetApiInvoices.generated.ts": "import { getApiInvoicesResponse } from '@/sections/Invoices/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiInvoicesFnArgs = {pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, sortBy?: (string) | null | undefined, negotiatorId?: (Array<string>) | null | undefined, propertyId?: (Array<string>) | null | undefined, status?: (Array<'pending' | 'raised' | 'partPaid' | 'partCredited' | 'credited' | 'paid'>) | null | undefined, dateFrom?: (Date) | null | undefined, dateTo?: (Date) | null | undefined, dueDateFrom?: (Date) | null | undefined, dueDateTo?: (Date) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined};\nexport const getApiInvoicesFn = async ({pageNumber, pageSize, sortBy, negotiatorId, propertyId, status, dateFrom, dateTo, dueDateFrom, dueDateTo, createdFrom, createdTo, modifiedFrom, modifiedTo}: GetApiInvoicesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/invoices/${querySerialiser({args:{pageNumber, pageSize, sortBy, negotiatorId, propertyId, status, dateFrom, dateTo, dueDateFrom, dueDateTo, createdFrom, createdTo, modifiedFrom, modifiedTo}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiInvoicesResponse.parse(data)\n    };\nexport const useGetApiInvoices = ({pageNumber, pageSize, sortBy, negotiatorId, propertyId, status, dateFrom, dateTo, dueDateFrom, dueDateTo, createdFrom, createdTo, modifiedFrom, modifiedTo}: GetApiInvoicesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Invoices', pageNumber, pageSize, sortBy, negotiatorId, propertyId, status, dateFrom, dateTo, dueDateFrom, dueDateTo, createdFrom, createdTo, modifiedFrom, modifiedTo],\n        queryFn: () => getApiInvoicesFn({pageNumber, pageSize, sortBy, negotiatorId, propertyId, status, dateFrom, dateTo, dueDateFrom, dueDateTo, createdFrom, createdTo, modifiedFrom, modifiedTo}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Invoices/services/apiTypes.generated.ts": "import { invoiceModelPagedResult } from '@/schemas/invoiceModelPagedResult.generated.tsx'\nimport { paymentModelPagedResult } from '@/schemas/paymentModelPagedResult.generated.tsx'\nimport { creditModelPagedResult } from '@/schemas/creditModelPagedResult.generated.tsx'\nimport { chargeModelPagedResult } from '@/schemas/chargeModelPagedResult.generated.tsx'\nimport { invoiceDetailModel } from '@/schemas/invoiceDetailModel.generated.tsx'\nimport { paymentModel } from '@/schemas/paymentModel.generated.tsx'\nimport { creditModel } from '@/schemas/creditModel.generated.tsx'\nimport { chargeModel } from '@/schemas/chargeModel.generated.tsx'\n\nexport const getApiInvoicesResponse = invoiceModelPagedResult;\nexport const getApiInvoicesPaymentsResponse = paymentModelPagedResult;\nexport const getApiInvoicesCreditsResponse = creditModelPagedResult;\nexport const getApiInvoicesChargesResponse = chargeModelPagedResult;\nexport const getApiInvoicesIdResponse = invoiceDetailModel;\nexport const getApiInvoicesPaymentsIdResponse = paymentModel;\nexport const getApiInvoicesCreditsIdResponse = creditModel;\nexport const getApiInvoicesChargesIdResponse = chargeModel;",
  "src/schemas/invoiceModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { invoiceModel, InvoiceModel } from '@/schemas/invoiceModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const invoiceModelPagedResult = z.object({_embedded: z.array(invoiceModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type InvoiceModelPagedResult = {_embedded?: (Array<InvoiceModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/invoiceModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\n\nexport const invoiceModel = /** Representation of an individual invoice */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** Unique identifier of the invoice */\nz.string().optional().nullable(), created: /** The date and time when the invoice was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the invoice was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), reference: /** The invoice reference */\nz.string().optional().nullable(), negotiatorId: /** Unique identifier of the negotiator associated with the invoice */\nz.string().optional().nullable(), propertyId: /** Unique identifier of the property associated with the invoice */\nz.string().optional().nullable(), description: /** Description of the invoice */\nz.string().optional().nullable(), status: /** The status of the invoice */\nz.string().optional().nullable(), date: /** The date of the invoice */\nz.string().pipe( z.coerce.date() ).optional().nullable(), dueDate: /** The due date of the invoice */\nz.string().pipe( z.coerce.date() ).optional().nullable(), isRaised: /** Flag indicating whether the invoice has been raised */\nz.boolean().optional().nullable(), netAmount: /** The net amount due for the invoice in the system base currency */\nz.number().optional().nullable(), vatAmount: /** The amount of VAT due for the invoice in the system base currency */\nz.number().optional().nullable(), outstandingAmount: /** The value of the invoice outstanding in the system base currency */\nz.number().optional().nullable()});\nexport type InvoiceModel = /** Representation of an individual invoice */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** Unique identifier of the invoice */\nstring) | null | undefined, created?: (/** The date and time when the invoice was created */\nDate) | null | undefined, modified?: (/** The date and time when the invoice was last modified */\nDate) | null | undefined, reference?: (/** The invoice reference */\nstring) | null | undefined, negotiatorId?: (/** Unique identifier of the negotiator associated with the invoice */\nstring) | null | undefined, propertyId?: (/** Unique identifier of the property associated with the invoice */\nstring) | null | undefined, description?: (/** Description of the invoice */\nstring) | null | undefined, status?: (/** The status of the invoice */\nstring) | null | undefined, date?: (/** The date of the invoice */\nDate) | null | undefined, dueDate?: (/** The due date of the invoice */\nDate) | null | undefined, isRaised?: (/** Flag indicating whether the invoice has been raised */\nboolean) | null | undefined, netAmount?: (/** The net amount due for the invoice in the system base currency */\nnumber) | null | undefined, vatAmount?: (/** The amount of VAT due for the invoice in the system base currency */\nnumber) | null | undefined, outstandingAmount?: (/** The value of the invoice outstanding in the system base currency */\nnumber) | null | undefined};",
  "src/sections/Invoices/tables/InvoicesPaymentsTable.generated.tsx": "import { useGetApiInvoicesPayments } from '@/sections/Invoices/services/useGetApiInvoicesPayments.generated.ts'\nimport { useState } from 'react'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\nimport { useNavigate } from 'react-router-dom'\n\nexport type UseInvoicesPaymentsTableArgs = {sortBy?: (string) | null | undefined, negotiatorId?: (Array<string>) | null | undefined, propertyId?: (Array<string>) | null | undefined, invoiceId?: (Array<string>) | null | undefined, type?: (Array<'payment' | 'accountPayment' | 'advertisingPayment' | 'buyerDeposit'>) | null | undefined, dateFrom?: (Date) | null | undefined, dateTo?: (Date) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined};\nexport const useInvoicesPaymentsTable = (args: UseInvoicesPaymentsTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiInvoicesPayments({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const InvoicesPaymentsTable = () => {\n  \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useInvoicesPaymentsTable({}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Invoices',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New invoicesPaymentsTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/invoices/payments/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Invoices/services/useGetApiInvoicesPayments.generated.ts": "import { getApiInvoicesPaymentsResponse } from '@/sections/Invoices/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiInvoicesPaymentsFnArgs = {pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, sortBy?: (string) | null | undefined, negotiatorId?: (Array<string>) | null | undefined, propertyId?: (Array<string>) | null | undefined, invoiceId?: (Array<string>) | null | undefined, type?: (Array<'payment' | 'accountPayment' | 'advertisingPayment' | 'buyerDeposit'>) | null | undefined, dateFrom?: (Date) | null | undefined, dateTo?: (Date) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined};\nexport const getApiInvoicesPaymentsFn = async ({pageNumber, pageSize, sortBy, negotiatorId, propertyId, invoiceId, type, dateFrom, dateTo, createdFrom, createdTo, modifiedFrom, modifiedTo}: GetApiInvoicesPaymentsFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/invoices/payments${querySerialiser({args:{pageNumber, pageSize, sortBy, negotiatorId, propertyId, invoiceId, type, dateFrom, dateTo, createdFrom, createdTo, modifiedFrom, modifiedTo}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiInvoicesPaymentsResponse.parse(data)\n    };\nexport const useGetApiInvoicesPayments = ({pageNumber, pageSize, sortBy, negotiatorId, propertyId, invoiceId, type, dateFrom, dateTo, createdFrom, createdTo, modifiedFrom, modifiedTo}: GetApiInvoicesPaymentsFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Invoices', pageNumber, pageSize, sortBy, negotiatorId, propertyId, invoiceId, type, dateFrom, dateTo, createdFrom, createdTo, modifiedFrom, modifiedTo],\n        queryFn: () => getApiInvoicesPaymentsFn({pageNumber, pageSize, sortBy, negotiatorId, propertyId, invoiceId, type, dateFrom, dateTo, createdFrom, createdTo, modifiedFrom, modifiedTo}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/schemas/paymentModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { paymentModel, PaymentModel } from '@/schemas/paymentModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const paymentModelPagedResult = z.object({_embedded: z.array(paymentModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type PaymentModelPagedResult = {_embedded?: (Array<PaymentModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/paymentModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\n\nexport const paymentModel = /** Representation of an individual payment */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** Unique identifier of the payment */\nz.string().optional().nullable(), created: /** The date and time when the payment was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the payment was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), negotiatorId: /** Unique identifier of the negotiator associated with the payment */\nz.string().optional().nullable(), propertyId: /** Unique identifier of the property associated with the payment */\nz.string().optional().nullable(), invoiceId: /** Unique identifier of the invoice associated with the payment */\nz.string().optional().nullable(), description: /** Description of the payment */\nz.string().optional().nullable(), type: /** The type of payment */\nz.string().optional().nullable(), date: /** The date of the payment */\nz.string().pipe( z.coerce.date() ).optional().nullable(), netAmount: /** The net amount due for the payment in the system base currency */\nz.number().optional().nullable(), vatAmount: /** The amount of VAT due for the payment in the system base currency */\nz.number().optional().nullable()});\nexport type PaymentModel = /** Representation of an individual payment */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** Unique identifier of the payment */\nstring) | null | undefined, created?: (/** The date and time when the payment was created */\nDate) | null | undefined, modified?: (/** The date and time when the payment was last modified */\nDate) | null | undefined, negotiatorId?: (/** Unique identifier of the negotiator associated with the payment */\nstring) | null | undefined, propertyId?: (/** Unique identifier of the property associated with the payment */\nstring) | null | undefined, invoiceId?: (/** Unique identifier of the invoice associated with the payment */\nstring) | null | undefined, description?: (/** Description of the payment */\nstring) | null | undefined, type?: (/** The type of payment */\nstring) | null | undefined, date?: (/** The date of the payment */\nDate) | null | undefined, netAmount?: (/** The net amount due for the payment in the system base currency */\nnumber) | null | undefined, vatAmount?: (/** The amount of VAT due for the payment in the system base currency */\nnumber) | null | undefined};",
  "src/sections/Invoices/tables/InvoicesCreditsTable.generated.tsx": "import { useGetApiInvoicesCredits } from '@/sections/Invoices/services/useGetApiInvoicesCredits.generated.ts'\nimport { useState } from 'react'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\nimport { useNavigate } from 'react-router-dom'\n\nexport type UseInvoicesCreditsTableArgs = {sortBy?: (string) | null | undefined, negotiatorId?: (Array<string>) | null | undefined, propertyId?: (Array<string>) | null | undefined, invoiceId?: (Array<string>) | null | undefined, dateFrom?: (Date) | null | undefined, dateTo?: (Date) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined};\nexport const useInvoicesCreditsTable = (args: UseInvoicesCreditsTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiInvoicesCredits({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const InvoicesCreditsTable = () => {\n  \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useInvoicesCreditsTable({}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Invoices',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New invoicesCreditsTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/invoices/credits/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Invoices/services/useGetApiInvoicesCredits.generated.ts": "import { getApiInvoicesCreditsResponse } from '@/sections/Invoices/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiInvoicesCreditsFnArgs = {pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, sortBy?: (string) | null | undefined, negotiatorId?: (Array<string>) | null | undefined, propertyId?: (Array<string>) | null | undefined, invoiceId?: (Array<string>) | null | undefined, dateFrom?: (Date) | null | undefined, dateTo?: (Date) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined};\nexport const getApiInvoicesCreditsFn = async ({pageNumber, pageSize, sortBy, negotiatorId, propertyId, invoiceId, dateFrom, dateTo, createdFrom, createdTo, modifiedFrom, modifiedTo}: GetApiInvoicesCreditsFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/invoices/credits${querySerialiser({args:{pageNumber, pageSize, sortBy, negotiatorId, propertyId, invoiceId, dateFrom, dateTo, createdFrom, createdTo, modifiedFrom, modifiedTo}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiInvoicesCreditsResponse.parse(data)\n    };\nexport const useGetApiInvoicesCredits = ({pageNumber, pageSize, sortBy, negotiatorId, propertyId, invoiceId, dateFrom, dateTo, createdFrom, createdTo, modifiedFrom, modifiedTo}: GetApiInvoicesCreditsFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Invoices', pageNumber, pageSize, sortBy, negotiatorId, propertyId, invoiceId, dateFrom, dateTo, createdFrom, createdTo, modifiedFrom, modifiedTo],\n        queryFn: () => getApiInvoicesCreditsFn({pageNumber, pageSize, sortBy, negotiatorId, propertyId, invoiceId, dateFrom, dateTo, createdFrom, createdTo, modifiedFrom, modifiedTo}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/schemas/creditModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { creditModel, CreditModel } from '@/schemas/creditModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const creditModelPagedResult = z.object({_embedded: z.array(creditModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type CreditModelPagedResult = {_embedded?: (Array<CreditModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/creditModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\n\nexport const creditModel = /** Representation of an individual credit */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** Unique identifier of the credit */\nz.string().optional().nullable(), created: /** The date and time when the credit was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the credit was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), negotiatorId: /** Unique identifier of the negotiator associated with the credit */\nz.string().optional().nullable(), propertyId: /** Unique identifier of the property associated with the credit */\nz.string().optional().nullable(), invoiceId: /** Unique identifier of the invoice associated with the credit */\nz.string().optional().nullable(), description: /** Description of the credit */\nz.string().optional().nullable(), date: /** The date of the credit */\nz.string().pipe( z.coerce.date() ).optional().nullable(), netAmount: /** The net amount due for the credit in the system base currency */\nz.number().optional().nullable(), vatAmount: /** The amount of VAT due for the credit in the system base currency */\nz.number().optional().nullable()});\nexport type CreditModel = /** Representation of an individual credit */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** Unique identifier of the credit */\nstring) | null | undefined, created?: (/** The date and time when the credit was created */\nDate) | null | undefined, modified?: (/** The date and time when the credit was last modified */\nDate) | null | undefined, negotiatorId?: (/** Unique identifier of the negotiator associated with the credit */\nstring) | null | undefined, propertyId?: (/** Unique identifier of the property associated with the credit */\nstring) | null | undefined, invoiceId?: (/** Unique identifier of the invoice associated with the credit */\nstring) | null | undefined, description?: (/** Description of the credit */\nstring) | null | undefined, date?: (/** The date of the credit */\nDate) | null | undefined, netAmount?: (/** The net amount due for the credit in the system base currency */\nnumber) | null | undefined, vatAmount?: (/** The amount of VAT due for the credit in the system base currency */\nnumber) | null | undefined};",
  "src/sections/Invoices/tables/InvoicesChargesTable.generated.tsx": "import { useGetApiInvoicesCharges } from '@/sections/Invoices/services/useGetApiInvoicesCharges.generated.ts'\nimport { useState } from 'react'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\nimport { useNavigate } from 'react-router-dom'\n\nexport type UseInvoicesChargesTableArgs = {sortBy?: (string) | null | undefined, negotiatorId?: (Array<string>) | null | undefined, propertyId?: (Array<string>) | null | undefined, invoiceId?: (Array<string>) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined};\nexport const useInvoicesChargesTable = (args: UseInvoicesChargesTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiInvoicesCharges({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const InvoicesChargesTable = () => {\n  \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useInvoicesChargesTable({}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Invoices',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New invoicesChargesTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/invoices/charges/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Invoices/services/useGetApiInvoicesCharges.generated.ts": "import { getApiInvoicesChargesResponse } from '@/sections/Invoices/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiInvoicesChargesFnArgs = {pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, sortBy?: (string) | null | undefined, negotiatorId?: (Array<string>) | null | undefined, propertyId?: (Array<string>) | null | undefined, invoiceId?: (Array<string>) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined};\nexport const getApiInvoicesChargesFn = async ({pageNumber, pageSize, sortBy, negotiatorId, propertyId, invoiceId, createdFrom, createdTo, modifiedFrom, modifiedTo}: GetApiInvoicesChargesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/invoices/charges${querySerialiser({args:{pageNumber, pageSize, sortBy, negotiatorId, propertyId, invoiceId, createdFrom, createdTo, modifiedFrom, modifiedTo}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiInvoicesChargesResponse.parse(data)\n    };\nexport const useGetApiInvoicesCharges = ({pageNumber, pageSize, sortBy, negotiatorId, propertyId, invoiceId, createdFrom, createdTo, modifiedFrom, modifiedTo}: GetApiInvoicesChargesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Invoices', pageNumber, pageSize, sortBy, negotiatorId, propertyId, invoiceId, createdFrom, createdTo, modifiedFrom, modifiedTo],\n        queryFn: () => getApiInvoicesChargesFn({pageNumber, pageSize, sortBy, negotiatorId, propertyId, invoiceId, createdFrom, createdTo, modifiedFrom, modifiedTo}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/schemas/chargeModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { chargeModel, ChargeModel } from '@/schemas/chargeModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const chargeModelPagedResult = z.object({_embedded: z.array(chargeModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type ChargeModelPagedResult = {_embedded?: (Array<ChargeModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/chargeModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\n\nexport const chargeModel = /** Representation of an invoice charge */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the charge */\nz.string().optional().nullable(), created: /** The date and time when the charge was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the charge was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), type: /** The type of charge (charge/advertising) */\nz.string().optional().nullable(), invoiceId: /** The unique identifier of the invoice with which this charge is associated */\nz.string().optional().nullable(), propertyId: /** The unique identifier of the property with which this charge is associated */\nz.string().optional().nullable(), negotiatorId: /** The unique identifier of the negotiator with which this charge is associated */\nz.string().optional().nullable(), vatCode: /** The code representing the VAT applied to this charge */\nz.string().optional().nullable(), description: /** Description of the charge */\nz.string().optional().nullable(), netAmount: /** The net amount */\nz.number().optional().nullable(), vatAmount: /** The VAT amount */\nz.number().optional().nullable()});\nexport type ChargeModel = /** Representation of an invoice charge */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the charge */\nstring) | null | undefined, created?: (/** The date and time when the charge was created */\nDate) | null | undefined, modified?: (/** The date and time when the charge was last modified */\nDate) | null | undefined, type?: (/** The type of charge (charge/advertising) */\nstring) | null | undefined, invoiceId?: (/** The unique identifier of the invoice with which this charge is associated */\nstring) | null | undefined, propertyId?: (/** The unique identifier of the property with which this charge is associated */\nstring) | null | undefined, negotiatorId?: (/** The unique identifier of the negotiator with which this charge is associated */\nstring) | null | undefined, vatCode?: (/** The code representing the VAT applied to this charge */\nstring) | null | undefined, description?: (/** Description of the charge */\nstring) | null | undefined, netAmount?: (/** The net amount */\nnumber) | null | undefined, vatAmount?: (/** The VAT amount */\nnumber) | null | undefined};",
  "src/sections/JournalEntries/tables/JournalEntriesTable.generated.tsx": "import { useGetApiJournalEntries } from '@/sections/JournalEntries/services/useGetApiJournalEntries.generated.ts'\nimport { useState } from 'react'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\nimport { useNavigate } from 'react-router-dom'\n\nexport type UseJournalEntriesTableArgs = {sortBy?: (string) | null | undefined, embed?: (Array<'property' | 'negotiator' | 'type'>) | null | undefined, associatedType?: (string) | null | undefined, associatedId?: (Array<string>) | null | undefined, negotiatorId?: (Array<string>) | null | undefined, propertyId?: (Array<string>) | null | undefined, typeId?: (Array<string>) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined};\nexport const useJournalEntriesTable = (args: UseJournalEntriesTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiJournalEntries({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const JournalEntriesTable = () => {\n  \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useJournalEntriesTable({}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'JournalEntries',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New journalEntriesTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/journalEntries/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/JournalEntries/services/useGetApiJournalEntries.generated.ts": "import { getApiJournalEntriesResponse } from '@/sections/JournalEntries/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiJournalEntriesFnArgs = {pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, sortBy?: (string) | null | undefined, embed?: (Array<'property' | 'negotiator' | 'type'>) | null | undefined, associatedType?: (string) | null | undefined, associatedId?: (Array<string>) | null | undefined, negotiatorId?: (Array<string>) | null | undefined, propertyId?: (Array<string>) | null | undefined, typeId?: (Array<string>) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined};\nexport const getApiJournalEntriesFn = async ({pageSize, pageNumber, sortBy, embed, associatedType, associatedId, negotiatorId, propertyId, typeId, createdFrom, createdTo}: GetApiJournalEntriesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/journalEntries/${querySerialiser({args:{pageSize, pageNumber, sortBy, embed, associatedType, associatedId, negotiatorId, propertyId, typeId, createdFrom, createdTo}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiJournalEntriesResponse.parse(data)\n    };\nexport const useGetApiJournalEntries = ({pageSize, pageNumber, sortBy, embed, associatedType, associatedId, negotiatorId, propertyId, typeId, createdFrom, createdTo}: GetApiJournalEntriesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['JournalEntries', pageSize, pageNumber, sortBy, embed, associatedType, associatedId, negotiatorId, propertyId, typeId, createdFrom, createdTo],\n        queryFn: () => getApiJournalEntriesFn({pageSize, pageNumber, sortBy, embed, associatedType, associatedId, negotiatorId, propertyId, typeId, createdFrom, createdTo}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/JournalEntries/services/apiTypes.generated.ts": "import { journalEntryModelPagedResult } from '@/schemas/journalEntryModelPagedResult.generated.tsx'\nimport { CreateJournalEntryModel, createJournalEntryModel } from '@/schemas/createJournalEntryModel.generated.tsx'\nimport { z } from 'zod'\nimport { landlordJournalEntryModelPagedResult } from '@/schemas/landlordJournalEntryModelPagedResult.generated.tsx'\nimport { CreateBulkJournalEntryModel, createBulkJournalEntryModel } from '@/schemas/createBulkJournalEntryModel.generated.tsx'\n\nexport const getApiJournalEntriesResponse = journalEntryModelPagedResult;\nexport type CreateApiJournalEntriesBody = CreateJournalEntryModel;\nexport const createApiJournalEntriesBody = createJournalEntryModel;\nexport const createApiJournalEntriesResponse = z.void();\nexport const getApiJournalEntriesLandlordsResponse = landlordJournalEntryModelPagedResult;\nexport type CreateApiJournalEntriesBulkBody = CreateBulkJournalEntryModel;\nexport const createApiJournalEntriesBulkBody = createBulkJournalEntryModel;\nexport const createApiJournalEntriesBulkResponse = z.void();",
  "src/schemas/journalEntryModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { journalEntryModel, JournalEntryModel } from '@/schemas/journalEntryModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const journalEntryModelPagedResult = z.object({_embedded: z.array(journalEntryModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type JournalEntryModelPagedResult = {_embedded?: (Array<JournalEntryModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/journalEntryModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\n\nexport const journalEntryModel = /** Representation of a journal entry */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), created: /** The date and time when the journal entry was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), propertyId: /** The unique identifier of the property the journal entry is related to. Can additionally be associated to another type */\nz.string().optional().nullable(), associatedType: /** The entity type the journal entry has been raised against (applicant/contact/company/landlord/tenancy/worksOrder) */\nz.string().optional().nullable(), associatedId: /** The unique identifier of the entity the journal entry has been raised against. Can additionally be associated to a property */\nz.string().optional().nullable(), typeId: /** The type of journal entry */\nz.string().optional().nullable(), negotiatorId: /** The unique identifier of the negotiator that created the entry */\nz.string().optional().nullable(), description: /** The textual description of the journal entry event */\nz.string().optional().nullable()});\nexport type JournalEntryModel = /** Representation of a journal entry */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, created?: (/** The date and time when the journal entry was created */\nDate) | null | undefined, propertyId?: (/** The unique identifier of the property the journal entry is related to. Can additionally be associated to another type */\nstring) | null | undefined, associatedType?: (/** The entity type the journal entry has been raised against (applicant/contact/company/landlord/tenancy/worksOrder) */\nstring) | null | undefined, associatedId?: (/** The unique identifier of the entity the journal entry has been raised against. Can additionally be associated to a property */\nstring) | null | undefined, typeId?: (/** The type of journal entry */\nstring) | null | undefined, negotiatorId?: (/** The unique identifier of the negotiator that created the entry */\nstring) | null | undefined, description?: (/** The textual description of the journal entry event */\nstring) | null | undefined};",
  "src/sections/JournalEntries/forms/CreateJournalEntries.example.tsx": "import { CreateJournalEntriesForm, fieldNames, CreateJournalEntriesFormFields } from '@/sections/JournalEntries/forms/CreateJournalEntriesForm.generated.tsx'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateJournalEntries = () => {\n      \n\n      \n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateJournalEntriesForm >\n              <FormLayout>\n                <CreateJournalEntriesFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateJournalEntriesForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/JournalEntries/forms/CreateJournalEntriesForm.generated.tsx": "import { CreateApiJournalEntriesBody, createApiJournalEntriesBody } from '@/sections/JournalEntries/services/apiTypes.generated.ts'\nimport { createJournalEntriesConfig } from '@/sections/JournalEntries/config/createJournalEntriesConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiJournalEntries } from '@/sections/JournalEntries/services/useCreateApiJournalEntries.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateJournalEntriesFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiJournalEntriesBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createJournalEntriesConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateJournalEntriesFormProps = {children: ReactNode, defaultValues?: CreateApiJournalEntriesBody, onSuccess?: () => void};\nexport const CreateJournalEntriesForm = (props: CreateJournalEntriesFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiJournalEntriesBody>({\n        resolver: zodResolver(createApiJournalEntriesBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiJournalEntries()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiJournalEntriesBody>({typeId: true, propertyId: true, associatedType: true, associatedId: true, description: true, negotiatorId: true});",
  "src/schemas/createJournalEntryModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateJournalEntryModel = /** Request body to create a journal entry */\n{typeId?: (/** The unique identifier of the type the journal entry is related to.\r\nDefault value set to MI */\nstring) | null | undefined, propertyId?: (/** The unique identifier of the property the journal entry is related to. Can additionally be associated to another type (Required when 'associatedId' is not given) */\nstring) | null | undefined, associatedType?: (/** The entity type the journal entry has been raised against (applicant/contact/company/landlord/tenancy/worksOrder) (Required when 'associatedId' is given)\r\nTypeId must be set to WO when passing worksOrder */\nstring) | null | undefined, associatedId?: (/** The unique identifier of the entity the journal entry has been raised against. Can additionally be associated to a property (Required when 'propertyId' is not given) */\nstring) | null | undefined, description: /** The textual description of the journal entry event */\nstring, negotiatorId?: (/** The identifier of the negotiator recording the journal entry */\nstring) | null | undefined};\nexport const createJournalEntryModel = /** Request body to create a journal entry */\nz.object({typeId: /** The unique identifier of the type the journal entry is related to.\r\nDefault value set to MI */\nz.string().optional().nullable(), propertyId: /** The unique identifier of the property the journal entry is related to. Can additionally be associated to another type (Required when 'associatedId' is not given) */\nz.string().optional().nullable(), associatedType: /** The entity type the journal entry has been raised against (applicant/contact/company/landlord/tenancy/worksOrder) (Required when 'associatedId' is given)\r\nTypeId must be set to WO when passing worksOrder */\nz.string().optional().nullable(), associatedId: /** The unique identifier of the entity the journal entry has been raised against. Can additionally be associated to a property (Required when 'propertyId' is not given) */\nz.string().optional().nullable(), description: /** The textual description of the journal entry event */\nz.string().min(1), negotiatorId: /** The identifier of the negotiator recording the journal entry */\nz.string().optional().nullable()});",
  "src/sections/JournalEntries/config/createJournalEntriesConfig.example.tsx": "import { CreateApiJournalEntriesBody } from '@/sections/JournalEntries/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createJournalEntriesConfig: ModelConfig<CreateApiJournalEntriesBody> = {typeId: {\n      key: 'typeId',\n      label: 'typeId',\n      defaultValue: '',\n      placeholder: 'typeId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, propertyId: {\n      key: 'propertyId',\n      label: 'propertyId',\n      defaultValue: '',\n      placeholder: 'propertyId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, associatedType: {\n      key: 'associatedType',\n      label: 'associatedType',\n      defaultValue: '',\n      placeholder: 'associatedType',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, associatedId: {\n      key: 'associatedId',\n      label: 'associatedId',\n      defaultValue: '',\n      placeholder: 'associatedId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, description: {\n      key: 'description',\n      label: 'description',\n      defaultValue: '',\n      placeholder: 'description',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, negotiatorId: {\n      key: 'negotiatorId',\n      label: 'negotiatorId',\n      defaultValue: '',\n      placeholder: 'negotiatorId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/JournalEntries/services/useCreateApiJournalEntries.generated.ts": "import { CreateJournalEntryModel } from '@/schemas/createJournalEntryModel.generated.tsx'\nimport { createApiJournalEntriesResponse } from '@/sections/JournalEntries/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiJournalEntriesFnArgs = {body: CreateJournalEntryModel};\nexport const createApiJournalEntriesFn = async ({body}: CreateApiJournalEntriesFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/journalEntries/${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiJournalEntriesResponse.parse(data)\n    };\nexport const useCreateApiJournalEntries = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiJournalEntriesFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['JournalEntries']})\n        }\n      })\n    };",
  "src/sections/JournalEntries/tables/JournalEntriesLandlordsTable.generated.tsx": "import { useGetApiJournalEntriesLandlords } from '@/sections/JournalEntries/services/useGetApiJournalEntriesLandlords.generated.ts'\nimport { useState } from 'react'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\nimport { useNavigate } from 'react-router-dom'\n\nexport type UseJournalEntriesLandlordsTableArgs = {sortBy?: (string) | null | undefined, landlordId?: (Array<string>) | null | undefined, negotiatorId?: (Array<string>) | null | undefined, propertyId?: (Array<string>) | null | undefined, type?: (string) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined};\nexport const useJournalEntriesLandlordsTable = (args: UseJournalEntriesLandlordsTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiJournalEntriesLandlords({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const JournalEntriesLandlordsTable = () => {\n  \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useJournalEntriesLandlordsTable({}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'JournalEntries',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New journalEntriesLandlordsTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/journalEntries/landlords/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/JournalEntries/services/useGetApiJournalEntriesLandlords.generated.ts": "import { getApiJournalEntriesLandlordsResponse } from '@/sections/JournalEntries/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiJournalEntriesLandlordsFnArgs = {pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, sortBy?: (string) | null | undefined, landlordId?: (Array<string>) | null | undefined, negotiatorId?: (Array<string>) | null | undefined, propertyId?: (Array<string>) | null | undefined, type?: (string) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined};\nexport const getApiJournalEntriesLandlordsFn = async ({pageSize, pageNumber, sortBy, landlordId, negotiatorId, propertyId, type, createdFrom, createdTo}: GetApiJournalEntriesLandlordsFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/journalEntries/landlords${querySerialiser({args:{pageSize, pageNumber, sortBy, landlordId, negotiatorId, propertyId, type, createdFrom, createdTo}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiJournalEntriesLandlordsResponse.parse(data)\n    };\nexport const useGetApiJournalEntriesLandlords = ({pageSize, pageNumber, sortBy, landlordId, negotiatorId, propertyId, type, createdFrom, createdTo}: GetApiJournalEntriesLandlordsFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['JournalEntries', pageSize, pageNumber, sortBy, landlordId, negotiatorId, propertyId, type, createdFrom, createdTo],\n        queryFn: () => getApiJournalEntriesLandlordsFn({pageSize, pageNumber, sortBy, landlordId, negotiatorId, propertyId, type, createdFrom, createdTo}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/schemas/landlordJournalEntryModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { landlordJournalEntryModel, LandlordJournalEntryModel } from '@/schemas/landlordJournalEntryModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const landlordJournalEntryModelPagedResult = z.object({_embedded: z.array(landlordJournalEntryModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type LandlordJournalEntryModelPagedResult = {_embedded?: (Array<LandlordJournalEntryModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/landlordJournalEntryModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\n\nexport const landlordJournalEntryModel = /** Representation of a landlord related journal entry */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), created: /** The date and time when the journal entry was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), propertyId: /** The unique identifier of the property the journal entry is related to. Can additionally be associated to another type */\nz.string().optional().nullable(), landlordId: /** The unique identifier of the landlord the journal entry is related to. */\nz.string().optional().nullable(), type: /** The type of journal entry */\nz.string().optional().nullable(), negotiatorId: /** The unique identifier of the negotiator that created the entry */\nz.string().optional().nullable(), description: /** The textual description of the journal entry event */\nz.string().optional().nullable()});\nexport type LandlordJournalEntryModel = /** Representation of a landlord related journal entry */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, created?: (/** The date and time when the journal entry was created */\nDate) | null | undefined, propertyId?: (/** The unique identifier of the property the journal entry is related to. Can additionally be associated to another type */\nstring) | null | undefined, landlordId?: (/** The unique identifier of the landlord the journal entry is related to. */\nstring) | null | undefined, type?: (/** The type of journal entry */\nstring) | null | undefined, negotiatorId?: (/** The unique identifier of the negotiator that created the entry */\nstring) | null | undefined, description?: (/** The textual description of the journal entry event */\nstring) | null | undefined};",
  "src/sections/JournalEntries/forms/CreateJournalEntriesBulk.example.tsx": "import { CreateJournalEntriesBulkForm, fieldNames, CreateJournalEntriesBulkFormFields } from '@/sections/JournalEntries/forms/CreateJournalEntriesBulkForm.generated.tsx'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateJournalEntriesBulk = () => {\n      \n\n      \n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateJournalEntriesBulkForm >\n              <FormLayout>\n                <CreateJournalEntriesBulkFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateJournalEntriesBulkForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/JournalEntries/forms/CreateJournalEntriesBulkForm.generated.tsx": "import { CreateApiJournalEntriesBulkBody, createApiJournalEntriesBulkBody } from '@/sections/JournalEntries/services/apiTypes.generated.ts'\nimport { createJournalEntriesBulkConfig } from '@/sections/JournalEntries/config/createJournalEntriesBulkConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiJournalEntriesBulk } from '@/sections/JournalEntries/services/useCreateApiJournalEntriesBulk.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateJournalEntriesBulkFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiJournalEntriesBulkBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createJournalEntriesBulkConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateJournalEntriesBulkFormProps = {children: ReactNode, defaultValues?: CreateApiJournalEntriesBulkBody, onSuccess?: () => void};\nexport const CreateJournalEntriesBulkForm = (props: CreateJournalEntriesBulkFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiJournalEntriesBulkBody>({\n        resolver: zodResolver(createApiJournalEntriesBulkBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiJournalEntriesBulk()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiJournalEntriesBulkBody>({createJournalEntry: true});",
  "src/schemas/createBulkJournalEntryModel.generated.tsx": "import { CreateJournalEntryModel, createJournalEntryModel } from '@/schemas/createJournalEntryModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type CreateBulkJournalEntryModel = /** Request body to create bulk journal entry */\n{createJournalEntry?: (/** Collection of journal entries */\nArray<CreateJournalEntryModel>) | null | undefined};\nexport const createBulkJournalEntryModel = /** Request body to create bulk journal entry */\nz.object({createJournalEntry: /** Collection of journal entries */\nz.array(createJournalEntryModel).optional().nullable()});",
  "src/sections/JournalEntries/config/createJournalEntriesBulkConfig.example.tsx": "import { CreateApiJournalEntriesBulkBody } from '@/sections/JournalEntries/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createJournalEntriesBulkConfig: ModelConfig<CreateApiJournalEntriesBulkBody> = {createJournalEntry: {\n      key: 'createJournalEntry',\n      label: 'createJournalEntry',\n      defaultValue: [],\n      placeholder: 'createJournalEntry',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/JournalEntries/services/useCreateApiJournalEntriesBulk.generated.ts": "import { CreateBulkJournalEntryModel } from '@/schemas/createBulkJournalEntryModel.generated.tsx'\nimport { createApiJournalEntriesBulkResponse } from '@/sections/JournalEntries/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiJournalEntriesBulkFnArgs = {body: CreateBulkJournalEntryModel};\nexport const createApiJournalEntriesBulkFn = async ({body}: CreateApiJournalEntriesBulkFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/journalEntries/bulk${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiJournalEntriesBulkResponse.parse(data)\n    };\nexport const useCreateApiJournalEntriesBulk = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiJournalEntriesBulkFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['JournalEntries']})\n        }\n      })\n    };",
  "src/sections/Landlords/tables/LandlordsTable.generated.tsx": "import { useGetApiLandlords } from '@/sections/Landlords/services/useGetApiLandlords.generated.ts'\nimport { useState } from 'react'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\nimport { useNavigate } from 'react-router-dom'\n\nexport type UseLandlordsTableArgs = {sortBy?: (string) | null | undefined, embed?: (Array<'appointments' | 'documents' | 'office' | 'properties' | 'solicitor' | 'source'>) | null | undefined, id?: (Array<string>) | null | undefined, email?: (Array<string>) | null | undefined, officeId?: (Array<string>) | null | undefined, extrasField?: (Array<string>) | null | undefined, active?: (boolean) | null | undefined, address?: (string) | null | undefined, name?: (string) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, metadata?: (Array<string>) | null | undefined};\nexport const useLandlordsTable = (args: UseLandlordsTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiLandlords({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const LandlordsTable = () => {\n  \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useLandlordsTable({}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Landlords',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New landlordsTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/landlords/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Landlords/services/useGetApiLandlords.generated.ts": "import { getApiLandlordsResponse } from '@/sections/Landlords/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiLandlordsFnArgs = {pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, sortBy?: (string) | null | undefined, embed?: (Array<'appointments' | 'documents' | 'office' | 'properties' | 'solicitor' | 'source'>) | null | undefined, id?: (Array<string>) | null | undefined, email?: (Array<string>) | null | undefined, officeId?: (Array<string>) | null | undefined, extrasField?: (Array<string>) | null | undefined, active?: (boolean) | null | undefined, address?: (string) | null | undefined, name?: (string) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, metadata?: (Array<string>) | null | undefined};\nexport const getApiLandlordsFn = async ({pageSize, pageNumber, sortBy, embed, id, email, officeId, extrasField, active, address, name, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata}: GetApiLandlordsFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/landlords/${querySerialiser({args:{pageSize, pageNumber, sortBy, embed, id, email, officeId, extrasField, active, address, name, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiLandlordsResponse.parse(data)\n    };\nexport const useGetApiLandlords = ({pageSize, pageNumber, sortBy, embed, id, email, officeId, extrasField, active, address, name, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata}: GetApiLandlordsFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Landlords', pageSize, pageNumber, sortBy, embed, id, email, officeId, extrasField, active, address, name, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata],\n        queryFn: () => getApiLandlordsFn({pageSize, pageNumber, sortBy, embed, id, email, officeId, extrasField, active, address, name, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Landlords/services/apiTypes.generated.ts": "import { landlordModelPagedResult } from '@/schemas/landlordModelPagedResult.generated.tsx'\nimport { CreateLandlordModel, createLandlordModel } from '@/schemas/createLandlordModel.generated.tsx'\nimport { z } from 'zod'\nimport { landlordContactRelationshipModelPagedResult } from '@/schemas/landlordContactRelationshipModelPagedResult.generated.tsx'\nimport { InsertLandlordContactRelationshipModel, insertLandlordContactRelationshipModel } from '@/schemas/insertLandlordContactRelationshipModel.generated.tsx'\nimport { landlordModel } from '@/schemas/landlordModel.generated.tsx'\nimport { landlordContactRelationshipModel } from '@/schemas/landlordContactRelationshipModel.generated.tsx'\n\nexport const getApiLandlordsResponse = landlordModelPagedResult;\nexport type CreateApiLandlordsBody = CreateLandlordModel;\nexport const createApiLandlordsBody = createLandlordModel;\nexport const createApiLandlordsResponse = z.void();\nexport const getApiLandlordsIdRelationshipsResponse = landlordContactRelationshipModelPagedResult;\nexport type CreateApiLandlordsIdRelationshipsBody = InsertLandlordContactRelationshipModel;\nexport const createApiLandlordsIdRelationshipsBody = insertLandlordContactRelationshipModel;\nexport const createApiLandlordsIdRelationshipsResponse = z.void();\nexport const getApiLandlordsIdResponse = landlordModel;\nexport const patchApiLandlordsIdResponse = z.void();\nexport const getApiLandlordsIdRelationshipsRelationshipIdResponse = landlordContactRelationshipModel;\nexport const deleteApiLandlordsIdRelationshipsRelationshipIdResponse = z.void();",
  "src/schemas/landlordModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { landlordModel, LandlordModel } from '@/schemas/landlordModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const landlordModelPagedResult = z.object({_embedded: z.array(landlordModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type LandlordModelPagedResult = {_embedded?: (Array<LandlordModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/landlordModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\nimport { landlordSourceModel, LandlordSourceModel } from '@/schemas/landlordSourceModel.generated.tsx'\nimport { landlordContactModel, LandlordContactModel } from '@/schemas/landlordContactModel.generated.tsx'\n\nexport const landlordModel = /** Representation of a landlord */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the landlord */\nz.string().optional().nullable(), created: /** The date and time when the landlord was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the landlord was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), active: /** A flag determining whether or not the landlord is currently active */\nz.boolean().optional().nullable(), solicitorId: /** The unique identifier of the company acting as the landlord's solicitor */\nz.string().optional().nullable(), officeId: /** The unique identifier of the office that is associated to the landlord */\nz.string().optional().nullable(), source: landlordSourceModel.optional().nullable(), related: /** A collection of contacts and/or companies associated to the landlord. The first item in the collection is considered the primary relationship */\nz.array(landlordContactModel).optional().nullable(), metadata: /** App specific metadata that has been set against the landlord */\nz.record(z.string(), z.object({})).optional().nullable(), extrasField: /** The requested extras fields */\nz.record(z.string(), z.object({})).optional().nullable(), _eTag: /** The ETag for the current version of the landlord. Used for managing update concurrency */\nz.string().optional().nullable()});\nexport type LandlordModel = /** Representation of a landlord */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the landlord */\nstring) | null | undefined, created?: (/** The date and time when the landlord was created */\nDate) | null | undefined, modified?: (/** The date and time when the landlord was last modified */\nDate) | null | undefined, active?: (/** A flag determining whether or not the landlord is currently active */\nboolean) | null | undefined, solicitorId?: (/** The unique identifier of the company acting as the landlord's solicitor */\nstring) | null | undefined, officeId?: (/** The unique identifier of the office that is associated to the landlord */\nstring) | null | undefined, source?: (LandlordSourceModel) | null | undefined, related?: (/** A collection of contacts and/or companies associated to the landlord. The first item in the collection is considered the primary relationship */\nArray<LandlordContactModel>) | null | undefined, metadata?: (/** App specific metadata that has been set against the landlord */\nRecord<string, Record<string, never>>) | null | undefined, extrasField?: (/** The requested extras fields */\nRecord<string, Record<string, never>>) | null | undefined, _eTag?: (/** The ETag for the current version of the landlord. Used for managing update concurrency */\nstring) | null | undefined};",
  "src/schemas/landlordSourceModel.generated.tsx": "import { z } from 'zod'\n\nexport const landlordSourceModel = /** Representation of a landlord's source */\nz.object({id: /** The unique identifier of the source of the landlord */\nz.string().optional().nullable(), type: /** The source type (office/source) */\nz.string().optional().nullable()});\nexport type LandlordSourceModel = /** Representation of a landlord's source */\n{id?: (/** The unique identifier of the source of the landlord */\nstring) | null | undefined, type?: (/** The source type (office/source) */\nstring) | null | undefined};",
  "src/schemas/landlordContactModel.generated.tsx": "import { z } from 'zod'\nimport { landlordContactAddressModel, LandlordContactAddressModel } from '@/schemas/landlordContactAddressModel.generated.tsx'\nimport { additionalContactDetailModel, AdditionalContactDetailModel } from '@/schemas/additionalContactDetailModel.generated.tsx'\n\nexport const landlordContactModel = /** A summarised view of the details of a contact associated to a landlord */\nz.object({id: /** The unique identifier of the contact */\nz.string().optional().nullable(), name: /** The complete name of the contact or company */\nz.string().optional().nullable(), title: /** The title of the contact (Available when 'type' is 'contact') */\nz.string().optional().nullable(), forename: /** The forename of the contact (Available when 'type' is 'contact') */\nz.string().optional().nullable(), surname: /** The surname of the contact (Available when 'type' is 'contact') */\nz.string().optional().nullable(), dateOfBirth: /** The date of birth of the contact (Available when 'type' is 'contact') */\nz.string().optional().nullable(), type: /** The type of the contact (contact/company) */\nz.string().optional().nullable(), homePhone: /** The home phone number of the contact */\nz.string().optional().nullable(), workPhone: /** The work phone number of the contact */\nz.string().optional().nullable(), mobilePhone: /** The mobile phone number of the contact */\nz.string().optional().nullable(), email: /** The email address of the contact */\nz.string().optional().nullable(), marketingConsent: /** The marketing consent status of the contact (grant/deny/notAsked/unknown) */\nz.string().optional().nullable(), primaryAddress: landlordContactAddressModel.optional().nullable(), additionalContactDetails: /** A collection of additional contact details */\nz.array(additionalContactDetailModel).optional().nullable()});\nexport type LandlordContactModel = /** A summarised view of the details of a contact associated to a landlord */\n{id?: (/** The unique identifier of the contact */\nstring) | null | undefined, name?: (/** The complete name of the contact or company */\nstring) | null | undefined, title?: (/** The title of the contact (Available when 'type' is 'contact') */\nstring) | null | undefined, forename?: (/** The forename of the contact (Available when 'type' is 'contact') */\nstring) | null | undefined, surname?: (/** The surname of the contact (Available when 'type' is 'contact') */\nstring) | null | undefined, dateOfBirth?: (/** The date of birth of the contact (Available when 'type' is 'contact') */\nstring) | null | undefined, type?: (/** The type of the contact (contact/company) */\nstring) | null | undefined, homePhone?: (/** The home phone number of the contact */\nstring) | null | undefined, workPhone?: (/** The work phone number of the contact */\nstring) | null | undefined, mobilePhone?: (/** The mobile phone number of the contact */\nstring) | null | undefined, email?: (/** The email address of the contact */\nstring) | null | undefined, marketingConsent?: (/** The marketing consent status of the contact (grant/deny/notAsked/unknown) */\nstring) | null | undefined, primaryAddress?: (LandlordContactAddressModel) | null | undefined, additionalContactDetails?: (/** A collection of additional contact details */\nArray<AdditionalContactDetailModel>) | null | undefined};",
  "src/schemas/landlordContactAddressModel.generated.tsx": "import { z } from 'zod'\n\nexport const landlordContactAddressModel = /** Representation of the physical address of a building or premise */\nz.object({buildingName: /** The building name */\nz.string().optional().nullable(), buildingNumber: /** The building number */\nz.string().optional().nullable(), line1: /** The first line of the address */\nz.string().optional().nullable(), line2: /** The second line of the address */\nz.string().optional().nullable(), line3: /** The third line of the address */\nz.string().optional().nullable(), line4: /** The fourth line of the address */\nz.string().optional().nullable(), postcode: /** The postcode */\nz.string().optional().nullable(), countryId: /** The ISO-3166 country code that the address resides within */\nz.string().optional().nullable()});\nexport type LandlordContactAddressModel = /** Representation of the physical address of a building or premise */\n{buildingName?: (/** The building name */\nstring) | null | undefined, buildingNumber?: (/** The building number */\nstring) | null | undefined, line1?: (/** The first line of the address */\nstring) | null | undefined, line2?: (/** The second line of the address */\nstring) | null | undefined, line3?: (/** The third line of the address */\nstring) | null | undefined, line4?: (/** The fourth line of the address */\nstring) | null | undefined, postcode?: (/** The postcode */\nstring) | null | undefined, countryId?: (/** The ISO-3166 country code that the address resides within */\nstring) | null | undefined};",
  "src/sections/Landlords/forms/CreateLandlords.example.tsx": "import { CreateLandlordsForm, fieldNames, CreateLandlordsFormFields } from '@/sections/Landlords/forms/CreateLandlordsForm.generated.tsx'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateLandlords = () => {\n      \n\n      \n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateLandlordsForm >\n              <FormLayout>\n                <CreateLandlordsFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateLandlordsForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Landlords/forms/CreateLandlordsForm.generated.tsx": "import { CreateApiLandlordsBody, createApiLandlordsBody } from '@/sections/Landlords/services/apiTypes.generated.ts'\nimport { createLandlordsConfig } from '@/sections/Landlords/config/createLandlordsConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiLandlords } from '@/sections/Landlords/services/useCreateApiLandlords.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateLandlordsFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiLandlordsBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createLandlordsConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateLandlordsFormProps = {children: ReactNode, defaultValues?: CreateApiLandlordsBody, onSuccess?: () => void};\nexport const CreateLandlordsForm = (props: CreateLandlordsFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiLandlordsBody>({\n        resolver: zodResolver(createApiLandlordsBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiLandlords()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiLandlordsBody>({active: true, solicitorId: true, officeId: true, source: true, related: true, metadata: true});",
  "src/schemas/createLandlordModel.generated.tsx": "import { CreateLandlordSourceModel, createLandlordSourceModel } from '@/schemas/createLandlordSourceModel.generated.tsx'\nimport { CreateLandlordContactRelationshipModel, createLandlordContactRelationshipModel } from '@/schemas/createLandlordContactRelationshipModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type CreateLandlordModel = /** Request body used to create a new landlord */\n{active?: (/** A flag determining whether or not the landlord is currently active */\nboolean) | null | undefined, solicitorId?: (/** The unique identifier of the company acting as the landlord's solicitor */\nstring) | null | undefined, officeId: /** The unique identifier of the office that is associated to the landlord */\nstring, source?: (CreateLandlordSourceModel) | null | undefined, related: /** A collection of contacts and/or companies associated to the landlord. The first item in the collection is considered the primary relationship */\nArray<CreateLandlordContactRelationshipModel>, metadata?: (/** App specific metadata that to set against the landlord */\nRecord<string, Record<string, never>>) | null | undefined};\nexport const createLandlordModel = /** Request body used to create a new landlord */\nz.object({active: /** A flag determining whether or not the landlord is currently active */\nz.boolean().optional().nullable(), solicitorId: /** The unique identifier of the company acting as the landlord's solicitor */\nz.string().optional().nullable(), officeId: /** The unique identifier of the office that is associated to the landlord */\nz.string().min(1), source: createLandlordSourceModel.optional().nullable(), related: /** A collection of contacts and/or companies associated to the landlord. The first item in the collection is considered the primary relationship */\nz.array(createLandlordContactRelationshipModel), metadata: /** App specific metadata that to set against the landlord */\nz.record(z.string(), z.object({})).optional().nullable()});",
  "src/schemas/createLandlordSourceModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateLandlordSourceModel = /** Request body used to set the source of a new landlord */\n{id?: (/** The unique identifier of the source of the landlord */\nstring) | null | undefined, type?: (/** The source type (office/source) */\nstring) | null | undefined};\nexport const createLandlordSourceModel = /** Request body used to set the source of a new landlord */\nz.object({id: /** The unique identifier of the source of the landlord */\nz.string().optional().nullable(), type: /** The source type (office/source) */\nz.string().optional().nullable()});",
  "src/schemas/createLandlordContactRelationshipModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateLandlordContactRelationshipModel = /** Request body used to create a new relationship between a landlord and a contact or company */\n{associatedId?: (/** The unique identifier of the contact or company to create a relationship with */\nstring) | null | undefined, associatedType?: (/** The type of relationship to create (contact/company) */\nstring) | null | undefined};\nexport const createLandlordContactRelationshipModel = /** Request body used to create a new relationship between a landlord and a contact or company */\nz.object({associatedId: /** The unique identifier of the contact or company to create a relationship with */\nz.string().optional().nullable(), associatedType: /** The type of relationship to create (contact/company) */\nz.string().optional().nullable()});",
  "src/sections/Landlords/config/createLandlordsConfig.example.tsx": "import { CreateApiLandlordsBody } from '@/sections/Landlords/services/apiTypes.generated.ts'\nimport { Switch } from '@/inputs/Switch.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createLandlordsConfig: ModelConfig<CreateApiLandlordsBody> = {active: {\n      key: 'active',\n      label: 'active',\n      defaultValue: false,\n      placeholder: 'active',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><Switch {...props} /></InputWrap>\n    }, solicitorId: {\n      key: 'solicitorId',\n      label: 'solicitorId',\n      defaultValue: '',\n      placeholder: 'solicitorId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, officeId: {\n      key: 'officeId',\n      label: 'officeId',\n      defaultValue: '',\n      placeholder: 'officeId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, source: {\n      key: 'source',\n      label: 'source',\n      defaultValue: null,\n      placeholder: 'source',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, related: {\n      key: 'related',\n      label: 'related',\n      defaultValue: [],\n      placeholder: 'related',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, metadata: {\n      key: 'metadata',\n      label: 'metadata',\n      defaultValue: null,\n      placeholder: 'metadata',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/Landlords/services/useCreateApiLandlords.generated.ts": "import { CreateLandlordModel } from '@/schemas/createLandlordModel.generated.tsx'\nimport { createApiLandlordsResponse } from '@/sections/Landlords/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiLandlordsFnArgs = {body: CreateLandlordModel};\nexport const createApiLandlordsFn = async ({body}: CreateApiLandlordsFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/landlords/${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiLandlordsResponse.parse(data)\n    };\nexport const useCreateApiLandlords = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiLandlordsFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Landlords']})\n        }\n      })\n    };",
  "src/sections/Landlords/tables/LandlordsIdRelationshipsTable.generated.tsx": "import { useGetApiLandlordsIdRelationships } from '@/sections/Landlords/services/useGetApiLandlordsIdRelationships.generated.ts'\nimport { useState } from 'react'\nimport { useParams, useNavigate } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\n\nexport type UseLandlordsIdRelationshipsTableArgs = {id: string};\nexport const useLandlordsIdRelationshipsTable = (args: UseLandlordsIdRelationshipsTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiLandlordsIdRelationships({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const LandlordsIdRelationshipsTable = () => {\n  const {id} = useParams()\n    \n    invariant(id, 'Missing id param')\n    \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useLandlordsIdRelationshipsTable({id}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Landlords',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New landlordsIdRelationshipsTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/landlords/${id}/relationships/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Landlords/services/useGetApiLandlordsIdRelationships.generated.ts": "import { getApiLandlordsIdRelationshipsResponse } from '@/sections/Landlords/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiLandlordsIdRelationshipsFnArgs = {id: string, pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined};\nexport const getApiLandlordsIdRelationshipsFn = async ({id, pageSize, pageNumber}: GetApiLandlordsIdRelationshipsFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/landlords/${id}/relationships${querySerialiser({args:{pageSize, pageNumber}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiLandlordsIdRelationshipsResponse.parse(data)\n    };\nexport const useGetApiLandlordsIdRelationships = ({id, pageSize, pageNumber}: GetApiLandlordsIdRelationshipsFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Landlords', id, pageSize, pageNumber],\n        queryFn: () => getApiLandlordsIdRelationshipsFn({id, pageSize, pageNumber}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/schemas/landlordContactRelationshipModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { landlordContactRelationshipModel, LandlordContactRelationshipModel } from '@/schemas/landlordContactRelationshipModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const landlordContactRelationshipModelPagedResult = z.object({_embedded: z.array(landlordContactRelationshipModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type LandlordContactRelationshipModelPagedResult = {_embedded?: (Array<LandlordContactRelationshipModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/landlordContactRelationshipModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\n\nexport const landlordContactRelationshipModel = /** Representation of relationship between a landlord and a contact or company */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the landlord relationship */\nz.string().optional().nullable(), landlordId: /** The unique identifier of the landlord */\nz.string().optional().nullable(), created: /** The date and time when the relationship was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the relationship was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), associatedType: /** The type of related entity (contact/company) */\nz.string().optional().nullable(), associatedId: /** The unique identifier of the related contact or company */\nz.string().optional().nullable(), isMain: /** A flag denoting whether or not the relationship should be regarded as the main relationship for the parent landlord entity */\nz.boolean().optional().nullable()});\nexport type LandlordContactRelationshipModel = /** Representation of relationship between a landlord and a contact or company */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the landlord relationship */\nstring) | null | undefined, landlordId?: (/** The unique identifier of the landlord */\nstring) | null | undefined, created?: (/** The date and time when the relationship was created */\nDate) | null | undefined, modified?: (/** The date and time when the relationship was last modified */\nDate) | null | undefined, associatedType?: (/** The type of related entity (contact/company) */\nstring) | null | undefined, associatedId?: (/** The unique identifier of the related contact or company */\nstring) | null | undefined, isMain?: (/** A flag denoting whether or not the relationship should be regarded as the main relationship for the parent landlord entity */\nboolean) | null | undefined};",
  "src/sections/Landlords/forms/CreateLandlordsIdRelationships.example.tsx": "import { CreateLandlordsIdRelationshipsForm, fieldNames, CreateLandlordsIdRelationshipsFormFields } from '@/sections/Landlords/forms/CreateLandlordsIdRelationshipsForm.generated.tsx'\nimport { useParams } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateLandlordsIdRelationships = () => {\n      const { id } = useParams()\n\n      invariant(id, 'Expected id to be defined')\n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateLandlordsIdRelationshipsForm id={id}>\n              <FormLayout>\n                <CreateLandlordsIdRelationshipsFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateLandlordsIdRelationshipsForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Landlords/forms/CreateLandlordsIdRelationshipsForm.generated.tsx": "import { CreateApiLandlordsIdRelationshipsBody, createApiLandlordsIdRelationshipsBody } from '@/sections/Landlords/services/apiTypes.generated.ts'\nimport { createLandlordsIdRelationshipsConfig } from '@/sections/Landlords/config/createLandlordsIdRelationshipsConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiLandlordsIdRelationships } from '@/sections/Landlords/services/useCreateApiLandlordsIdRelationships.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateLandlordsIdRelationshipsFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiLandlordsIdRelationshipsBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createLandlordsIdRelationshipsConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateLandlordsIdRelationshipsFormProps = {id: string, children: ReactNode, defaultValues?: CreateApiLandlordsIdRelationshipsBody, onSuccess?: () => void};\nexport const CreateLandlordsIdRelationshipsForm = (props: CreateLandlordsIdRelationshipsFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiLandlordsIdRelationshipsBody>({\n        resolver: zodResolver(createApiLandlordsIdRelationshipsBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiLandlordsIdRelationships()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiLandlordsIdRelationshipsBody>({associatedId: true, associatedType: true, isMain: true});",
  "src/schemas/insertLandlordContactRelationshipModel.generated.tsx": "import { z } from 'zod'\n\nexport type InsertLandlordContactRelationshipModel = /** Request body used to create or update a relationship between a landlord and a contact or company */\n{associatedId: /** The unique identifier of the contact or company to create a relationship with */\nstring, associatedType: /** The type of relationship to create (contact/company) */\nstring, isMain: /** Flag denoting whether or not this relationship should be considered to be the main/primary relationship. Setting to true will automatically demote the existing primary relationship */\nboolean};\nexport const insertLandlordContactRelationshipModel = /** Request body used to create or update a relationship between a landlord and a contact or company */\nz.object({associatedId: /** The unique identifier of the contact or company to create a relationship with */\nz.string().min(1), associatedType: /** The type of relationship to create (contact/company) */\nz.string().min(1), isMain: /** Flag denoting whether or not this relationship should be considered to be the main/primary relationship. Setting to true will automatically demote the existing primary relationship */\nz.boolean()});",
  "src/sections/Landlords/config/createLandlordsIdRelationshipsConfig.example.tsx": "import { CreateApiLandlordsIdRelationshipsBody } from '@/sections/Landlords/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { Switch } from '@/inputs/Switch.tsx'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createLandlordsIdRelationshipsConfig: ModelConfig<CreateApiLandlordsIdRelationshipsBody> = {associatedId: {\n      key: 'associatedId',\n      label: 'associatedId',\n      defaultValue: '',\n      placeholder: 'associatedId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, associatedType: {\n      key: 'associatedType',\n      label: 'associatedType',\n      defaultValue: '',\n      placeholder: 'associatedType',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, isMain: {\n      key: 'isMain',\n      label: 'isMain',\n      defaultValue: false,\n      placeholder: 'isMain',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><Switch {...props} /></InputWrap>\n    }};",
  "src/sections/Landlords/services/useCreateApiLandlordsIdRelationships.generated.ts": "import { InsertLandlordContactRelationshipModel } from '@/schemas/insertLandlordContactRelationshipModel.generated.tsx'\nimport { createApiLandlordsIdRelationshipsResponse } from '@/sections/Landlords/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiLandlordsIdRelationshipsFnArgs = {id: string, body: InsertLandlordContactRelationshipModel};\nexport const createApiLandlordsIdRelationshipsFn = async ({id, body}: CreateApiLandlordsIdRelationshipsFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/landlords/${id}/relationships${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiLandlordsIdRelationshipsResponse.parse(data)\n    };\nexport const useCreateApiLandlordsIdRelationships = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiLandlordsIdRelationshipsFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Landlords']})\n        }\n      })\n    };",
  "src/sections/Metadata/tables/MetadataTable.generated.tsx": "import { useGetApiMetadata } from '@/sections/Metadata/services/useGetApiMetadata.generated.ts'\nimport { useState } from 'react'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\nimport { useNavigate } from 'react-router-dom'\n\nexport type UseMetadataTableArgs = {entityType?: (string) | null | undefined, id?: (Array<string>) | null | undefined, entityId?: (Array<string>) | null | undefined, filter?: (Array<string>) | null | undefined};\nexport const useMetadataTable = (args: UseMetadataTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiMetadata({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const MetadataTable = () => {\n  \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useMetadataTable({}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Metadata',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New metadataTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/metadata/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Metadata/services/useGetApiMetadata.generated.ts": "import { getApiMetadataResponse } from '@/sections/Metadata/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiMetadataFnArgs = {pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, entityType?: (string) | null | undefined, id?: (Array<string>) | null | undefined, entityId?: (Array<string>) | null | undefined, filter?: (Array<string>) | null | undefined};\nexport const getApiMetadataFn = async ({pageSize, pageNumber, entityType, id, entityId, filter}: GetApiMetadataFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/metadata/${querySerialiser({args:{pageSize, pageNumber, entityType, id, entityId, filter}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiMetadataResponse.parse(data)\n    };\nexport const useGetApiMetadata = ({pageSize, pageNumber, entityType, id, entityId, filter}: GetApiMetadataFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Metadata', pageSize, pageNumber, entityType, id, entityId, filter],\n        queryFn: () => getApiMetadataFn({pageSize, pageNumber, entityType, id, entityId, filter}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Metadata/services/apiTypes.generated.ts": "import { metadataModelPagedResult } from '@/schemas/metadataModelPagedResult.generated.tsx'\nimport { CreateMetadataRequest, createMetadataRequest } from '@/schemas/createMetadataRequest.generated.tsx'\nimport { z } from 'zod'\nimport { metadataModel } from '@/schemas/metadataModel.generated.tsx'\n\nexport const getApiMetadataResponse = metadataModelPagedResult;\nexport type CreateApiMetadataBody = CreateMetadataRequest;\nexport const createApiMetadataBody = createMetadataRequest;\nexport const createApiMetadataResponse = z.void();\nexport const getApiMetadataIdResponse = metadataModel;\nexport const updateApiMetadataIdResponse = z.void();\nexport const deleteApiMetadataIdResponse = z.void();\nexport const patchApiMetadataIdResponse = z.void();",
  "src/schemas/metadataModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { metadataModel, MetadataModel } from '@/schemas/metadataModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const metadataModelPagedResult = z.object({_embedded: z.array(metadataModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type MetadataModelPagedResult = {_embedded?: (Array<MetadataModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/metadataModel.generated.tsx": "import { z } from 'zod'\n\nexport const metadataModel = /** Model representing the state of a metadata record for a given entity */\nz.object({id: /** The unique identifier of this metadata record */\nz.string().optional().nullable(), modified: /** The date and time of when this metadata record was last updated */\nz.string().pipe( z.coerce.date() ).optional().nullable(), entityType: /** The name of the entity type that this metadata record is associated to */\nz.string().optional().nullable(), entityId: /** The unique identifier of the the entity that this metadata is associated to */\nz.string().optional().nullable(), metadata: /** The JSON document content */\nz.string().optional().nullable()});\nexport type MetadataModel = /** Model representing the state of a metadata record for a given entity */\n{id?: (/** The unique identifier of this metadata record */\nstring) | null | undefined, modified?: (/** The date and time of when this metadata record was last updated */\nDate) | null | undefined, entityType?: (/** The name of the entity type that this metadata record is associated to */\nstring) | null | undefined, entityId?: (/** The unique identifier of the the entity that this metadata is associated to */\nstring) | null | undefined, metadata?: (/** The JSON document content */\nstring) | null | undefined};",
  "src/sections/Metadata/forms/CreateMetadata.example.tsx": "import { CreateMetadataForm, fieldNames, CreateMetadataFormFields } from '@/sections/Metadata/forms/CreateMetadataForm.generated.tsx'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateMetadata = () => {\n      \n\n      \n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateMetadataForm >\n              <FormLayout>\n                <CreateMetadataFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateMetadataForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Metadata/forms/CreateMetadataForm.generated.tsx": "import { CreateApiMetadataBody, createApiMetadataBody } from '@/sections/Metadata/services/apiTypes.generated.ts'\nimport { createMetadataConfig } from '@/sections/Metadata/config/createMetadataConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiMetadata } from '@/sections/Metadata/services/useCreateApiMetadata.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateMetadataFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiMetadataBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createMetadataConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateMetadataFormProps = {children: ReactNode, defaultValues?: CreateApiMetadataBody, onSuccess?: () => void};\nexport const CreateMetadataForm = (props: CreateMetadataFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiMetadataBody>({\n        resolver: zodResolver(createApiMetadataBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiMetadata()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiMetadataBody>({entityType: true, entityId: true, metadata: true});",
  "src/schemas/createMetadataRequest.generated.tsx": "import { z } from 'zod'\n\nexport type CreateMetadataRequest = /** Payload to create a metadata record */\n{entityType: /** The type of the entity that this metadata is related to. This can represent a Foundations inbuilt type (an entity presented in our APIs) or it can be a custom entity type (a dynamic standalone metadata entity that you create).\r\n            \r\nInbuilt types: applicant, appointment, company, contact, conveyancing, identityCheck, landlord, negotiator, offer, office, property, task, vendor, worksOrder */\nstring, entityId?: (/** The unique identifier of the entity that this metadata is related to.\r\nFor custom entities, this can be left blank and an id will be generated for you. */\nstring) | null | undefined, metadata: /** The JSON document to store */\nstring};\nexport const createMetadataRequest = /** Payload to create a metadata record */\nz.object({entityType: /** The type of the entity that this metadata is related to. This can represent a Foundations inbuilt type (an entity presented in our APIs) or it can be a custom entity type (a dynamic standalone metadata entity that you create).\r\n            \r\nInbuilt types: applicant, appointment, company, contact, conveyancing, identityCheck, landlord, negotiator, offer, office, property, task, vendor, worksOrder */\nz.string().min(1), entityId: /** The unique identifier of the entity that this metadata is related to.\r\nFor custom entities, this can be left blank and an id will be generated for you. */\nz.string().optional().nullable(), metadata: /** The JSON document to store */\nz.string().min(1)});",
  "src/sections/Metadata/config/createMetadataConfig.example.tsx": "import { CreateApiMetadataBody } from '@/sections/Metadata/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createMetadataConfig: ModelConfig<CreateApiMetadataBody> = {entityType: {\n      key: 'entityType',\n      label: 'entityType',\n      defaultValue: '',\n      placeholder: 'entityType',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, entityId: {\n      key: 'entityId',\n      label: 'entityId',\n      defaultValue: '',\n      placeholder: 'entityId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, metadata: {\n      key: 'metadata',\n      label: 'metadata',\n      defaultValue: '',\n      placeholder: 'metadata',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/Metadata/services/useCreateApiMetadata.generated.ts": "import { CreateMetadataRequest } from '@/schemas/createMetadataRequest.generated.tsx'\nimport { createApiMetadataResponse } from '@/sections/Metadata/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiMetadataFnArgs = {body: CreateMetadataRequest};\nexport const createApiMetadataFn = async ({body}: CreateApiMetadataFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/metadata/${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiMetadataResponse.parse(data)\n    };\nexport const useCreateApiMetadata = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiMetadataFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Metadata']})\n        }\n      })\n    };",
  "src/sections/MetadataSchema/tables/MetadataMetadataSchemaTable.generated.tsx": "import { useGetApiMetadataMetadataSchema } from '@/sections/MetadataSchema/services/useGetApiMetadataMetadataSchema.generated.ts'\nimport { useState } from 'react'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\nimport { useNavigate } from 'react-router-dom'\n\nexport type UseMetadataMetadataSchemaTableArgs = {entityType?: (string) | null | undefined};\nexport const useMetadataMetadataSchemaTable = (args: UseMetadataMetadataSchemaTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiMetadataMetadataSchema({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const MetadataMetadataSchemaTable = () => {\n  \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useMetadataMetadataSchemaTable({}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'MetadataSchema',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New metadataMetadataSchemaTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/metadata/metadataSchema/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/MetadataSchema/services/useGetApiMetadataMetadataSchema.generated.ts": "import { getApiMetadataMetadataSchemaResponse } from '@/sections/MetadataSchema/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiMetadataMetadataSchemaFnArgs = {pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, entityType?: (string) | null | undefined};\nexport const getApiMetadataMetadataSchemaFn = async ({pageSize, pageNumber, entityType}: GetApiMetadataMetadataSchemaFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/metadata/metadataSchema${querySerialiser({args:{pageSize, pageNumber, entityType}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiMetadataMetadataSchemaResponse.parse(data)\n    };\nexport const useGetApiMetadataMetadataSchema = ({pageSize, pageNumber, entityType}: GetApiMetadataMetadataSchemaFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['MetadataSchema', pageSize, pageNumber, entityType],\n        queryFn: () => getApiMetadataMetadataSchemaFn({pageSize, pageNumber, entityType}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/MetadataSchema/services/apiTypes.generated.ts": "import { schemaModelPagedResult } from '@/schemas/schemaModelPagedResult.generated.tsx'\nimport { CreateSchemaRequest, createSchemaRequest } from '@/schemas/createSchemaRequest.generated.tsx'\nimport { z } from 'zod'\nimport { schemaModel } from '@/schemas/schemaModel.generated.tsx'\n\nexport const getApiMetadataMetadataSchemaResponse = schemaModelPagedResult;\nexport type CreateApiMetadataMetadataSchemaBody = CreateSchemaRequest;\nexport const createApiMetadataMetadataSchemaBody = createSchemaRequest;\nexport const createApiMetadataMetadataSchemaResponse = z.void();\nexport const getApiMetadataMetadataSchemaIdResponse = schemaModel;\nexport const updateApiMetadataMetadataSchemaIdResponse = z.void();",
  "src/schemas/schemaModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { schemaModel, SchemaModel } from '@/schemas/schemaModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const schemaModelPagedResult = z.object({_embedded: z.array(schemaModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type SchemaModelPagedResult = {_embedded?: (Array<SchemaModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/schemaModel.generated.tsx": "import { z } from 'zod'\n\nexport const schemaModel = /** Model representing a JSON schema used to validate a specific entity type */\nz.object({id: /** The unique identifier of this JSON schema */\nz.string().optional().nullable(), modified: /** The date and time of when this JSON schema was last updated */\nz.string().pipe( z.coerce.date() ).optional().nullable(), schema: /** The JSON schema document */\nz.string().optional().nullable()});\nexport type SchemaModel = /** Model representing a JSON schema used to validate a specific entity type */\n{id?: (/** The unique identifier of this JSON schema */\nstring) | null | undefined, modified?: (/** The date and time of when this JSON schema was last updated */\nDate) | null | undefined, schema?: (/** The JSON schema document */\nstring) | null | undefined};",
  "src/sections/MetadataSchema/forms/CreateMetadataMetadataSchema.example.tsx": "import { CreateMetadataMetadataSchemaForm, fieldNames, CreateMetadataMetadataSchemaFormFields } from '@/sections/MetadataSchema/forms/CreateMetadataMetadataSchemaForm.generated.tsx'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateMetadataMetadataSchema = () => {\n      \n\n      \n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateMetadataMetadataSchemaForm >\n              <FormLayout>\n                <CreateMetadataMetadataSchemaFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateMetadataMetadataSchemaForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/MetadataSchema/forms/CreateMetadataMetadataSchemaForm.generated.tsx": "import { CreateApiMetadataMetadataSchemaBody, createApiMetadataMetadataSchemaBody } from '@/sections/MetadataSchema/services/apiTypes.generated.ts'\nimport { createMetadataMetadataSchemaConfig } from '@/sections/MetadataSchema/config/createMetadataMetadataSchemaConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiMetadataMetadataSchema } from '@/sections/MetadataSchema/services/useCreateApiMetadataMetadataSchema.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateMetadataMetadataSchemaFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiMetadataMetadataSchemaBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createMetadataMetadataSchemaConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateMetadataMetadataSchemaFormProps = {children: ReactNode, defaultValues?: CreateApiMetadataMetadataSchemaBody, onSuccess?: () => void};\nexport const CreateMetadataMetadataSchemaForm = (props: CreateMetadataMetadataSchemaFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiMetadataMetadataSchemaBody>({\n        resolver: zodResolver(createApiMetadataMetadataSchemaBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiMetadataMetadataSchema()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiMetadataMetadataSchemaBody>({entityType: true, schema: true});",
  "src/schemas/createSchemaRequest.generated.tsx": "import { z } from 'zod'\n\nexport type CreateSchemaRequest = /** Payload to create a JSON schema for metadata validation */\n{entityType: /** The name of the entity type that this schema is related to */\nstring, schema: /** The JSON schema used to validate entities of this type */\nstring};\nexport const createSchemaRequest = /** Payload to create a JSON schema for metadata validation */\nz.object({entityType: /** The name of the entity type that this schema is related to */\nz.string().min(1), schema: /** The JSON schema used to validate entities of this type */\nz.string().min(1)});",
  "src/sections/MetadataSchema/config/createMetadataMetadataSchemaConfig.example.tsx": "import { CreateApiMetadataMetadataSchemaBody } from '@/sections/MetadataSchema/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createMetadataMetadataSchemaConfig: ModelConfig<CreateApiMetadataMetadataSchemaBody> = {entityType: {\n      key: 'entityType',\n      label: 'entityType',\n      defaultValue: '',\n      placeholder: 'entityType',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, schema: {\n      key: 'schema',\n      label: 'schema',\n      defaultValue: '',\n      placeholder: 'schema',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/MetadataSchema/services/useCreateApiMetadataMetadataSchema.generated.ts": "import { CreateSchemaRequest } from '@/schemas/createSchemaRequest.generated.tsx'\nimport { createApiMetadataMetadataSchemaResponse } from '@/sections/MetadataSchema/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiMetadataMetadataSchemaFnArgs = {body: CreateSchemaRequest};\nexport const createApiMetadataMetadataSchemaFn = async ({body}: CreateApiMetadataMetadataSchemaFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/metadata/metadataSchema${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiMetadataMetadataSchemaResponse.parse(data)\n    };\nexport const useCreateApiMetadataMetadataSchema = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiMetadataMetadataSchemaFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['MetadataSchema']})\n        }\n      })\n    };",
  "src/sections/Negotiators/tables/NegotiatorsTable.generated.tsx": "import { useGetApiNegotiators } from '@/sections/Negotiators/services/useGetApiNegotiators.generated.ts'\nimport { useState } from 'react'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\nimport { useNavigate } from 'react-router-dom'\n\nexport type UseNegotiatorsTableArgs = {sortBy?: (string) | null | undefined, embed?: (Array<'office'>) | null | undefined, id?: (Array<string>) | null | undefined, officeId?: (Array<string>) | null | undefined, email?: (string) | null | undefined, name?: (string) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, active?: (boolean) | null | undefined, metadata?: (Array<string>) | null | undefined};\nexport const useNegotiatorsTable = (args: UseNegotiatorsTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiNegotiators({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const NegotiatorsTable = () => {\n  \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useNegotiatorsTable({}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Negotiators',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New negotiatorsTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/negotiators/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Negotiators/forms/CreateNegotiators.example.tsx": "import { CreateNegotiatorsForm, fieldNames, CreateNegotiatorsFormFields } from '@/sections/Negotiators/forms/CreateNegotiatorsForm.generated.tsx'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateNegotiators = () => {\n      \n\n      \n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateNegotiatorsForm >\n              <FormLayout>\n                <CreateNegotiatorsFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateNegotiatorsForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Negotiators/forms/CreateNegotiatorsForm.generated.tsx": "import { CreateApiNegotiatorsBody, createApiNegotiatorsBody } from '@/sections/Negotiators/services/apiTypes.generated.ts'\nimport { createNegotiatorsConfig } from '@/sections/Negotiators/config/createNegotiatorsConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiNegotiators } from '@/sections/Negotiators/services/useCreateApiNegotiators.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateNegotiatorsFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiNegotiatorsBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createNegotiatorsConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateNegotiatorsFormProps = {children: ReactNode, defaultValues?: CreateApiNegotiatorsBody, onSuccess?: () => void};\nexport const CreateNegotiatorsForm = (props: CreateNegotiatorsFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiNegotiatorsBody>({\n        resolver: zodResolver(createApiNegotiatorsBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiNegotiators()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiNegotiatorsBody>({name: true, jobTitle: true, active: true, officeId: true, workPhone: true, mobilePhone: true, email: true, diaryNegotiatorIds: true, diaryOfficeIds: true, metadata: true});",
  "src/schemas/createNegotiatorModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateNegotiatorModel = /** Request body used to create a new negotiator */\n{name: /** The name of the negotiator */\nstring, jobTitle?: (/** The job title of the negotiator */\nstring) | null | undefined, active?: (/** A flag determining whether or not the negotiator is active */\nboolean) | null | undefined, officeId: /** The unique identifier of the office that the negotiator is attached to */\nstring, workPhone?: (/** The work phone number of the negotiator */\nstring) | null | undefined, mobilePhone?: (/** The mobile phone number of the negotiator */\nstring) | null | undefined, email?: (/** The email address of the negotiator */\nstring) | null | undefined, diaryNegotiatorIds?: (/** The identifiers of other negotiators whose diaries should be displayed to this negotiator when rendering diary/calendar view components in applicants */\nArray<string>) | null | undefined, diaryOfficeIds?: (/** The identifiers of other offices whose diaries should be displayed to this negotiator when rendering diary/calendar view components in applicants */\nArray<string>) | null | undefined, metadata?: (/** App specific metadata to set against the negotiator */\nRecord<string, Record<string, never>>) | null | undefined};\nexport const createNegotiatorModel = /** Request body used to create a new negotiator */\nz.object({name: /** The name of the negotiator */\nz.string().min(1), jobTitle: /** The job title of the negotiator */\nz.string().optional().nullable(), active: /** A flag determining whether or not the negotiator is active */\nz.boolean().optional().nullable(), officeId: /** The unique identifier of the office that the negotiator is attached to */\nz.string().min(1), workPhone: /** The work phone number of the negotiator */\nz.string().optional().nullable(), mobilePhone: /** The mobile phone number of the negotiator */\nz.string().optional().nullable(), email: /** The email address of the negotiator */\nz.string().optional().nullable(), diaryNegotiatorIds: /** The identifiers of other negotiators whose diaries should be displayed to this negotiator when rendering diary/calendar view components in applicants */\nz.array(z.string().min(1)).optional().nullable(), diaryOfficeIds: /** The identifiers of other offices whose diaries should be displayed to this negotiator when rendering diary/calendar view components in applicants */\nz.array(z.string().min(1)).optional().nullable(), metadata: /** App specific metadata to set against the negotiator */\nz.record(z.string(), z.object({})).optional().nullable()});",
  "src/sections/Negotiators/config/createNegotiatorsConfig.example.tsx": "import { CreateApiNegotiatorsBody } from '@/sections/Negotiators/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { Switch } from '@/inputs/Switch.tsx'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createNegotiatorsConfig: ModelConfig<CreateApiNegotiatorsBody> = {name: {\n      key: 'name',\n      label: 'name',\n      defaultValue: '',\n      placeholder: 'name',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, jobTitle: {\n      key: 'jobTitle',\n      label: 'jobTitle',\n      defaultValue: '',\n      placeholder: 'jobTitle',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, active: {\n      key: 'active',\n      label: 'active',\n      defaultValue: false,\n      placeholder: 'active',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><Switch {...props} /></InputWrap>\n    }, officeId: {\n      key: 'officeId',\n      label: 'officeId',\n      defaultValue: '',\n      placeholder: 'officeId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, workPhone: {\n      key: 'workPhone',\n      label: 'workPhone',\n      defaultValue: '',\n      placeholder: 'workPhone',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, mobilePhone: {\n      key: 'mobilePhone',\n      label: 'mobilePhone',\n      defaultValue: '',\n      placeholder: 'mobilePhone',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, email: {\n      key: 'email',\n      label: 'email',\n      defaultValue: '',\n      placeholder: 'email',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, diaryNegotiatorIds: {\n      key: 'diaryNegotiatorIds',\n      label: 'diaryNegotiatorIds',\n      defaultValue: [],\n      placeholder: 'diaryNegotiatorIds',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, diaryOfficeIds: {\n      key: 'diaryOfficeIds',\n      label: 'diaryOfficeIds',\n      defaultValue: [],\n      placeholder: 'diaryOfficeIds',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, metadata: {\n      key: 'metadata',\n      label: 'metadata',\n      defaultValue: null,\n      placeholder: 'metadata',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/Negotiators/services/useCreateApiNegotiators.generated.ts": "import { CreateNegotiatorModel } from '@/schemas/createNegotiatorModel.generated.tsx'\nimport { createApiNegotiatorsResponse } from '@/sections/Negotiators/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiNegotiatorsFnArgs = {body: CreateNegotiatorModel};\nexport const createApiNegotiatorsFn = async ({body}: CreateApiNegotiatorsFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/negotiators/${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiNegotiatorsResponse.parse(data)\n    };\nexport const useCreateApiNegotiators = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiNegotiatorsFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Negotiators']})\n        }\n      })\n    };",
  "src/sections/Notifications/forms/CreateNotifications.example.tsx": "import { CreateNotificationsForm, fieldNames, CreateNotificationsFormFields } from '@/sections/Notifications/forms/CreateNotificationsForm.generated.tsx'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateNotifications = () => {\n      \n\n      \n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateNotificationsForm >\n              <FormLayout>\n                <CreateNotificationsFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateNotificationsForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Notifications/forms/CreateNotificationsForm.generated.tsx": "import { CreateApiNotificationsBody, createApiNotificationsBody } from '@/sections/Notifications/services/apiTypes.generated.ts'\nimport { createNotificationsConfig } from '@/sections/Notifications/config/createNotificationsConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiNotifications } from '@/sections/Notifications/services/useCreateApiNotifications.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateNotificationsFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiNotificationsBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createNotificationsConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateNotificationsFormProps = {children: ReactNode, defaultValues?: CreateApiNotificationsBody, onSuccess?: () => void};\nexport const CreateNotificationsForm = (props: CreateNotificationsFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiNotificationsBody>({\n        resolver: zodResolver(createApiNotificationsBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiNotifications()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiNotificationsBody>({type: true, subType: true, products: true, targets: true, payload: true});",
  "src/sections/Notifications/services/apiTypes.generated.ts": "import { CreateNotificationModel, createNotificationModel } from '@/schemas/createNotificationModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type CreateApiNotificationsBody = CreateNotificationModel;\nexport const createApiNotificationsBody = createNotificationModel;\nexport const createApiNotificationsResponse = z.void();",
  "src/schemas/createNotificationModel.generated.tsx": "import { CreateNotificationTargetModel, createNotificationTargetModel } from '@/schemas/createNotificationTargetModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type CreateNotificationModel = /** Payload for creating a notification */\n{type?: (/** The notification type (telephony) */\nstring) | null | undefined, subType?: (/** The sub category type (answeredCall/endedCall/incomingCall/missedCall) */\nstring) | null | undefined, products?: (/** The products the notification is associated to, and will be delivered to */\nArray<string>) | null | undefined, targets?: (CreateNotificationTargetModel) | null | undefined, payload?: (/** The payload to deliver to the specified target(s). Note that the payload must match the expected format\r\nbased on the type/subType combination and will be validated accordingly. Please refer to [the documentation](https://foundations-documentation.reapit.cloud/api/notifications)\r\nfor more information */\nRecord<string, never>) | null | undefined};\nexport const createNotificationModel = /** Payload for creating a notification */\nz.object({type: /** The notification type (telephony) */\nz.string().optional().nullable(), subType: /** The sub category type (answeredCall/endedCall/incomingCall/missedCall) */\nz.string().optional().nullable(), products: /** The products the notification is associated to, and will be delivered to */\nz.array(z.string().min(1)).optional().nullable(), targets: createNotificationTargetModel.optional().nullable(), payload: /** The payload to deliver to the specified target(s). Note that the payload must match the expected format\r\nbased on the type/subType combination and will be validated accordingly. Please refer to [the documentation](https://foundations-documentation.reapit.cloud/api/notifications)\r\nfor more information */\nz.object({}).optional().nullable()});",
  "src/schemas/createNotificationTargetModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateNotificationTargetModel = /** Payload for defining notification targets */\n{negotiatorId?: (/** The identifier of the negotiators whom should receive the notification */\nArray<string>) | null | undefined};\nexport const createNotificationTargetModel = /** Payload for defining notification targets */\nz.object({negotiatorId: /** The identifier of the negotiators whom should receive the notification */\nz.array(z.string().min(1)).optional().nullable()});",
  "src/sections/Notifications/config/createNotificationsConfig.example.tsx": "import { CreateApiNotificationsBody } from '@/sections/Notifications/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createNotificationsConfig: ModelConfig<CreateApiNotificationsBody> = {type: {\n      key: 'type',\n      label: 'type',\n      defaultValue: '',\n      placeholder: 'type',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, subType: {\n      key: 'subType',\n      label: 'subType',\n      defaultValue: '',\n      placeholder: 'subType',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, products: {\n      key: 'products',\n      label: 'products',\n      defaultValue: [],\n      placeholder: 'products',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, targets: {\n      key: 'targets',\n      label: 'targets',\n      defaultValue: null,\n      placeholder: 'targets',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, payload: {\n      key: 'payload',\n      label: 'payload',\n      defaultValue: null,\n      placeholder: 'payload',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/Notifications/services/useCreateApiNotifications.generated.ts": "import { CreateNotificationModel } from '@/schemas/createNotificationModel.generated.tsx'\nimport { createApiNotificationsResponse } from '@/sections/Notifications/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiNotificationsFnArgs = {body: CreateNotificationModel};\nexport const createApiNotificationsFn = async ({body}: CreateApiNotificationsFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/notifications/${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiNotificationsResponse.parse(data)\n    };\nexport const useCreateApiNotifications = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiNotificationsFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Notifications']})\n        }\n      })\n    };",
  "src/sections/Offers/tables/OffersTable.generated.tsx": "import { useGetApiOffers } from '@/sections/Offers/services/useGetApiOffers.generated.ts'\nimport { useState } from 'react'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\nimport { useNavigate } from 'react-router-dom'\n\nexport type UseOffersTableArgs = {sortBy?: (string) | null | undefined, embed?: (Array<'applicant' | 'conveyancing' | 'property' | 'negotiator'>) | null | undefined, id?: (Array<string>) | null | undefined, applicantId?: (Array<string>) | null | undefined, propertyId?: (Array<string>) | null | undefined, status?: (Array<'pending' | 'withdrawn' | 'rejected' | 'accepted' | 'noteOfInterest' | 'noteOfInterestWithdrawn'>) | null | undefined, address?: (string) | null | undefined, name?: (string) | null | undefined, amountFrom?: (number) | null | undefined, amountTo?: (number) | null | undefined, dateFrom?: (Date) | null | undefined, dateTo?: (Date) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, metadata?: (Array<string>) | null | undefined};\nexport const useOffersTable = (args: UseOffersTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiOffers({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const OffersTable = () => {\n  \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useOffersTable({}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Offers',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New offersTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/offers/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Offers/services/useGetApiOffers.generated.ts": "import { getApiOffersResponse } from '@/sections/Offers/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiOffersFnArgs = {pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, sortBy?: (string) | null | undefined, embed?: (Array<'applicant' | 'conveyancing' | 'property' | 'negotiator'>) | null | undefined, id?: (Array<string>) | null | undefined, applicantId?: (Array<string>) | null | undefined, propertyId?: (Array<string>) | null | undefined, status?: (Array<'pending' | 'withdrawn' | 'rejected' | 'accepted' | 'noteOfInterest' | 'noteOfInterestWithdrawn'>) | null | undefined, address?: (string) | null | undefined, name?: (string) | null | undefined, amountFrom?: (number) | null | undefined, amountTo?: (number) | null | undefined, dateFrom?: (Date) | null | undefined, dateTo?: (Date) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, metadata?: (Array<string>) | null | undefined};\nexport const getApiOffersFn = async ({pageSize, pageNumber, sortBy, embed, id, applicantId, propertyId, status, address, name, amountFrom, amountTo, dateFrom, dateTo, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata}: GetApiOffersFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/offers/${querySerialiser({args:{pageSize, pageNumber, sortBy, embed, id, applicantId, propertyId, status, address, name, amountFrom, amountTo, dateFrom, dateTo, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiOffersResponse.parse(data)\n    };\nexport const useGetApiOffers = ({pageSize, pageNumber, sortBy, embed, id, applicantId, propertyId, status, address, name, amountFrom, amountTo, dateFrom, dateTo, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata}: GetApiOffersFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Offers', pageSize, pageNumber, sortBy, embed, id, applicantId, propertyId, status, address, name, amountFrom, amountTo, dateFrom, dateTo, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata],\n        queryFn: () => getApiOffersFn({pageSize, pageNumber, sortBy, embed, id, applicantId, propertyId, status, address, name, amountFrom, amountTo, dateFrom, dateTo, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Offers/services/apiTypes.generated.ts": "import { offerModelPagedResult } from '@/schemas/offerModelPagedResult.generated.tsx'\nimport { CreateOfferModel, createOfferModel } from '@/schemas/createOfferModel.generated.tsx'\nimport { z } from 'zod'\nimport { offerModel } from '@/schemas/offerModel.generated.tsx'\n\nexport const getApiOffersResponse = offerModelPagedResult;\nexport type CreateApiOffersBody = CreateOfferModel;\nexport const createApiOffersBody = createOfferModel;\nexport const createApiOffersResponse = z.void();\nexport const getApiOffersIdResponse = offerModel;\nexport const patchApiOffersIdResponse = z.void();",
  "src/schemas/offerModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { offerModel, OfferModel } from '@/schemas/offerModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const offerModelPagedResult = z.object({_embedded: z.array(offerModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type OfferModelPagedResult = {_embedded?: (Array<OfferModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/offerModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\nimport { offerContactModel, OfferContactModel } from '@/schemas/offerContactModel.generated.tsx'\n\nexport const offerModel = /** Representation of an offer */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the offer */\nz.string().optional().nullable(), created: /** The the date and time when the offer was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the offer was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), currency: /** The currency that applies to monetary amounts exposed in the model */\nz.string().optional().nullable(), applicantId: /** The unique identifier of the applicant associated to the offer */\nz.string().optional().nullable(), companyId: /** The unique identifier of the company associated to the offer */\nz.string().optional().nullable(), contactId: /** The unique identifier of the contact associated to the offer */\nz.string().optional().nullable(), propertyId: /** The unique identifier of the property associated to the offer */\nz.string().optional().nullable(), negotiatorId: /** The unique identifier of the negotiator associated to the offer */\nz.string().optional().nullable(), date: /** The date when the offer was made */\nz.string().optional().nullable(), amount: /** The monetary amount of the offer */\nz.number().optional().nullable(), status: /** The current status of the offer (pending/withdrawn/rejected/accepted/noteOfInterest) */\nz.string().optional().nullable(), inclusions: /** A free text field describing items that should be included in the sale */\nz.string().optional().nullable(), exclusions: /** A free text field describing items that are explicitly excluded from the sale */\nz.string().optional().nullable(), conditions: /** A free text field describing any other conditions set by either party that relate to the sale */\nz.string().optional().nullable(), related: /** A collection of contacts associated to the offer */\nz.array(offerContactModel).optional().nullable(), metadata: /** App specific metadata that has been set against the offer */\nz.record(z.string(), z.object({})).optional().nullable(), _eTag: /** The ETag for the current version of the offer. Used for managing update concurrency */\nz.string().optional().nullable()});\nexport type OfferModel = /** Representation of an offer */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the offer */\nstring) | null | undefined, created?: (/** The the date and time when the offer was created */\nDate) | null | undefined, modified?: (/** The date and time when the offer was last modified */\nDate) | null | undefined, currency?: (/** The currency that applies to monetary amounts exposed in the model */\nstring) | null | undefined, applicantId?: (/** The unique identifier of the applicant associated to the offer */\nstring) | null | undefined, companyId?: (/** The unique identifier of the company associated to the offer */\nstring) | null | undefined, contactId?: (/** The unique identifier of the contact associated to the offer */\nstring) | null | undefined, propertyId?: (/** The unique identifier of the property associated to the offer */\nstring) | null | undefined, negotiatorId?: (/** The unique identifier of the negotiator associated to the offer */\nstring) | null | undefined, date?: (/** The date when the offer was made */\nstring) | null | undefined, amount?: (/** The monetary amount of the offer */\nnumber) | null | undefined, status?: (/** The current status of the offer (pending/withdrawn/rejected/accepted/noteOfInterest) */\nstring) | null | undefined, inclusions?: (/** A free text field describing items that should be included in the sale */\nstring) | null | undefined, exclusions?: (/** A free text field describing items that are explicitly excluded from the sale */\nstring) | null | undefined, conditions?: (/** A free text field describing any other conditions set by either party that relate to the sale */\nstring) | null | undefined, related?: (/** A collection of contacts associated to the offer */\nArray<OfferContactModel>) | null | undefined, metadata?: (/** App specific metadata that has been set against the offer */\nRecord<string, Record<string, never>>) | null | undefined, _eTag?: (/** The ETag for the current version of the offer. Used for managing update concurrency */\nstring) | null | undefined};",
  "src/schemas/offerContactModel.generated.tsx": "import { z } from 'zod'\nimport { offerContactAddressModel, OfferContactAddressModel } from '@/schemas/offerContactAddressModel.generated.tsx'\nimport { additionalContactDetailModel, AdditionalContactDetailModel } from '@/schemas/additionalContactDetailModel.generated.tsx'\n\nexport const offerContactModel = /** A summarised view of the details of a contact associated to an offer */\nz.object({id: /** The unique identifier of the contact */\nz.string().optional().nullable(), name: /** The complete name of the contact or company */\nz.string().optional().nullable(), title: /** The title of the contact (Available when 'type' is 'contact') */\nz.string().optional().nullable(), forename: /** The forename of the contact (Available when 'type' is 'contact') */\nz.string().optional().nullable(), surname: /** The surname of the contact (Available when 'type' is 'contact') */\nz.string().optional().nullable(), dateOfBirth: /** The date of birth of the contact (Available when 'type' is 'contact') */\nz.string().optional().nullable(), type: /** The type of the contact (contact/company) */\nz.string().optional().nullable(), homePhone: /** The home phone number of the contact */\nz.string().optional().nullable(), workPhone: /** The work phone number of the contact */\nz.string().optional().nullable(), mobilePhone: /** The mobile phone number of the contact */\nz.string().optional().nullable(), email: /** The email address of the contact */\nz.string().optional().nullable(), marketingConsent: /** The marketing consent status of the contact (grant/deny/notAsked/unknown) */\nz.string().optional().nullable(), primaryAddress: offerContactAddressModel.optional().nullable(), additionalContactDetails: /** A collection of additional contact details */\nz.array(additionalContactDetailModel).optional().nullable()});\nexport type OfferContactModel = /** A summarised view of the details of a contact associated to an offer */\n{id?: (/** The unique identifier of the contact */\nstring) | null | undefined, name?: (/** The complete name of the contact or company */\nstring) | null | undefined, title?: (/** The title of the contact (Available when 'type' is 'contact') */\nstring) | null | undefined, forename?: (/** The forename of the contact (Available when 'type' is 'contact') */\nstring) | null | undefined, surname?: (/** The surname of the contact (Available when 'type' is 'contact') */\nstring) | null | undefined, dateOfBirth?: (/** The date of birth of the contact (Available when 'type' is 'contact') */\nstring) | null | undefined, type?: (/** The type of the contact (contact/company) */\nstring) | null | undefined, homePhone?: (/** The home phone number of the contact */\nstring) | null | undefined, workPhone?: (/** The work phone number of the contact */\nstring) | null | undefined, mobilePhone?: (/** The mobile phone number of the contact */\nstring) | null | undefined, email?: (/** The email address of the contact */\nstring) | null | undefined, marketingConsent?: (/** The marketing consent status of the contact (grant/deny/notAsked/unknown) */\nstring) | null | undefined, primaryAddress?: (OfferContactAddressModel) | null | undefined, additionalContactDetails?: (/** A collection of additional contact details */\nArray<AdditionalContactDetailModel>) | null | undefined};",
  "src/schemas/offerContactAddressModel.generated.tsx": "import { z } from 'zod'\n\nexport const offerContactAddressModel = /** Representation of the physical address of a building or premise */\nz.object({buildingName: /** The building name */\nz.string().optional().nullable(), buildingNumber: /** The building number */\nz.string().optional().nullable(), line1: /** The first line of the address */\nz.string().optional().nullable(), line2: /** The second line of the address */\nz.string().optional().nullable(), line3: /** The third line of the address */\nz.string().optional().nullable(), line4: /** The fourth line of the address */\nz.string().optional().nullable(), postcode: /** The postcode */\nz.string().optional().nullable(), countryId: /** The ISO-3166 country code that the address resides in */\nz.string().optional().nullable()});\nexport type OfferContactAddressModel = /** Representation of the physical address of a building or premise */\n{buildingName?: (/** The building name */\nstring) | null | undefined, buildingNumber?: (/** The building number */\nstring) | null | undefined, line1?: (/** The first line of the address */\nstring) | null | undefined, line2?: (/** The second line of the address */\nstring) | null | undefined, line3?: (/** The third line of the address */\nstring) | null | undefined, line4?: (/** The fourth line of the address */\nstring) | null | undefined, postcode?: (/** The postcode */\nstring) | null | undefined, countryId?: (/** The ISO-3166 country code that the address resides in */\nstring) | null | undefined};",
  "src/sections/Offers/forms/CreateOffers.example.tsx": "import { CreateOffersForm, fieldNames, CreateOffersFormFields } from '@/sections/Offers/forms/CreateOffersForm.generated.tsx'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateOffers = () => {\n      \n\n      \n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateOffersForm >\n              <FormLayout>\n                <CreateOffersFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateOffersForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Offers/forms/CreateOffersForm.generated.tsx": "import { CreateApiOffersBody, createApiOffersBody } from '@/sections/Offers/services/apiTypes.generated.ts'\nimport { createOffersConfig } from '@/sections/Offers/config/createOffersConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiOffers } from '@/sections/Offers/services/useCreateApiOffers.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateOffersFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiOffersBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createOffersConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateOffersFormProps = {children: ReactNode, defaultValues?: CreateApiOffersBody, onSuccess?: () => void};\nexport const CreateOffersForm = (props: CreateOffersFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiOffersBody>({\n        resolver: zodResolver(createApiOffersBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiOffers()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiOffersBody>({applicantId: true, propertyId: true, negotiatorId: true, date: true, amount: true, status: true, inclusions: true, exclusions: true, conditions: true, metadata: true});",
  "src/schemas/createOfferModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateOfferModel = /** Request body used to create a new offer */\n{applicantId: /** The unique identifier of the applicant associated to the offer */\nstring, propertyId: /** The unique identifier of the property associated to the offer */\nstring, negotiatorId?: (/** The unique identifier of the negotiator associated to the offer */\nstring) | null | undefined, date: /** The date when the offer was made */\nstring, amount: /** The monetary amount of the offer */\nnumber, status: /** The current status of the offer (pending/withdrawn/rejected/accepted/noteOfInterest) */\nstring, inclusions?: (/** A free text field describing items that should be included in the sale */\nstring) | null | undefined, exclusions?: (/** A free text field describing items that are explicitly excluded from the sale */\nstring) | null | undefined, conditions?: (/** A free text field describing any other conditions set by either party that relate to the sale */\nstring) | null | undefined, metadata?: (/** App specific metadata to set against the offer */\nRecord<string, Record<string, never>>) | null | undefined};\nexport const createOfferModel = /** Request body used to create a new offer */\nz.object({applicantId: /** The unique identifier of the applicant associated to the offer */\nz.string().min(1), propertyId: /** The unique identifier of the property associated to the offer */\nz.string().min(1), negotiatorId: /** The unique identifier of the negotiator associated to the offer */\nz.string().optional().nullable(), date: /** The date when the offer was made */\nz.string().min(1), amount: /** The monetary amount of the offer */\nz.number(), status: /** The current status of the offer (pending/withdrawn/rejected/accepted/noteOfInterest) */\nz.string().min(1), inclusions: /** A free text field describing items that should be included in the sale */\nz.string().optional().nullable(), exclusions: /** A free text field describing items that are explicitly excluded from the sale */\nz.string().optional().nullable(), conditions: /** A free text field describing any other conditions set by either party that relate to the sale */\nz.string().optional().nullable(), metadata: /** App specific metadata to set against the offer */\nz.record(z.string(), z.object({})).optional().nullable()});",
  "src/sections/Offers/config/createOffersConfig.example.tsx": "import { CreateApiOffersBody } from '@/sections/Offers/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { DateInput } from '@/inputs/DateInput.tsx'\nimport { NumberInput } from '@/inputs/NumberInput.tsx'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createOffersConfig: ModelConfig<CreateApiOffersBody> = {applicantId: {\n      key: 'applicantId',\n      label: 'applicantId',\n      defaultValue: '',\n      placeholder: 'applicantId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, propertyId: {\n      key: 'propertyId',\n      label: 'propertyId',\n      defaultValue: '',\n      placeholder: 'propertyId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, negotiatorId: {\n      key: 'negotiatorId',\n      label: 'negotiatorId',\n      defaultValue: '',\n      placeholder: 'negotiatorId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, date: {\n      key: 'date',\n      label: 'date',\n      defaultValue: null,\n      placeholder: 'date',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><DateInput {...props} /></InputWrap>\n    }, amount: {\n      key: 'amount',\n      label: 'amount',\n      defaultValue: null,\n      placeholder: 'amount',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><NumberInput {...props} /></InputWrap>\n    }, status: {\n      key: 'status',\n      label: 'status',\n      defaultValue: '',\n      placeholder: 'status',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, inclusions: {\n      key: 'inclusions',\n      label: 'inclusions',\n      defaultValue: '',\n      placeholder: 'inclusions',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, exclusions: {\n      key: 'exclusions',\n      label: 'exclusions',\n      defaultValue: '',\n      placeholder: 'exclusions',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, conditions: {\n      key: 'conditions',\n      label: 'conditions',\n      defaultValue: '',\n      placeholder: 'conditions',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, metadata: {\n      key: 'metadata',\n      label: 'metadata',\n      defaultValue: null,\n      placeholder: 'metadata',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/Offers/services/useCreateApiOffers.generated.ts": "import { CreateOfferModel } from '@/schemas/createOfferModel.generated.tsx'\nimport { createApiOffersResponse } from '@/sections/Offers/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiOffersFnArgs = {body: CreateOfferModel};\nexport const createApiOffersFn = async ({body}: CreateApiOffersFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/offers/${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiOffersResponse.parse(data)\n    };\nexport const useCreateApiOffers = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiOffersFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Offers']})\n        }\n      })\n    };",
  "src/sections/Offices/tables/OfficesTable.generated.tsx": "import { useGetApiOffices } from '@/sections/Offices/services/useGetApiOffices.generated.ts'\nimport { useState } from 'react'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\nimport { useNavigate } from 'react-router-dom'\n\nexport type UseOfficesTableArgs = {sortBy?: (string) | null | undefined, embed?: (Array<'negotiators'>) | null | undefined, id?: (Array<string>) | null | undefined, address?: (string) | null | undefined, name?: (string) | null | undefined, region?: (string) | null | undefined, active?: (boolean) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, metadata?: (Array<string>) | null | undefined, extrasField?: (Array<string>) | null | undefined};\nexport const useOfficesTable = (args: UseOfficesTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiOffices({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const OfficesTable = () => {\n  \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useOfficesTable({}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Offices',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New officesTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/offices/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Offices/forms/CreateOffices.example.tsx": "import { CreateOfficesForm, fieldNames, CreateOfficesFormFields } from '@/sections/Offices/forms/CreateOfficesForm.generated.tsx'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateOffices = () => {\n      \n\n      \n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateOfficesForm >\n              <FormLayout>\n                <CreateOfficesFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateOfficesForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Offices/forms/CreateOfficesForm.generated.tsx": "import { CreateApiOfficesBody, createApiOfficesBody } from '@/sections/Offices/services/apiTypes.generated.ts'\nimport { createOfficesConfig } from '@/sections/Offices/config/createOfficesConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiOffices } from '@/sections/Offices/services/useCreateApiOffices.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateOfficesFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiOfficesBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createOfficesConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateOfficesFormProps = {children: ReactNode, defaultValues?: CreateApiOfficesBody, onSuccess?: () => void};\nexport const CreateOfficesForm = (props: CreateOfficesFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiOfficesBody>({\n        resolver: zodResolver(createApiOfficesBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiOffices()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiOfficesBody>({name: true, active: true, manager: true, address: true, workPhone: true, email: true, metadata: true});",
  "src/schemas/createOfficeModel.generated.tsx": "import { CreateOfficeAddressModel, createOfficeAddressModel } from '@/schemas/createOfficeAddressModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type CreateOfficeModel = /** Request body used to create a new office */\n{name: /** The name of the office */\nstring, active?: (/** A flag denoting whether or not this office is active */\nboolean) | null | undefined, manager?: (/** The name of the office manager */\nstring) | null | undefined, address: CreateOfficeAddressModel, workPhone?: (/** The work phone number of the office */\nstring) | null | undefined, email?: (/** The email address of the office */\nstring) | null | undefined, metadata?: (/** App specific metadata to set against the office */\nRecord<string, Record<string, never>>) | null | undefined};\nexport const createOfficeModel = /** Request body used to create a new office */\nz.object({name: /** The name of the office */\nz.string().min(1), active: /** A flag denoting whether or not this office is active */\nz.boolean().optional().nullable(), manager: /** The name of the office manager */\nz.string().optional().nullable(), address: createOfficeAddressModel, workPhone: /** The work phone number of the office */\nz.string().optional().nullable(), email: /** The email address of the office */\nz.string().optional().nullable(), metadata: /** App specific metadata to set against the office */\nz.record(z.string(), z.object({})).optional().nullable()});",
  "src/schemas/createOfficeAddressModel.generated.tsx": "import { CreateOfficeAddressGeolocationModel, createOfficeAddressGeolocationModel } from '@/schemas/createOfficeAddressGeolocationModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type CreateOfficeAddressModel = /** Request body used to set the address of a new office */\n{buildingName?: (/** The building name */\nstring) | null | undefined, buildingNumber?: (/** The building number */\nstring) | null | undefined, line1: /** The first line of the address */\nstring, line2?: (/** The second line of the address */\nstring) | null | undefined, line3?: (/** The third line of the address */\nstring) | null | undefined, line4?: (/** The fourth line of the address */\nstring) | null | undefined, postcode?: (/** The postcode */\nstring) | null | undefined, countryId?: (/** The ISO-3166 country code that the address resides within */\nstring) | null | undefined, geolocation?: (CreateOfficeAddressGeolocationModel) | null | undefined};\nexport const createOfficeAddressModel = /** Request body used to set the address of a new office */\nz.object({buildingName: /** The building name */\nz.string().optional().nullable(), buildingNumber: /** The building number */\nz.string().optional().nullable(), line1: /** The first line of the address */\nz.string().min(1), line2: /** The second line of the address */\nz.string().optional().nullable(), line3: /** The third line of the address */\nz.string().optional().nullable(), line4: /** The fourth line of the address */\nz.string().optional().nullable(), postcode: /** The postcode */\nz.string().optional().nullable(), countryId: /** The ISO-3166 country code that the address resides within */\nz.string().optional().nullable(), geolocation: createOfficeAddressGeolocationModel.optional().nullable()});",
  "src/schemas/createOfficeAddressGeolocationModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateOfficeAddressGeolocationModel = /** Request body used to set the geolocation coordinates of a new address */\n{latitude?: (/** The latitude coordinate of the coordinate pair */\nnumber) | null | undefined, longitude?: (/** The longitude coordinate of the coordinate pair */\nnumber) | null | undefined};\nexport const createOfficeAddressGeolocationModel = /** Request body used to set the geolocation coordinates of a new address */\nz.object({latitude: /** The latitude coordinate of the coordinate pair */\nz.number().optional().nullable(), longitude: /** The longitude coordinate of the coordinate pair */\nz.number().optional().nullable()});",
  "src/sections/Offices/config/createOfficesConfig.example.tsx": "import { CreateApiOfficesBody } from '@/sections/Offices/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { Switch } from '@/inputs/Switch.tsx'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createOfficesConfig: ModelConfig<CreateApiOfficesBody> = {name: {\n      key: 'name',\n      label: 'name',\n      defaultValue: '',\n      placeholder: 'name',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, active: {\n      key: 'active',\n      label: 'active',\n      defaultValue: false,\n      placeholder: 'active',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><Switch {...props} /></InputWrap>\n    }, manager: {\n      key: 'manager',\n      label: 'manager',\n      defaultValue: '',\n      placeholder: 'manager',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, address: {\n      key: 'address',\n      label: 'address',\n      defaultValue: null,\n      placeholder: 'address',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, workPhone: {\n      key: 'workPhone',\n      label: 'workPhone',\n      defaultValue: '',\n      placeholder: 'workPhone',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, email: {\n      key: 'email',\n      label: 'email',\n      defaultValue: '',\n      placeholder: 'email',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, metadata: {\n      key: 'metadata',\n      label: 'metadata',\n      defaultValue: null,\n      placeholder: 'metadata',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/Offices/services/useCreateApiOffices.generated.ts": "import { CreateOfficeModel } from '@/schemas/createOfficeModel.generated.tsx'\nimport { createApiOfficesResponse } from '@/sections/Offices/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiOfficesFnArgs = {body: CreateOfficeModel};\nexport const createApiOfficesFn = async ({body}: CreateApiOfficesFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/offices/${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiOfficesResponse.parse(data)\n    };\nexport const useCreateApiOffices = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiOfficesFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Offices']})\n        }\n      })\n    };",
  "src/sections/Properties/tables/PropertiesTable.generated.tsx": "import { useGetApiProperties } from '@/sections/Properties/services/useGetApiProperties.generated.ts'\nimport { useState } from 'react'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\nimport { useNavigate } from 'react-router-dom'\n\nexport type UsePropertiesTableArgs = {sortBy?: (string) | null | undefined, embed?: (Array<'appointments' | 'area' | 'certificates' | 'department' | 'documents' | 'images' | 'keys' | 'landlord' | 'negotiator' | 'offers' | 'offices' | 'tenancies' | 'vendor'>) | null | undefined, id?: (Array<string>) | null | undefined, age?: (Array<'period' | 'new' | 'modern' | 'old'>) | null | undefined, agentRole?: (Array<'managed' | 'rentCollection' | 'collectFirstPayment' | 'collectRentToDate' | 'lettingOnly' | 'introducingTenant'>) | null | undefined, areaId?: (Array<string>) | null | undefined, excludeAreaId?: (Array<string>) | null | undefined, landlordId?: (Array<string>) | null | undefined, lettingStatus?: (Array<'valuation' | 'toLet' | 'toLetUnavailable' | 'underOffer' | 'underOfferUnavailable' | 'arrangingTenancyUnavailable' | 'arrangingTenancy' | 'tenancyCurrentUnavailable' | 'tenancyCurrent' | 'tenancyFinished' | 'tenancyCancelled' | 'sold' | 'letByOtherAgent' | 'letPrivately' | 'provisional' | 'withdrawn'>) | null | undefined, locality?: (Array<'rural' | 'village' | 'townCity'>) | null | undefined, marketingMode?: (Array<'selling' | 'letting' | 'sellingAndLetting'>) | null | undefined, masterId?: (Array<string>) | null | undefined, negotiatorId?: (Array<string>) | null | undefined, officeId?: (Array<string>) | null | undefined, parking?: (Array<'residents' | 'offStreet' | 'secure' | 'underground' | 'garage' | 'doubleGarage' | 'tripleGarage' | 'carport'>) | null | undefined, sellingStatus?: (Array<'preAppraisal' | 'valuation' | 'paidValuation' | 'forSale' | 'forSaleUnavailable' | 'underOffer' | 'underOfferUnavailable' | 'reserved' | 'exchanged' | 'completed' | 'soldExternally' | 'withdrawn'>) | null | undefined, situation?: (Array<'garden' | 'land' | 'patio' | 'roofTerrace' | 'conservatory' | 'balcony' | 'communalGardens' | 'outsideSpace'>) | null | undefined, style?: (Array<'terraced' | 'endTerrace' | 'detached' | 'semiDetached' | 'linkDetached' | 'mews' | 'basement' | 'lowerGroundFloor' | 'groundFloor' | 'firstFloor' | 'upperFloor' | 'upperFloorWithLift' | 'penthouse' | 'duplex'>) | null | undefined, type?: (Array<'house' | 'bungalow' | 'flatApartment' | 'maisonette' | 'land' | 'farm' | 'cottage' | 'studio' | 'townhouse' | 'developmentPlot'>) | null | undefined, market?: (Array<'local' | 'openA' | 'openB' | 'openC' | 'openD'>) | null | undefined, address?: (string) | null | undefined, countryId?: (string) | null | undefined, departmentId?: (string) | null | undefined, bedroomsFrom?: (number) | null | undefined, bedroomsTo?: (number) | null | undefined, priceFrom?: (number) | null | undefined, priceTo?: (number) | null | undefined, priceFiltersCurrency?: (string) | null | undefined, rentFrom?: (number) | null | undefined, rentTo?: (number) | null | undefined, rentFrequency?: (Array<'weekly' | 'monthly' | 'annually'>) | null | undefined, internetAdvertising?: (boolean) | null | undefined, isExternal?: (boolean) | null | undefined, fromArchive?: (boolean) | null | undefined, availableFrom?: (Date) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, metadata?: (Array<string>) | null | undefined, extrasField?: (Array<string>) | null | undefined};\nexport const usePropertiesTable = (args: UsePropertiesTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiProperties({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const PropertiesTable = () => {\n  \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = usePropertiesTable({}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Properties',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New propertiesTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/properties/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Properties/services/useGetApiProperties.generated.ts": "import { getApiPropertiesResponse } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiPropertiesFnArgs = {pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, sortBy?: (string) | null | undefined, embed?: (Array<'appointments' | 'area' | 'certificates' | 'department' | 'documents' | 'images' | 'keys' | 'landlord' | 'negotiator' | 'offers' | 'offices' | 'tenancies' | 'vendor'>) | null | undefined, id?: (Array<string>) | null | undefined, age?: (Array<'period' | 'new' | 'modern' | 'old'>) | null | undefined, agentRole?: (Array<'managed' | 'rentCollection' | 'collectFirstPayment' | 'collectRentToDate' | 'lettingOnly' | 'introducingTenant'>) | null | undefined, areaId?: (Array<string>) | null | undefined, excludeAreaId?: (Array<string>) | null | undefined, landlordId?: (Array<string>) | null | undefined, lettingStatus?: (Array<'valuation' | 'toLet' | 'toLetUnavailable' | 'underOffer' | 'underOfferUnavailable' | 'arrangingTenancyUnavailable' | 'arrangingTenancy' | 'tenancyCurrentUnavailable' | 'tenancyCurrent' | 'tenancyFinished' | 'tenancyCancelled' | 'sold' | 'letByOtherAgent' | 'letPrivately' | 'provisional' | 'withdrawn'>) | null | undefined, locality?: (Array<'rural' | 'village' | 'townCity'>) | null | undefined, marketingMode?: (Array<'selling' | 'letting' | 'sellingAndLetting'>) | null | undefined, masterId?: (Array<string>) | null | undefined, negotiatorId?: (Array<string>) | null | undefined, officeId?: (Array<string>) | null | undefined, parking?: (Array<'residents' | 'offStreet' | 'secure' | 'underground' | 'garage' | 'doubleGarage' | 'tripleGarage' | 'carport'>) | null | undefined, sellingStatus?: (Array<'preAppraisal' | 'valuation' | 'paidValuation' | 'forSale' | 'forSaleUnavailable' | 'underOffer' | 'underOfferUnavailable' | 'reserved' | 'exchanged' | 'completed' | 'soldExternally' | 'withdrawn'>) | null | undefined, situation?: (Array<'garden' | 'land' | 'patio' | 'roofTerrace' | 'conservatory' | 'balcony' | 'communalGardens' | 'outsideSpace'>) | null | undefined, style?: (Array<'terraced' | 'endTerrace' | 'detached' | 'semiDetached' | 'linkDetached' | 'mews' | 'basement' | 'lowerGroundFloor' | 'groundFloor' | 'firstFloor' | 'upperFloor' | 'upperFloorWithLift' | 'penthouse' | 'duplex'>) | null | undefined, type?: (Array<'house' | 'bungalow' | 'flatApartment' | 'maisonette' | 'land' | 'farm' | 'cottage' | 'studio' | 'townhouse' | 'developmentPlot'>) | null | undefined, market?: (Array<'local' | 'openA' | 'openB' | 'openC' | 'openD'>) | null | undefined, address?: (string) | null | undefined, countryId?: (string) | null | undefined, departmentId?: (string) | null | undefined, bedroomsFrom?: (number) | null | undefined, bedroomsTo?: (number) | null | undefined, priceFrom?: (number) | null | undefined, priceTo?: (number) | null | undefined, priceFiltersCurrency?: (string) | null | undefined, rentFrom?: (number) | null | undefined, rentTo?: (number) | null | undefined, rentFrequency?: (Array<'weekly' | 'monthly' | 'annually'>) | null | undefined, internetAdvertising?: (boolean) | null | undefined, isExternal?: (boolean) | null | undefined, fromArchive?: (boolean) | null | undefined, availableFrom?: (Date) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, metadata?: (Array<string>) | null | undefined, extrasField?: (Array<string>) | null | undefined};\nexport const getApiPropertiesFn = async ({pageSize, pageNumber, sortBy, embed, id, age, agentRole, areaId, excludeAreaId, landlordId, lettingStatus, locality, marketingMode, masterId, negotiatorId, officeId, parking, sellingStatus, situation, style, type, market, address, countryId, departmentId, bedroomsFrom, bedroomsTo, priceFrom, priceTo, priceFiltersCurrency, rentFrom, rentTo, rentFrequency, internetAdvertising, isExternal, fromArchive, availableFrom, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata, extrasField}: GetApiPropertiesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/properties/${querySerialiser({args:{pageSize, pageNumber, sortBy, embed, id, age, agentRole, areaId, excludeAreaId, landlordId, lettingStatus, locality, marketingMode, masterId, negotiatorId, officeId, parking, sellingStatus, situation, style, type, market, address, countryId, departmentId, bedroomsFrom, bedroomsTo, priceFrom, priceTo, priceFiltersCurrency, rentFrom, rentTo, rentFrequency, internetAdvertising, isExternal, fromArchive, availableFrom, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata, extrasField}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiPropertiesResponse.parse(data)\n    };\nexport const useGetApiProperties = ({pageSize, pageNumber, sortBy, embed, id, age, agentRole, areaId, excludeAreaId, landlordId, lettingStatus, locality, marketingMode, masterId, negotiatorId, officeId, parking, sellingStatus, situation, style, type, market, address, countryId, departmentId, bedroomsFrom, bedroomsTo, priceFrom, priceTo, priceFiltersCurrency, rentFrom, rentTo, rentFrequency, internetAdvertising, isExternal, fromArchive, availableFrom, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata, extrasField}: GetApiPropertiesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Properties', pageSize, pageNumber, sortBy, embed, id, age, agentRole, areaId, excludeAreaId, landlordId, lettingStatus, locality, marketingMode, masterId, negotiatorId, officeId, parking, sellingStatus, situation, style, type, market, address, countryId, departmentId, bedroomsFrom, bedroomsTo, priceFrom, priceTo, priceFiltersCurrency, rentFrom, rentTo, rentFrequency, internetAdvertising, isExternal, fromArchive, availableFrom, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata, extrasField],\n        queryFn: () => getApiPropertiesFn({pageSize, pageNumber, sortBy, embed, id, age, agentRole, areaId, excludeAreaId, landlordId, lettingStatus, locality, marketingMode, masterId, negotiatorId, officeId, parking, sellingStatus, situation, style, type, market, address, countryId, departmentId, bedroomsFrom, bedroomsTo, priceFrom, priceTo, priceFiltersCurrency, rentFrom, rentTo, rentFrequency, internetAdvertising, isExternal, fromArchive, availableFrom, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata, extrasField}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Properties/services/apiTypes.generated.ts": "import { propertyModelPagedResult } from '@/schemas/propertyModelPagedResult.generated.tsx'\nimport { CreatePropertyModel, createPropertyModel } from '@/schemas/createPropertyModel.generated.tsx'\nimport { z } from 'zod'\nimport { certificateModelPagedResult } from '@/schemas/certificateModelPagedResult.generated.tsx'\nimport { CreateCertificateModel, createCertificateModel } from '@/schemas/createCertificateModel.generated.tsx'\nimport { keysModelPagedResult } from '@/schemas/keysModelPagedResult.generated.tsx'\nimport { CreateKeyModel, createKeyModel } from '@/schemas/createKeyModel.generated.tsx'\nimport { keyMovementModelPagedResult } from '@/schemas/keyMovementModelPagedResult.generated.tsx'\nimport { CreateKeyMovementModel, createKeyMovementModel } from '@/schemas/createKeyMovementModel.generated.tsx'\nimport { propertyCheckModelPagedResult } from '@/schemas/propertyCheckModelPagedResult.generated.tsx'\nimport { CreatePropertyCheckModel, createPropertyCheckModel } from '@/schemas/createPropertyCheckModel.generated.tsx'\nimport { propertyAppraisalModelPagedResult } from '@/schemas/propertyAppraisalModelPagedResult.generated.tsx'\nimport { CreatePropertyAppraisalModel, createPropertyAppraisalModel } from '@/schemas/createPropertyAppraisalModel.generated.tsx'\nimport { propertyModel } from '@/schemas/propertyModel.generated.tsx'\nimport { certificateModel } from '@/schemas/certificateModel.generated.tsx'\nimport { propertyCertificateResponsibilitiesModel } from '@/schemas/propertyCertificateResponsibilitiesModel.generated.tsx'\nimport { keysModel } from '@/schemas/keysModel.generated.tsx'\nimport { keyMovementModel } from '@/schemas/keyMovementModel.generated.tsx'\nimport { propertyCheckModel } from '@/schemas/propertyCheckModel.generated.tsx'\nimport { propertyAppraisalModel } from '@/schemas/propertyAppraisalModel.generated.tsx'\n\nexport const getApiPropertiesResponse = propertyModelPagedResult;\nexport type CreateApiPropertiesBody = CreatePropertyModel;\nexport const createApiPropertiesBody = createPropertyModel;\nexport const createApiPropertiesResponse = z.void();\nexport const getApiPropertiesIdCertificatesResponse = certificateModelPagedResult;\nexport type CreateApiPropertiesIdCertificatesBody = CreateCertificateModel;\nexport const createApiPropertiesIdCertificatesBody = createCertificateModel;\nexport const createApiPropertiesIdCertificatesResponse = z.void();\nexport const getApiPropertiesIdKeysResponse = keysModelPagedResult;\nexport type CreateApiPropertiesIdKeysBody = CreateKeyModel;\nexport const createApiPropertiesIdKeysBody = createKeyModel;\nexport const createApiPropertiesIdKeysResponse = z.void();\nexport const getApiPropertiesIdKeysKeyIdMovementsResponse = keyMovementModelPagedResult;\nexport type CreateApiPropertiesIdKeysKeyIdMovementsBody = CreateKeyMovementModel;\nexport const createApiPropertiesIdKeysKeyIdMovementsBody = createKeyMovementModel;\nexport const createApiPropertiesIdKeysKeyIdMovementsResponse = z.void();\nexport const getApiPropertiesIdChecksResponse = propertyCheckModelPagedResult;\nexport type CreateApiPropertiesIdChecksBody = CreatePropertyCheckModel;\nexport const createApiPropertiesIdChecksBody = createPropertyCheckModel;\nexport const createApiPropertiesIdChecksResponse = z.void();\nexport const getApiPropertiesCertificatesResponse = certificateModelPagedResult;\nexport const getApiPropertiesIdAppraisalsResponse = propertyAppraisalModelPagedResult;\nexport type CreateApiPropertiesIdAppraisalsBody = CreatePropertyAppraisalModel;\nexport const createApiPropertiesIdAppraisalsBody = createPropertyAppraisalModel;\nexport const createApiPropertiesIdAppraisalsResponse = z.void();\nexport const getApiPropertiesIdResponse = propertyModel;\nexport const patchApiPropertiesIdResponse = z.void();\nexport const getApiPropertiesIdCertificatesCertificateIdResponse = certificateModel;\nexport const patchApiPropertiesIdCertificatesCertificateIdResponse = z.void();\nexport const getApiPropertiesIdCertificatesResponsibilitiesResponse = propertyCertificateResponsibilitiesModel;\nexport const patchApiPropertiesIdCertificatesResponsibilitiesResponse = z.void();\nexport const getApiPropertiesIdKeysKeyIdResponse = keysModel;\nexport const getApiPropertiesIdKeysKeyIdMovementsMovementIdResponse = keyMovementModel;\nexport const updateApiPropertiesIdKeysKeyIdMovementsMovementIdResponse = z.void();\nexport const getApiPropertiesIdChecksCheckIdResponse = propertyCheckModel;\nexport const deleteApiPropertiesIdChecksCheckIdResponse = z.void();\nexport const patchApiPropertiesIdChecksCheckIdResponse = z.void();\nexport const getApiPropertiesIdAppraisalsAppraisalIdResponse = propertyAppraisalModel;\nexport const patchApiPropertiesIdAppraisalsAppraisalIdResponse = z.void();",
  "src/schemas/propertyModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { propertyModel, PropertyModel } from '@/schemas/propertyModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const propertyModelPagedResult = z.object({_embedded: z.array(propertyModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type PropertyModelPagedResult = {_embedded?: (Array<PropertyModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/propertyModel.generated.tsx": "import { z } from 'zod'\nimport { propertyAddressModel, PropertyAddressModel } from '@/schemas/propertyAddressModel.generated.tsx'\nimport { propertyRuralModel, PropertyRuralModel } from '@/schemas/propertyRuralModel.generated.tsx'\nimport { propertyExternalAreaModel, PropertyExternalAreaModel } from '@/schemas/propertyExternalAreaModel.generated.tsx'\nimport { propertyInternalAreaModel, PropertyInternalAreaModel } from '@/schemas/propertyInternalAreaModel.generated.tsx'\nimport { propertyEpcModel, PropertyEpcModel } from '@/schemas/propertyEpcModel.generated.tsx'\nimport { propertySellingModel, PropertySellingModel } from '@/schemas/propertySellingModel.generated.tsx'\nimport { propertyLettingModel, PropertyLettingModel } from '@/schemas/propertyLettingModel.generated.tsx'\nimport { propertyCommercialModel, PropertyCommercialModel } from '@/schemas/propertyCommercialModel.generated.tsx'\nimport { propertyRegionalModel, PropertyRegionalModel } from '@/schemas/propertyRegionalModel.generated.tsx'\nimport { unmappedAttributeModel, UnmappedAttributeModel } from '@/schemas/unmappedAttributeModel.generated.tsx'\nimport { propertyRoomModel, PropertyRoomModel } from '@/schemas/propertyRoomModel.generated.tsx'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\n\nexport const propertyModel = /** Representation of a property. Properties can be grouped into developments in the source data, functionality that is typically used by New Homes departments.\r\nThe _links collection will expose specific links to allow developers to navigate through a particular development, should a property be configured in this manner. Refer to commentary on the _links collection for more details */\nz.object({_embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the property */\nz.string().optional().nullable(), created: /** The date and time when the property was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the property was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), lastCall: /** The date the owner of the property was last called */\nz.string().optional().nullable(), nextCall: /** The date the owner of the property is next due to be called */\nz.string().optional().nullable(), marketingMode: /** The marketing mode of the property (selling/letting/sellingAndLetting) */\nz.string().optional().nullable(), currency: /** The currency that applies to monetary amounts exposed in the model */\nz.string().optional().nullable(), alternateId: /** An optional alternative identifier specified for this property */\nz.string().optional().nullable(), address: propertyAddressModel.optional().nullable(), areaId: /** The unique identifier of the area that the property resides in */\nz.string().optional().nullable(), strapline: /** The strapline description containing a short summary about the property */\nz.string().optional().nullable(), description: /** The brief description of the property */\nz.string().optional().nullable(), longDescription: /** The long description of the property */\nz.string().optional().nullable(), localAuthorityCompanyId: /** The property's local authority */\nz.string().optional().nullable(), localAuthorityCompanyName: /** The name of the property's local authority */\nz.string().optional().nullable(), summary: /** The summary of accommodation, typically short phrases or bullet points describing the key features of the property */\nz.string().optional().nullable(), departmentId: /** The unique identifier of the department the property is associated with. The property will only match to applicants with the same values set. See the [Platform Glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information about departments */\nz.string().optional().nullable(), negotiatorId: /** The unique identifier of the negotiator managing the property */\nz.string().optional().nullable(), bedrooms: /** The total number of bedrooms in the property. This is only supported by some departments. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nz.number().int().optional().nullable(), bedroomsMax: /** The maximum number of bedrooms in the property or properties. This is typically used when marketing development sites and would be set on the master record. This is only supported by some departments. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nz.number().int().optional().nullable(), receptions: /** The total number of reception rooms in the property. This is only supported by some departments. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nz.number().int().optional().nullable(), receptionsMax: /** The maximum number of reception rooms in the property. This is only supported by some departments. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nz.number().int().optional().nullable(), bathrooms: /** The total number of bathrooms in the property. This is only supported by some departments. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nz.number().int().optional().nullable(), bathroomsMax: /** The maximum number of bathrooms in the property. This is only supported by some departments. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nz.number().int().optional().nullable(), numberOfUnits: /** The number of units offered on the market. This is typically used when marketing development sites. */\nz.number().int().optional().nullable(), parkingSpaces: /** The total number of parking spaces the property has. This is only supported by some departments. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nz.number().int().optional().nullable(), councilTax: /** The council tax banding of the property (A/B/C/D/E/F/G/H/I/notYetAvailable) */\nz.string().optional().nullable(), disabledPortalIds: /** A collection of identifiers of portals that the property should not be displayed on */\nz.array(z.string().min(1)).optional().nullable(), internetAdvertising: /** A flag denoting whether or not this property can be advertised on the internet */\nz.boolean().optional().nullable(), isExternal: /** A flag denoting whether or not the property has been instructed by another estate agent */\nz.boolean().optional().nullable(), viewingArrangements: /** The arrangements regarding viewing the property */\nz.string().optional().nullable(), videoUrl: /** The url of a video associated with this property, such as a virtual tour */\nz.string().optional().nullable(), videoCaption: /** The caption for the video url associated with this property */\nz.string().optional().nullable(), video2Url: /** The url of a second video associated with this property, such as a virtual tour */\nz.string().optional().nullable(), video2Caption: /** The caption for the second video url associated with this property */\nz.string().optional().nullable(), notes: /** Any general notes regarding the property. These are not usually exposed to end users and may contain sensitive information about a sale */\nz.string().optional().nullable(), boardStatus: /** The status of the advertising board sited outside or near to the property */\nz.string().optional().nullable(), boardNotes: /** Any notes relevant to the advertising board sited outside or near to the property */\nz.string().optional().nullable(), featuredImageUrl: /** The properties featured image url */\nz.string().optional().nullable(), url: /** The url to the property on an external website */\nz.string().optional().nullable(), urlCaption: /** The caption to accompany the url to the property on an external website */\nz.string().optional().nullable(), groundRent: /** Any ground rent payment that applies to the property */\nz.number().optional().nullable(), groundRentComment: /** Comments regarding the ground rent of the property */\nz.string().optional().nullable(), groundRentReviewDate: /** The date when the ground rent payable on the property should be reviewed */\nz.string().pipe( z.coerce.date() ).optional().nullable(), groundRentIncrease: /** The annual percentage increase of the ground rent after being reviewed */\nz.number().optional().nullable(), serviceCharge: /** Any service charge payment that applies to the property */\nz.number().optional().nullable(), serviceChargeComment: /** Comments regarding the service charge of the property */\nz.string().optional().nullable(), floorLevel: /** The total number of parking spaces the property has. This is only supported by some departments. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nz.number().int().optional().nullable(), internalFloors: /** The number of internal floors the property has. Note that this field can only be set when certain configuration settings are enabled on the property's department. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nz.number().int().optional().nullable(), totalFloors: /** The total number of floors the property has. Note that this field can only be set when certain configuration settings are enabled on the property's department. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nz.number().int().optional().nullable(), boardUpdated: /** The date the advertising board was last updated (or should be updated when the date is in the future) */\nz.string().optional().nullable(), valuation: /** The date on which the property was valued. Note that this can differ to physical appointment dates in some cases */\nz.string().optional().nullable(), archivedOn: /** The date and time the property was archived */\nz.string().pipe( z.coerce.date() ).optional().nullable(), fromArchive: /** A flag determining whether or not the property is archived */\nz.boolean().optional().nullable(), rural: propertyRuralModel.optional().nullable(), externalArea: propertyExternalAreaModel.optional().nullable(), internalArea: propertyInternalAreaModel.optional().nullable(), epc: propertyEpcModel.optional().nullable(), selling: propertySellingModel.optional().nullable(), letting: propertyLettingModel.optional().nullable(), commercial: propertyCommercialModel.optional().nullable(), regional: propertyRegionalModel.optional().nullable(), type: /** The attributes describing the overall type of the property (eg house, bungalow, land), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department)\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nz.array(z.string().min(1)).optional().nullable(), style: /** The attributes describing the style of property (eg detached, semiDetached), defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department)\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nz.array(z.string().min(1)).optional().nullable(), situation: /** The attributes describing other aspects of the property - such as outside space - as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department)\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nz.array(z.string().min(1)).optional().nullable(), parking: /** The attributes describing the parking available at the property (eg garage), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department)\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nz.array(z.string().min(1)).optional().nullable(), age: /** The attributes describing the age of the property (eg new, period), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department)\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nz.array(z.string().min(1)).optional().nullable(), locality: /** The attributes describing the general location of the property (eg rural, townCity), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department)\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nz.array(z.string().min(1)).optional().nullable(), specialFeatures: /** The attributes describing the property's special features (eg swimmingPool, tennisCourt), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(z.string().min(1)).optional().nullable(), unmappedAttributes: /** The attributes associated to the property which are not currently mapped. These are defined the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(unmappedAttributeModel).optional().nullable(), availableServicesIds: /** Identifiers of any services connected at the property */\nz.array(z.string().min(1)).optional().nullable(), rooms: /** Details of each room in the property */\nz.array(propertyRoomModel).optional().nullable(), roomDetailsApproved: /** A flag determining whether or not the property's room details have been approved by the vendor or landlord */\nz.boolean().optional().nullable(), officeIds: /** A collection of unique identifiers of offices attached to the property. The first item in the collection is considered the primary office */\nz.array(z.string().min(1)).optional().nullable(), lostInstructionDate: /** The date that this property became a lost instruction */\nz.string().pipe( z.coerce.date() ).optional().nullable(), lostInstructionNote: /** The notes regarding the lost instruction */\nz.string().optional().nullable(), developmentSiteType: /** The type of development */\nz.string().optional().nullable(), metadata: /** App specific metadata that has been set against the property */\nz.record(z.string(), z.object({})).optional().nullable(), keywords: /** The keywords associated with property */\nz.array(z.string().min(1)).optional().nullable(), extrasField: /** The requested extras fields */\nz.record(z.string(), z.object({})).optional().nullable(), _eTag: /** The ETag for the current version of the property. Used for managing update concurrency */\nz.string().optional().nullable(), _links: /** Collection containing relative URLs to data associated with the property.\r\nIn the case of a development - where a property is grouped with, or associated to another property by way of a parent/child relationship,\r\nthe collection will contain a _master_ or _subPlot_ link depending on the property type. Where the property is the master record in a development (the parent),\r\na _subPlots_ link will be included in the collection giving you access to all the plots (the children) within the development. Where the property is a sub plot that forms part of a \r\ndevelopment, a _master_ link will be included in the collection giving you access to the master record. */\nz.record(z.string(), linkModel).optional().nullable()});\nexport type PropertyModel = /** Representation of a property. Properties can be grouped into developments in the source data, functionality that is typically used by New Homes departments.\r\nThe _links collection will expose specific links to allow developers to navigate through a particular development, should a property be configured in this manner. Refer to commentary on the _links collection for more details */\n{_embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the property */\nstring) | null | undefined, created?: (/** The date and time when the property was created */\nDate) | null | undefined, modified?: (/** The date and time when the property was last modified */\nDate) | null | undefined, lastCall?: (/** The date the owner of the property was last called */\nstring) | null | undefined, nextCall?: (/** The date the owner of the property is next due to be called */\nstring) | null | undefined, marketingMode?: (/** The marketing mode of the property (selling/letting/sellingAndLetting) */\nstring) | null | undefined, currency?: (/** The currency that applies to monetary amounts exposed in the model */\nstring) | null | undefined, alternateId?: (/** An optional alternative identifier specified for this property */\nstring) | null | undefined, address?: (PropertyAddressModel) | null | undefined, areaId?: (/** The unique identifier of the area that the property resides in */\nstring) | null | undefined, strapline?: (/** The strapline description containing a short summary about the property */\nstring) | null | undefined, description?: (/** The brief description of the property */\nstring) | null | undefined, longDescription?: (/** The long description of the property */\nstring) | null | undefined, localAuthorityCompanyId?: (/** The property's local authority */\nstring) | null | undefined, localAuthorityCompanyName?: (/** The name of the property's local authority */\nstring) | null | undefined, summary?: (/** The summary of accommodation, typically short phrases or bullet points describing the key features of the property */\nstring) | null | undefined, departmentId?: (/** The unique identifier of the department the property is associated with. The property will only match to applicants with the same values set. See the [Platform Glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information about departments */\nstring) | null | undefined, negotiatorId?: (/** The unique identifier of the negotiator managing the property */\nstring) | null | undefined, bedrooms?: (/** The total number of bedrooms in the property. This is only supported by some departments. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nnumber) | null | undefined, bedroomsMax?: (/** The maximum number of bedrooms in the property or properties. This is typically used when marketing development sites and would be set on the master record. This is only supported by some departments. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nnumber) | null | undefined, receptions?: (/** The total number of reception rooms in the property. This is only supported by some departments. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nnumber) | null | undefined, receptionsMax?: (/** The maximum number of reception rooms in the property. This is only supported by some departments. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nnumber) | null | undefined, bathrooms?: (/** The total number of bathrooms in the property. This is only supported by some departments. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nnumber) | null | undefined, bathroomsMax?: (/** The maximum number of bathrooms in the property. This is only supported by some departments. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nnumber) | null | undefined, numberOfUnits?: (/** The number of units offered on the market. This is typically used when marketing development sites. */\nnumber) | null | undefined, parkingSpaces?: (/** The total number of parking spaces the property has. This is only supported by some departments. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nnumber) | null | undefined, councilTax?: (/** The council tax banding of the property (A/B/C/D/E/F/G/H/I/notYetAvailable) */\nstring) | null | undefined, disabledPortalIds?: (/** A collection of identifiers of portals that the property should not be displayed on */\nArray<string>) | null | undefined, internetAdvertising?: (/** A flag denoting whether or not this property can be advertised on the internet */\nboolean) | null | undefined, isExternal?: (/** A flag denoting whether or not the property has been instructed by another estate agent */\nboolean) | null | undefined, viewingArrangements?: (/** The arrangements regarding viewing the property */\nstring) | null | undefined, videoUrl?: (/** The url of a video associated with this property, such as a virtual tour */\nstring) | null | undefined, videoCaption?: (/** The caption for the video url associated with this property */\nstring) | null | undefined, video2Url?: (/** The url of a second video associated with this property, such as a virtual tour */\nstring) | null | undefined, video2Caption?: (/** The caption for the second video url associated with this property */\nstring) | null | undefined, notes?: (/** Any general notes regarding the property. These are not usually exposed to end users and may contain sensitive information about a sale */\nstring) | null | undefined, boardStatus?: (/** The status of the advertising board sited outside or near to the property */\nstring) | null | undefined, boardNotes?: (/** Any notes relevant to the advertising board sited outside or near to the property */\nstring) | null | undefined, featuredImageUrl?: (/** The properties featured image url */\nstring) | null | undefined, url?: (/** The url to the property on an external website */\nstring) | null | undefined, urlCaption?: (/** The caption to accompany the url to the property on an external website */\nstring) | null | undefined, groundRent?: (/** Any ground rent payment that applies to the property */\nnumber) | null | undefined, groundRentComment?: (/** Comments regarding the ground rent of the property */\nstring) | null | undefined, groundRentReviewDate?: (/** The date when the ground rent payable on the property should be reviewed */\nDate) | null | undefined, groundRentIncrease?: (/** The annual percentage increase of the ground rent after being reviewed */\nnumber) | null | undefined, serviceCharge?: (/** Any service charge payment that applies to the property */\nnumber) | null | undefined, serviceChargeComment?: (/** Comments regarding the service charge of the property */\nstring) | null | undefined, floorLevel?: (/** The total number of parking spaces the property has. This is only supported by some departments. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nnumber) | null | undefined, internalFloors?: (/** The number of internal floors the property has. Note that this field can only be set when certain configuration settings are enabled on the property's department. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nnumber) | null | undefined, totalFloors?: (/** The total number of floors the property has. Note that this field can only be set when certain configuration settings are enabled on the property's department. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nnumber) | null | undefined, boardUpdated?: (/** The date the advertising board was last updated (or should be updated when the date is in the future) */\nstring) | null | undefined, valuation?: (/** The date on which the property was valued. Note that this can differ to physical appointment dates in some cases */\nstring) | null | undefined, archivedOn?: (/** The date and time the property was archived */\nDate) | null | undefined, fromArchive?: (/** A flag determining whether or not the property is archived */\nboolean) | null | undefined, rural?: (PropertyRuralModel) | null | undefined, externalArea?: (PropertyExternalAreaModel) | null | undefined, internalArea?: (PropertyInternalAreaModel) | null | undefined, epc?: (PropertyEpcModel) | null | undefined, selling?: (PropertySellingModel) | null | undefined, letting?: (PropertyLettingModel) | null | undefined, commercial?: (PropertyCommercialModel) | null | undefined, regional?: (PropertyRegionalModel) | null | undefined, type?: (/** The attributes describing the overall type of the property (eg house, bungalow, land), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department)\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nArray<string>) | null | undefined, style?: (/** The attributes describing the style of property (eg detached, semiDetached), defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department)\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nArray<string>) | null | undefined, situation?: (/** The attributes describing other aspects of the property - such as outside space - as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department)\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nArray<string>) | null | undefined, parking?: (/** The attributes describing the parking available at the property (eg garage), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department)\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nArray<string>) | null | undefined, age?: (/** The attributes describing the age of the property (eg new, period), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department)\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nArray<string>) | null | undefined, locality?: (/** The attributes describing the general location of the property (eg rural, townCity), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department)\r\nFor information about how to interpret this data and how it maps back to AgencyCloud, please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#interpreting-department-data) */\nArray<string>) | null | undefined, specialFeatures?: (/** The attributes describing the property's special features (eg swimmingPool, tennisCourt), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<string>) | null | undefined, unmappedAttributes?: (/** The attributes associated to the property which are not currently mapped. These are defined the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<UnmappedAttributeModel>) | null | undefined, availableServicesIds?: (/** Identifiers of any services connected at the property */\nArray<string>) | null | undefined, rooms?: (/** Details of each room in the property */\nArray<PropertyRoomModel>) | null | undefined, roomDetailsApproved?: (/** A flag determining whether or not the property's room details have been approved by the vendor or landlord */\nboolean) | null | undefined, officeIds?: (/** A collection of unique identifiers of offices attached to the property. The first item in the collection is considered the primary office */\nArray<string>) | null | undefined, lostInstructionDate?: (/** The date that this property became a lost instruction */\nDate) | null | undefined, lostInstructionNote?: (/** The notes regarding the lost instruction */\nstring) | null | undefined, developmentSiteType?: (/** The type of development */\nstring) | null | undefined, metadata?: (/** App specific metadata that has been set against the property */\nRecord<string, Record<string, never>>) | null | undefined, keywords?: (/** The keywords associated with property */\nArray<string>) | null | undefined, extrasField?: (/** The requested extras fields */\nRecord<string, Record<string, never>>) | null | undefined, _eTag?: (/** The ETag for the current version of the property. Used for managing update concurrency */\nstring) | null | undefined, _links?: (/** Collection containing relative URLs to data associated with the property.\r\nIn the case of a development - where a property is grouped with, or associated to another property by way of a parent/child relationship,\r\nthe collection will contain a _master_ or _subPlot_ link depending on the property type. Where the property is the master record in a development (the parent),\r\na _subPlots_ link will be included in the collection giving you access to all the plots (the children) within the development. Where the property is a sub plot that forms part of a \r\ndevelopment, a _master_ link will be included in the collection giving you access to the master record. */\nRecord<string, LinkModel>) | null | undefined};",
  "src/schemas/propertyAddressModel.generated.tsx": "import { z } from 'zod'\nimport { propertyGeolocationModel, PropertyGeolocationModel } from '@/schemas/propertyGeolocationModel.generated.tsx'\n\nexport const propertyAddressModel = /** Representation of the physical address of a building or premise */\nz.object({buildingName: /** The building name */\nz.string().optional().nullable(), buildingNumber: /** The building number */\nz.string().optional().nullable(), line1: /** The first line of the address */\nz.string().optional().nullable(), line2: /** The second line of the address */\nz.string().optional().nullable(), line3: /** The third line of the address */\nz.string().optional().nullable(), line4: /** The fourth line of the address */\nz.string().optional().nullable(), postcode: /** The postcode */\nz.string().optional().nullable(), countryId: /** The ISO-3166 country code that the address resides within */\nz.string().optional().nullable(), localTimeZone: /** The local timezone for the address, based on the Geolocation coordinates */\nz.string().optional().nullable(), geolocation: propertyGeolocationModel.optional().nullable()});\nexport type PropertyAddressModel = /** Representation of the physical address of a building or premise */\n{buildingName?: (/** The building name */\nstring) | null | undefined, buildingNumber?: (/** The building number */\nstring) | null | undefined, line1?: (/** The first line of the address */\nstring) | null | undefined, line2?: (/** The second line of the address */\nstring) | null | undefined, line3?: (/** The third line of the address */\nstring) | null | undefined, line4?: (/** The fourth line of the address */\nstring) | null | undefined, postcode?: (/** The postcode */\nstring) | null | undefined, countryId?: (/** The ISO-3166 country code that the address resides within */\nstring) | null | undefined, localTimeZone?: (/** The local timezone for the address, based on the Geolocation coordinates */\nstring) | null | undefined, geolocation?: (PropertyGeolocationModel) | null | undefined};",
  "src/schemas/propertyGeolocationModel.generated.tsx": "import { z } from 'zod'\n\nexport const propertyGeolocationModel = /** Representation of the geographical location of an address using coordinates */\nz.object({latitude: /** The latitude coordinate of the coordinate pair */\nz.number().optional().nullable(), longitude: /** The longitude coordinate of the coordinate pair */\nz.number().optional().nullable()});\nexport type PropertyGeolocationModel = /** Representation of the geographical location of an address using coordinates */\n{latitude?: (/** The latitude coordinate of the coordinate pair */\nnumber) | null | undefined, longitude?: (/** The longitude coordinate of the coordinate pair */\nnumber) | null | undefined};",
  "src/schemas/propertyRuralModel.generated.tsx": "import { z } from 'zod'\n\nexport const propertyRuralModel = /** Details specific to rural properties */\nz.object({tenureId: /** Details of the rural tenure associated with the property. */\nz.string().optional().nullable(), buildingsDescription: /** Details of the buildings associated with the property. */\nz.string().optional().nullable(), landDescription: /** Details of the land associated with the property. */\nz.string().optional().nullable()});\nexport type PropertyRuralModel = /** Details specific to rural properties */\n{tenureId?: (/** Details of the rural tenure associated with the property. */\nstring) | null | undefined, buildingsDescription?: (/** Details of the buildings associated with the property. */\nstring) | null | undefined, landDescription?: (/** Details of the land associated with the property. */\nstring) | null | undefined};",
  "src/schemas/propertyExternalAreaModel.generated.tsx": "import { z } from 'zod'\n\nexport const propertyExternalAreaModel = /** Representation of the external land area of a property */\nz.object({type: /** The unit of area (acres/hectares) */\nz.string().optional().nullable(), min: /** The minimum area bound */\nz.number().optional().nullable(), max: /** The maximum area bound (please note there is no corresponding field in the Reapit CRM) */\nz.number().optional().nullable()});\nexport type PropertyExternalAreaModel = /** Representation of the external land area of a property */\n{type?: (/** The unit of area (acres/hectares) */\nstring) | null | undefined, min?: (/** The minimum area bound */\nnumber) | null | undefined, max?: (/** The maximum area bound (please note there is no corresponding field in the Reapit CRM) */\nnumber) | null | undefined};",
  "src/schemas/propertyInternalAreaModel.generated.tsx": "import { z } from 'zod'\n\nexport const propertyInternalAreaModel = /** Representation of the internal dimensions of a property */\nz.object({type: /** The unit of area (squareFeet/squareMetres) */\nz.string().optional().nullable(), min: /** The minimum area bound */\nz.number().optional().nullable(), max: /** The maximum area bound */\nz.number().optional().nullable()});\nexport type PropertyInternalAreaModel = /** Representation of the internal dimensions of a property */\n{type?: (/** The unit of area (squareFeet/squareMetres) */\nstring) | null | undefined, min?: (/** The minimum area bound */\nnumber) | null | undefined, max?: (/** The maximum area bound */\nnumber) | null | undefined};",
  "src/schemas/propertyEpcModel.generated.tsx": "import { z } from 'zod'\n\nexport const propertyEpcModel = /** Representation of EPC statistics */\nz.object({exempt: /** A flag denoting whether or not this property is exempt from requiring an EPC certificate */\nz.boolean().optional().nullable(), eer: /** The current energy efficiency rating */\nz.number().int().optional().nullable(), eerRating: /** The current energy efficiency letter rating (A-G). This is generated from the `eer` value\r\nfor systems that do not have an explicit EPC Rating component */\nz.string().optional().nullable(), eerPotential: /** The potential energy efficiency rating */\nz.number().int().optional().nullable(), eerPotentialRating: /** The potential energy efficiency letter rating (A-G). This is generated from the `eerPotential` value */\nz.string().optional().nullable(), eir: /** The current environmental impact rating */\nz.number().int().optional().nullable(), eirRating: /** The current environment impact letter rating (A-G). This is generated from the `eir` value */\nz.string().optional().nullable(), eirPotential: /** The potential environmental impact rating */\nz.number().int().optional().nullable(), eirPotentialRating: /** The potential environment impact letter rating (A-G). This is generated from the `eirPotential` value */\nz.string().optional().nullable(), fullDocumentUrl: /** The URL to access the full EPC document */\nz.string().optional().nullable(), firstPageDocumentUrl: /** The URL to access the first page of the EPC document */\nz.string().optional().nullable()});\nexport type PropertyEpcModel = /** Representation of EPC statistics */\n{exempt?: (/** A flag denoting whether or not this property is exempt from requiring an EPC certificate */\nboolean) | null | undefined, eer?: (/** The current energy efficiency rating */\nnumber) | null | undefined, eerRating?: (/** The current energy efficiency letter rating (A-G). This is generated from the `eer` value\r\nfor systems that do not have an explicit EPC Rating component */\nstring) | null | undefined, eerPotential?: (/** The potential energy efficiency rating */\nnumber) | null | undefined, eerPotentialRating?: (/** The potential energy efficiency letter rating (A-G). This is generated from the `eerPotential` value */\nstring) | null | undefined, eir?: (/** The current environmental impact rating */\nnumber) | null | undefined, eirRating?: (/** The current environment impact letter rating (A-G). This is generated from the `eir` value */\nstring) | null | undefined, eirPotential?: (/** The potential environmental impact rating */\nnumber) | null | undefined, eirPotentialRating?: (/** The potential environment impact letter rating (A-G). This is generated from the `eirPotential` value */\nstring) | null | undefined, fullDocumentUrl?: (/** The URL to access the full EPC document */\nstring) | null | undefined, firstPageDocumentUrl?: (/** The URL to access the first page of the EPC document */\nstring) | null | undefined};",
  "src/schemas/propertySellingModel.generated.tsx": "import { z } from 'zod'\nimport { propertyTenureModel, PropertyTenureModel } from '@/schemas/propertyTenureModel.generated.tsx'\nimport { propertyCommissionFeeModel, PropertyCommissionFeeModel } from '@/schemas/propertyCommissionFeeModel.generated.tsx'\nimport { propertySharedOwnershipModel, PropertySharedOwnershipModel } from '@/schemas/propertySharedOwnershipModel.generated.tsx'\nimport { propertySubAgentTermsModel, PropertySubAgentTermsModel } from '@/schemas/propertySubAgentTermsModel.generated.tsx'\n\nexport const propertySellingModel = /** Representation of property details specific to sales marketing */\nz.object({instructed: /** The date that the property was marked as for sale */\nz.string().optional().nullable(), price: /** The marketing price of the property */\nz.number().optional().nullable(), priceTo: /** The maximum price of a property on the development plot */\nz.number().optional().nullable(), reservationFee: /** The fee charged by the agent to reserve a property (typically a new build) */\nz.number().int().optional().nullable(), qualifier: /** The price qualifier (askingPrice/priceOnApplication/guidePrice/offersInRegion/offersOver/offersInExcess/fixedPrice/priceReducedTo) */\nz.string().optional().nullable(), status: /** The current status of the sale (preAppraisal/valuation/paidValuation/forSale/forSaleUnavailable/underOffer/underOfferUnavailable/reserved/exchanged/completed/soldExternally/withdrawn) */\nz.string().optional().nullable(), disposal: /** The method used to sell the property (auction/confidential/tender/offersInvited/privateTreaty/sharedOwnership) */\nz.string().optional().nullable(), completed: /** The date the property sale was completed */\nz.string().optional().nullable(), exchanged: /** The date the property was exchanged */\nz.string().optional().nullable(), accountPaid: /** The date the property account was paid */\nz.string().optional().nullable(), tenure: propertyTenureModel.optional().nullable(), vendorId: /** The unique identifier of the vendor selling the property */\nz.string().optional().nullable(), agency: /** The selling agency type (marketingForAssociate/clientsOnly/comparable/subAgent/jointSole/jointSoleFeeAvailable/multiple/multipleFeeAvailable/ownToSell/soleSellingRights/soleSellingRightsFeeAvailable/soleAgent/soleAgentFeeAvailable) */\nz.string().optional().nullable(), agencyId: /** The unique identifier of the custom selling agency type - only applicable when Agency is not set */\nz.string().optional().nullable(), agreementExpiry: /** The date on which the agreement between the vendor and agent expires */\nz.string().optional().nullable(), fee: propertyCommissionFeeModel.optional().nullable(), exchangedCompanyFee: /** The actual fee amount to be collected by the agent - often based on the exchange price of the property */\nz.number().optional().nullable(), recommendedPrice: /** The agent's recommended asking price */\nz.number().int().optional().nullable(), valuationPrice: /** The agent's valuation price */\nz.number().int().optional().nullable(), brochureId: /** The unique identifier of the document used for the sales brochure */\nz.string().optional().nullable(), publicBrochureUrl: /** The URL at which the brochure can be publicly accessed when the\r\nproperty is being actively marketed */\nz.string().optional().nullable(), exchangedPrice: /** The price the property exchanged/sold for */\nz.number().int().optional().nullable(), exchangedOfficeId: /** The unique identifier of the office that sold the property */\nz.string().optional().nullable(), decoration: /** The property's decorative condition (unmodernised/fair/good/veryGood) */\nz.array(z.string().min(1)).optional().nullable(), sharedOwnership: propertySharedOwnershipModel.optional().nullable(), subAgentTerms: propertySubAgentTermsModel.optional().nullable()});\nexport type PropertySellingModel = /** Representation of property details specific to sales marketing */\n{instructed?: (/** The date that the property was marked as for sale */\nstring) | null | undefined, price?: (/** The marketing price of the property */\nnumber) | null | undefined, priceTo?: (/** The maximum price of a property on the development plot */\nnumber) | null | undefined, reservationFee?: (/** The fee charged by the agent to reserve a property (typically a new build) */\nnumber) | null | undefined, qualifier?: (/** The price qualifier (askingPrice/priceOnApplication/guidePrice/offersInRegion/offersOver/offersInExcess/fixedPrice/priceReducedTo) */\nstring) | null | undefined, status?: (/** The current status of the sale (preAppraisal/valuation/paidValuation/forSale/forSaleUnavailable/underOffer/underOfferUnavailable/reserved/exchanged/completed/soldExternally/withdrawn) */\nstring) | null | undefined, disposal?: (/** The method used to sell the property (auction/confidential/tender/offersInvited/privateTreaty/sharedOwnership) */\nstring) | null | undefined, completed?: (/** The date the property sale was completed */\nstring) | null | undefined, exchanged?: (/** The date the property was exchanged */\nstring) | null | undefined, accountPaid?: (/** The date the property account was paid */\nstring) | null | undefined, tenure?: (PropertyTenureModel) | null | undefined, vendorId?: (/** The unique identifier of the vendor selling the property */\nstring) | null | undefined, agency?: (/** The selling agency type (marketingForAssociate/clientsOnly/comparable/subAgent/jointSole/jointSoleFeeAvailable/multiple/multipleFeeAvailable/ownToSell/soleSellingRights/soleSellingRightsFeeAvailable/soleAgent/soleAgentFeeAvailable) */\nstring) | null | undefined, agencyId?: (/** The unique identifier of the custom selling agency type - only applicable when Agency is not set */\nstring) | null | undefined, agreementExpiry?: (/** The date on which the agreement between the vendor and agent expires */\nstring) | null | undefined, fee?: (PropertyCommissionFeeModel) | null | undefined, exchangedCompanyFee?: (/** The actual fee amount to be collected by the agent - often based on the exchange price of the property */\nnumber) | null | undefined, recommendedPrice?: (/** The agent's recommended asking price */\nnumber) | null | undefined, valuationPrice?: (/** The agent's valuation price */\nnumber) | null | undefined, brochureId?: (/** The unique identifier of the document used for the sales brochure */\nstring) | null | undefined, publicBrochureUrl?: (/** The URL at which the brochure can be publicly accessed when the\r\nproperty is being actively marketed */\nstring) | null | undefined, exchangedPrice?: (/** The price the property exchanged/sold for */\nnumber) | null | undefined, exchangedOfficeId?: (/** The unique identifier of the office that sold the property */\nstring) | null | undefined, decoration?: (/** The property's decorative condition (unmodernised/fair/good/veryGood) */\nArray<string>) | null | undefined, sharedOwnership?: (PropertySharedOwnershipModel) | null | undefined, subAgentTerms?: (PropertySubAgentTermsModel) | null | undefined};",
  "src/schemas/propertyTenureModel.generated.tsx": "import { z } from 'zod'\n\nexport const propertyTenureModel = /** Representation of the tenure of a property */\nz.object({type: /** The type of tenure that applies to the property (freehold/leasehold/shareOfFreehold/commonhold/tba) */\nz.string().optional().nullable(), expiry: /** The tenure expiration date */\nz.string().optional().nullable()});\nexport type PropertyTenureModel = /** Representation of the tenure of a property */\n{type?: (/** The type of tenure that applies to the property (freehold/leasehold/shareOfFreehold/commonhold/tba) */\nstring) | null | undefined, expiry?: (/** The tenure expiration date */\nstring) | null | undefined};",
  "src/schemas/propertyCommissionFeeModel.generated.tsx": "import { z } from 'zod'\n\nexport const propertyCommissionFeeModel = /** Representation of the the commission fee for a property */\nz.object({type: /** The commission letting fee type (percentage/fixed) */\nz.string().optional().nullable(), amount: /** The commission letting fee amount */\nz.number().optional().nullable()});\nexport type PropertyCommissionFeeModel = /** Representation of the the commission fee for a property */\n{type?: (/** The commission letting fee type (percentage/fixed) */\nstring) | null | undefined, amount?: (/** The commission letting fee amount */\nnumber) | null | undefined};",
  "src/schemas/propertySharedOwnershipModel.generated.tsx": "import { z } from 'zod'\n\nexport const propertySharedOwnershipModel = /** Details relating to the shared ownership of the property */\nz.object({sharedPercentage: /** The percentage of the shared ownership property being sold by the vendor */\nz.number().optional().nullable(), rent: /** The rent payable on the remainder of the shared ownership property */\nz.number().optional().nullable(), rentFrequency: /** The frequency at which the shared ownership rent should be paid */\nz.string().optional().nullable()});\nexport type PropertySharedOwnershipModel = /** Details relating to the shared ownership of the property */\n{sharedPercentage?: (/** The percentage of the shared ownership property being sold by the vendor */\nnumber) | null | undefined, rent?: (/** The rent payable on the remainder of the shared ownership property */\nnumber) | null | undefined, rentFrequency?: (/** The frequency at which the shared ownership rent should be paid */\nstring) | null | undefined};",
  "src/schemas/propertySubAgentTermsModel.generated.tsx": "import { z } from 'zod'\n\nexport const propertySubAgentTermsModel = /** Representation of the sub agent terms */\nz.object({feeAvailable: /** A flag denoting whether or not fee is available */\nz.boolean().optional().nullable(), type: /** The type of fee (percent/fixed/callForFees) */\nz.string().optional().nullable(), amount: /** The fee amount */\nz.number().optional().nullable()});\nexport type PropertySubAgentTermsModel = /** Representation of the sub agent terms */\n{feeAvailable?: (/** A flag denoting whether or not fee is available */\nboolean) | null | undefined, type?: (/** The type of fee (percent/fixed/callForFees) */\nstring) | null | undefined, amount?: (/** The fee amount */\nnumber) | null | undefined};",
  "src/schemas/propertyLettingModel.generated.tsx": "import { z } from 'zod'\nimport { propertyCommissionFeeModel, PropertyCommissionFeeModel } from '@/schemas/propertyCommissionFeeModel.generated.tsx'\nimport { utilityModel, UtilityModel } from '@/schemas/utilityModel.generated.tsx'\nimport { propertyLettingsDepositModel, PropertyLettingsDepositModel } from '@/schemas/propertyLettingsDepositModel.generated.tsx'\nimport { propertyLettingRentInsuranceModel, PropertyLettingRentInsuranceModel } from '@/schemas/propertyLettingRentInsuranceModel.generated.tsx'\nimport { propertyLettingLicencingModel, PropertyLettingLicencingModel } from '@/schemas/propertyLettingLicencingModel.generated.tsx'\n\nexport const propertyLettingModel = /** Representation of property details specific to lettings marketing */\nz.object({instructed: /** The date the property was marked as to let */\nz.string().optional().nullable(), availableFrom: /** The date the property is next available from */\nz.string().optional().nullable(), availableTo: /** The date the property is available to */\nz.string().optional().nullable(), agreementSigned: /** The date the letting agreement between the landlord and agent was signed */\nz.string().optional().nullable(), rent: /** The rent being charged for the property */\nz.number().optional().nullable(), rentFrequency: /** The frequency at which rent will be collected (weekly/monthly/annually) */\nz.string().optional().nullable(), rentIncludes: /** Details of any bills that are included in the rent */\nz.string().optional().nullable(), furnishing: /** The furnishing state that the property can be offered in (furnished/unfurnished/partFurnished) */\nz.array(z.string().min(1)).optional().nullable(), term: /** The acceptable letting terms (short/long/any) */\nz.string().optional().nullable(), status: /** The current status of the let (valuation/toLet/toLetUnavailable/underOffer/underOfferUnavailable/arrangingTenancyUnavailable/arrangingTenancy/tenancyCurrentUnavailable/tenancyCurrent/tenancyFinished/tenancyCancelled/sold/letByOtherAgent/letPrivately/provisional/withdrawn) */\nz.string().optional().nullable(), agentRole: /** The role that the agent will be performing for this lettings property (managed/rentCollection/collectFirstPayment/collectRentToDate/lettingOnly/introducingTenant) */\nz.string().optional().nullable(), landlordId: /** The unique identifier of the landlord letting the property */\nz.string().optional().nullable(), worksOrderNote: /** A note to accompany any works orders created for the property */\nz.string().optional().nullable(), minimumTerm: /** The minimum number of months the property can be let out for */\nz.number().int().optional().nullable(), propertyManagerId: /** The unique identifier of the negotiator that manages the property */\nz.string().optional().nullable(), managementCompanyIds: /** The unique identifiers of the management companies associated to the property */\nz.array(z.string().min(1)).optional().nullable(), brochureId: /** The unique identifier of the document used for the lettings brochure */\nz.string().optional().nullable(), publicBrochureUrl: /** The URL at which the brochure can be publicly accessed when the\r\nproperty is being actively marketed */\nz.string().optional().nullable(), managementFee: propertyCommissionFeeModel.optional().nullable(), lettingFee: propertyCommissionFeeModel.optional().nullable(), qualifier: /** The rent qualifier (rentOnApplication/askingRent) */\nz.string().optional().nullable(), utilities: utilityModel.optional().nullable(), deposit: propertyLettingsDepositModel.optional().nullable(), rentInsurance: propertyLettingRentInsuranceModel.optional().nullable(), licencing: propertyLettingLicencingModel.optional().nullable()});\nexport type PropertyLettingModel = /** Representation of property details specific to lettings marketing */\n{instructed?: (/** The date the property was marked as to let */\nstring) | null | undefined, availableFrom?: (/** The date the property is next available from */\nstring) | null | undefined, availableTo?: (/** The date the property is available to */\nstring) | null | undefined, agreementSigned?: (/** The date the letting agreement between the landlord and agent was signed */\nstring) | null | undefined, rent?: (/** The rent being charged for the property */\nnumber) | null | undefined, rentFrequency?: (/** The frequency at which rent will be collected (weekly/monthly/annually) */\nstring) | null | undefined, rentIncludes?: (/** Details of any bills that are included in the rent */\nstring) | null | undefined, furnishing?: (/** The furnishing state that the property can be offered in (furnished/unfurnished/partFurnished) */\nArray<string>) | null | undefined, term?: (/** The acceptable letting terms (short/long/any) */\nstring) | null | undefined, status?: (/** The current status of the let (valuation/toLet/toLetUnavailable/underOffer/underOfferUnavailable/arrangingTenancyUnavailable/arrangingTenancy/tenancyCurrentUnavailable/tenancyCurrent/tenancyFinished/tenancyCancelled/sold/letByOtherAgent/letPrivately/provisional/withdrawn) */\nstring) | null | undefined, agentRole?: (/** The role that the agent will be performing for this lettings property (managed/rentCollection/collectFirstPayment/collectRentToDate/lettingOnly/introducingTenant) */\nstring) | null | undefined, landlordId?: (/** The unique identifier of the landlord letting the property */\nstring) | null | undefined, worksOrderNote?: (/** A note to accompany any works orders created for the property */\nstring) | null | undefined, minimumTerm?: (/** The minimum number of months the property can be let out for */\nnumber) | null | undefined, propertyManagerId?: (/** The unique identifier of the negotiator that manages the property */\nstring) | null | undefined, managementCompanyIds?: (/** The unique identifiers of the management companies associated to the property */\nArray<string>) | null | undefined, brochureId?: (/** The unique identifier of the document used for the lettings brochure */\nstring) | null | undefined, publicBrochureUrl?: (/** The URL at which the brochure can be publicly accessed when the\r\nproperty is being actively marketed */\nstring) | null | undefined, managementFee?: (PropertyCommissionFeeModel) | null | undefined, lettingFee?: (PropertyCommissionFeeModel) | null | undefined, qualifier?: (/** The rent qualifier (rentOnApplication/askingRent) */\nstring) | null | undefined, utilities?: (UtilityModel) | null | undefined, deposit?: (PropertyLettingsDepositModel) | null | undefined, rentInsurance?: (PropertyLettingRentInsuranceModel) | null | undefined, licencing?: (PropertyLettingLicencingModel) | null | undefined};",
  "src/schemas/utilityModel.generated.tsx": "import { z } from 'zod'\n\nexport const utilityModel = /** Representation of property details specific to utilities */\nz.object({hasGas: /** A flag denoting whether or not the property has gas connected */\nz.boolean().optional().nullable(), gasCompanyId: /** The unique identifier of the company supplying the gas to the property */\nz.string().optional().nullable(), gasMeterPoint: /** The gas meter point number */\nz.string().optional().nullable(), electricityCompanyId: /** The unique identifier of the company supplying the electricity to the property */\nz.string().optional().nullable(), electricityMeterPoint: /** The electricity meter point number */\nz.string().optional().nullable(), waterCompanyId: /** The unique identifier of the company supplying the water to the property */\nz.string().optional().nullable(), waterMeterPoint: /** The water meter point number */\nz.string().optional().nullable(), telephoneCompanyId: /** The unique identifier of the company supplying the telephone to the property */\nz.string().optional().nullable(), internetCompanyId: /** The unique identifier of the company supplying the internet to the property */\nz.string().optional().nullable(), cableTvCompanyId: /** The unique identifier of the company supplying the cable tv to the property */\nz.string().optional().nullable()});\nexport type UtilityModel = /** Representation of property details specific to utilities */\n{hasGas?: (/** A flag denoting whether or not the property has gas connected */\nboolean) | null | undefined, gasCompanyId?: (/** The unique identifier of the company supplying the gas to the property */\nstring) | null | undefined, gasMeterPoint?: (/** The gas meter point number */\nstring) | null | undefined, electricityCompanyId?: (/** The unique identifier of the company supplying the electricity to the property */\nstring) | null | undefined, electricityMeterPoint?: (/** The electricity meter point number */\nstring) | null | undefined, waterCompanyId?: (/** The unique identifier of the company supplying the water to the property */\nstring) | null | undefined, waterMeterPoint?: (/** The water meter point number */\nstring) | null | undefined, telephoneCompanyId?: (/** The unique identifier of the company supplying the telephone to the property */\nstring) | null | undefined, internetCompanyId?: (/** The unique identifier of the company supplying the internet to the property */\nstring) | null | undefined, cableTvCompanyId?: (/** The unique identifier of the company supplying the cable tv to the property */\nstring) | null | undefined};",
  "src/schemas/propertyLettingsDepositModel.generated.tsx": "import { z } from 'zod'\n\nexport const propertyLettingsDepositModel = /** Representation of a property details related to deposit */\nz.object({type: /** The type of deposit (weeks/months/fixed) */\nz.string().optional().nullable(), amount: /** The deposit amount. This can be the number of weeks or months rent or a monetary amount based on the `type` */\nz.number().optional().nullable()});\nexport type PropertyLettingsDepositModel = /** Representation of a property details related to deposit */\n{type?: (/** The type of deposit (weeks/months/fixed) */\nstring) | null | undefined, amount?: (/** The deposit amount. This can be the number of weeks or months rent or a monetary amount based on the `type` */\nnumber) | null | undefined};",
  "src/schemas/propertyLettingRentInsuranceModel.generated.tsx": "import { z } from 'zod'\n\nexport const propertyLettingRentInsuranceModel = /** Representation of property details specific to rent insurance associated with a lettings property */\nz.object({status: /** Status indicating whether or not rent protection insurance has been taken out (notAsked/cancelled/declined/quoted/taken) */\nz.string().optional().nullable(), referenceNumber: /** The reference number of the insurance policy when rent protection insurance has been taken out */\nz.string().optional().nullable(), start: /** The insurance policy start date */\nz.string().optional().nullable(), end: /** The insurance policy end date */\nz.string().optional().nullable(), cancelledReasonId: /** The identifier of the reason the insurance policy was cancelled, to be used in conjunction with the relevant configuration API endpoint */\nz.string().optional().nullable(), cancelledComment: /** A textual comment or note entered by the agent when an insurance policy was cancelled */\nz.string().optional().nullable(), autoRenew: /** Flag indicating whether or not the insurance policy should auto renew */\nz.boolean().optional().nullable()});\nexport type PropertyLettingRentInsuranceModel = /** Representation of property details specific to rent insurance associated with a lettings property */\n{status?: (/** Status indicating whether or not rent protection insurance has been taken out (notAsked/cancelled/declined/quoted/taken) */\nstring) | null | undefined, referenceNumber?: (/** The reference number of the insurance policy when rent protection insurance has been taken out */\nstring) | null | undefined, start?: (/** The insurance policy start date */\nstring) | null | undefined, end?: (/** The insurance policy end date */\nstring) | null | undefined, cancelledReasonId?: (/** The identifier of the reason the insurance policy was cancelled, to be used in conjunction with the relevant configuration API endpoint */\nstring) | null | undefined, cancelledComment?: (/** A textual comment or note entered by the agent when an insurance policy was cancelled */\nstring) | null | undefined, autoRenew?: (/** Flag indicating whether or not the insurance policy should auto renew */\nboolean) | null | undefined};",
  "src/schemas/propertyLettingLicencingModel.generated.tsx": "import { z } from 'zod'\nimport { propertyLettingLicenceApplicationModel, PropertyLettingLicenceApplicationModel } from '@/schemas/propertyLettingLicenceApplicationModel.generated.tsx'\n\nexport const propertyLettingLicencingModel = /** Representation of property details specific to property Licencing */\nz.object({licenceRequired: /** A flag determining whether or not a licence is required to let the property. Typically required for houses of multiple occupancy (HMOs) */\nz.boolean().optional().nullable(), licenceType: /** The type of licence (additional/mandatory/none/notSet/selective) */\nz.string().optional().nullable(), households: /** The number of households that the licence permits in the property */\nz.number().int().optional().nullable(), occupants: /** The number of occupants that the licence permits in the property */\nz.number().int().optional().nullable(), aboveCommercialPremises: /** A flag determining whether or not the property is above commercial premises */\nz.boolean().optional().nullable(), application: propertyLettingLicenceApplicationModel.optional().nullable()});\nexport type PropertyLettingLicencingModel = /** Representation of property details specific to property Licencing */\n{licenceRequired?: (/** A flag determining whether or not a licence is required to let the property. Typically required for houses of multiple occupancy (HMOs) */\nboolean) | null | undefined, licenceType?: (/** The type of licence (additional/mandatory/none/notSet/selective) */\nstring) | null | undefined, households?: (/** The number of households that the licence permits in the property */\nnumber) | null | undefined, occupants?: (/** The number of occupants that the licence permits in the property */\nnumber) | null | undefined, aboveCommercialPremises?: (/** A flag determining whether or not the property is above commercial premises */\nboolean) | null | undefined, application?: (PropertyLettingLicenceApplicationModel) | null | undefined};",
  "src/schemas/propertyLettingLicenceApplicationModel.generated.tsx": "import { z } from 'zod'\n\nexport const propertyLettingLicenceApplicationModel = /** Representation of property details specific to property licence application */\nz.object({status: /** The status of the licence application (applied/granted/landlordApplying/notApplicable) */\nz.string().optional().nullable(), referenceNumber: /** The licence application reference number */\nz.string().optional().nullable(), date: /** The date the licence was applied for */\nz.string().optional().nullable(), granted: /** The date the licence application was granted */\nz.string().optional().nullable(), expiry: /** The date the licence will expire */\nz.string().optional().nullable()});\nexport type PropertyLettingLicenceApplicationModel = /** Representation of property details specific to property licence application */\n{status?: (/** The status of the licence application (applied/granted/landlordApplying/notApplicable) */\nstring) | null | undefined, referenceNumber?: (/** The licence application reference number */\nstring) | null | undefined, date?: (/** The date the licence was applied for */\nstring) | null | undefined, granted?: (/** The date the licence application was granted */\nstring) | null | undefined, expiry?: (/** The date the licence will expire */\nstring) | null | undefined};",
  "src/schemas/propertyCommercialModel.generated.tsx": "import { z } from 'zod'\n\nexport const propertyCommercialModel = /** An properties commercial details */\nz.object({useClass: /** The commercial use attributes (eg a1, a2, b1), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(z.string().min(1)).optional().nullable(), floorLevel: /** The commercial floor level attributes (eg basement, subGround, ground, upperFloor), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(z.string().min(1)).optional().nullable()});\nexport type PropertyCommercialModel = /** An properties commercial details */\n{useClass?: (/** The commercial use attributes (eg a1, a2, b1), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<string>) | null | undefined, floorLevel?: (/** The commercial floor level attributes (eg basement, subGround, ground, upperFloor), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<string>) | null | undefined};",
  "src/schemas/propertyRegionalModel.generated.tsx": "import { z } from 'zod'\nimport { guernseyModel, GuernseyModel } from '@/schemas/guernseyModel.generated.tsx'\nimport { irelandPropertyModel, IrelandPropertyModel } from '@/schemas/irelandPropertyModel.generated.tsx'\n\nexport const propertyRegionalModel = /** Details relating to the real estate market in specific countries. Child models are named based on the ISO3166 country code that the data inside the model relates to */\nz.object({ggy: guernseyModel.optional().nullable(), irl: irelandPropertyModel.optional().nullable()});\nexport type PropertyRegionalModel = /** Details relating to the real estate market in specific countries. Child models are named based on the ISO3166 country code that the data inside the model relates to */\n{ggy?: (GuernseyModel) | null | undefined, irl?: (IrelandPropertyModel) | null | undefined};",
  "src/schemas/guernseyModel.generated.tsx": "import { z } from 'zod'\n\nexport const guernseyModel = /** Any specific details relating to the marketing of a property in Guernsey */\nz.object({market: /** Attributes describing which markets the property is available in (local/openA/openB/openC/openD) */\nz.array(z.string().min(1)).optional().nullable()});\nexport type GuernseyModel = /** Any specific details relating to the marketing of a property in Guernsey */\n{market?: (/** Attributes describing which markets the property is available in (local/openA/openB/openC/openD) */\nArray<string>) | null | undefined};",
  "src/schemas/irelandPropertyModel.generated.tsx": "import { z } from 'zod'\nimport { irelandPropertyBERModel, IrelandPropertyBERModel } from '@/schemas/irelandPropertyBERModel.generated.tsx'\n\nexport const irelandPropertyModel = /** Any specific details relating to the marketing of a property in Ireland */\nz.object({buildingEnergyRating: irelandPropertyBERModel.optional().nullable()});\nexport type IrelandPropertyModel = /** Any specific details relating to the marketing of a property in Ireland */\n{buildingEnergyRating?: (IrelandPropertyBERModel) | null | undefined};",
  "src/schemas/irelandPropertyBERModel.generated.tsx": "import { z } from 'zod'\n\nexport const irelandPropertyBERModel = /** Any specific details relating to energy performance ratings for properties marketed in Ireland */\nz.object({exempt: /** A flag denoting whether or not this property is exempt from requiring a Building Energy Rating (BER) certificate */\nz.boolean().optional().nullable(), rating: /** The BER rating of the property */\nz.string().optional().nullable(), refNumber: /** The BER certificate reference number */\nz.string().optional().nullable(), epi: /** The energy performance indicator for the property */\nz.string().optional().nullable()});\nexport type IrelandPropertyBERModel = /** Any specific details relating to energy performance ratings for properties marketed in Ireland */\n{exempt?: (/** A flag denoting whether or not this property is exempt from requiring a Building Energy Rating (BER) certificate */\nboolean) | null | undefined, rating?: (/** The BER rating of the property */\nstring) | null | undefined, refNumber?: (/** The BER certificate reference number */\nstring) | null | undefined, epi?: (/** The energy performance indicator for the property */\nstring) | null | undefined};",
  "src/schemas/unmappedAttributeModel.generated.tsx": "import { z } from 'zod'\n\nexport const unmappedAttributeModel = /** Represents an unmapped attribute type */\nz.object({type: /** The type of unmapped attribute (style/type/situation/parking/age/locality/special) */\nz.string().optional().nullable(), value: /** The value associated to the unmapped type */\nz.string().optional().nullable()});\nexport type UnmappedAttributeModel = /** Represents an unmapped attribute type */\n{type?: (/** The type of unmapped attribute (style/type/situation/parking/age/locality/special) */\nstring) | null | undefined, value?: (/** The value associated to the unmapped type */\nstring) | null | undefined};",
  "src/schemas/propertyRoomModel.generated.tsx": "import { z } from 'zod'\n\nexport const propertyRoomModel = /** Representation of a single room in a property */\nz.object({name: /** The name of the room */\nz.string().optional().nullable(), dimensions: /** Details about the dimensions of the room */\nz.string().optional().nullable(), dimensionsAlt: /** Details about the alternate dimensions of the room */\nz.string().optional().nullable(), description: /** Short description of the room */\nz.string().optional().nullable()});\nexport type PropertyRoomModel = /** Representation of a single room in a property */\n{name?: (/** The name of the room */\nstring) | null | undefined, dimensions?: (/** Details about the dimensions of the room */\nstring) | null | undefined, dimensionsAlt?: (/** Details about the alternate dimensions of the room */\nstring) | null | undefined, description?: (/** Short description of the room */\nstring) | null | undefined};",
  "src/sections/Properties/forms/CreateProperties.example.tsx": "import { CreatePropertiesForm, fieldNames, CreatePropertiesFormFields } from '@/sections/Properties/forms/CreatePropertiesForm.generated.tsx'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateProperties = () => {\n      \n\n      \n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreatePropertiesForm >\n              <FormLayout>\n                <CreatePropertiesFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreatePropertiesForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Properties/forms/CreatePropertiesForm.generated.tsx": "import { CreateApiPropertiesBody, createApiPropertiesBody } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { createPropertiesConfig } from '@/sections/Properties/config/createPropertiesConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiProperties } from '@/sections/Properties/services/useCreateApiProperties.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreatePropertiesFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiPropertiesBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createPropertiesConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreatePropertiesFormProps = {children: ReactNode, defaultValues?: CreateApiPropertiesBody, onSuccess?: () => void};\nexport const CreatePropertiesForm = (props: CreatePropertiesFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiPropertiesBody>({\n        resolver: zodResolver(createApiPropertiesBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiProperties()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiPropertiesBody>({lastCall: true, nextCall: true, marketingMode: true, departmentId: true, strapline: true, description: true, summary: true, alternateId: true, specialFeatures: true, address: true, bedrooms: true, bedroomsMax: true, numberOfUnits: true, receptions: true, receptionsMax: true, bathrooms: true, bathroomsMax: true, parkingSpaces: true, councilTax: true, internetAdvertising: true, viewingArrangements: true, videoUrl: true, videoCaption: true, video2Url: true, video2Caption: true, notes: true, longDescription: true, floorLevel: true, internalFloors: true, totalFloors: true, boardStatus: true, boardNotes: true, boardUpdated: true, valuation: true, epc: true, externalArea: true, internalArea: true, rural: true, selling: true, letting: true, regional: true, type: true, style: true, situation: true, parking: true, age: true, locality: true, rooms: true, roomDetailsApproved: true, negotiatorId: true, officeIds: true, areaId: true, url: true, urlCaption: true, groundRent: true, groundRentComment: true, groundRentReviewDate: true, groundRentIncrease: true, serviceCharge: true, serviceChargeComment: true, metadata: true});",
  "src/schemas/createPropertyModel.generated.tsx": "import { CreatePropertyAddressModel, createPropertyAddressModel } from '@/schemas/createPropertyAddressModel.generated.tsx'\nimport { CreatePropertyEpcModel, createPropertyEpcModel } from '@/schemas/createPropertyEpcModel.generated.tsx'\nimport { CreatePropertyExternalAreaModel, createPropertyExternalAreaModel } from '@/schemas/createPropertyExternalAreaModel.generated.tsx'\nimport { CreatePropertyInternalAreaModel, createPropertyInternalAreaModel } from '@/schemas/createPropertyInternalAreaModel.generated.tsx'\nimport { CreatePropertyRuralModel, createPropertyRuralModel } from '@/schemas/createPropertyRuralModel.generated.tsx'\nimport { CreatePropertySellingModel, createPropertySellingModel } from '@/schemas/createPropertySellingModel.generated.tsx'\nimport { CreatePropertyLettingModel, createPropertyLettingModel } from '@/schemas/createPropertyLettingModel.generated.tsx'\nimport { CreatePropertyRegionalModel, createPropertyRegionalModel } from '@/schemas/createPropertyRegionalModel.generated.tsx'\nimport { CreatePropertyRoomModel, createPropertyRoomModel } from '@/schemas/createPropertyRoomModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type CreatePropertyModel = /** Request body used to create a new property */\n{lastCall?: (/** The date the owner of the property was last called */\nstring) | null | undefined, nextCall?: (/** The date the owner of the property is next due to be called */\nstring) | null | undefined, marketingMode: /** The marketing mode of the property (selling/letting/sellingAndLetting) */\nstring, departmentId: /** The unique identifier of the department the property is associated with. The property will only match to applicants with the same values set. See the [Platform Glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information about departments */\nstring, strapline?: (/** The strapline description containing a short summary about the property */\nstring) | null | undefined, description?: (/** The brief description of the property */\nstring) | null | undefined, summary?: (/** The summary of accommodation, typically short phrases or bullet points describing the key features of the property */\nstring) | null | undefined, alternateId?: (/** An optional alternative identifier specified for this property */\nstring) | null | undefined, specialFeatures?: (/** The property's special feature property requirements (eg Swimming Pool, Tennis Court), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<string>) | null | undefined, address: CreatePropertyAddressModel, bedrooms?: (/** The total number of bedrooms in the property */\nnumber) | null | undefined, bedroomsMax?: (/** The maximum number of bedrooms in the property */\nnumber) | null | undefined, numberOfUnits?: (/** The number of units offered on the market. This is typically used when marketing development sites. */\nnumber) | null | undefined, receptions?: (/** The total number of reception rooms in the property */\nnumber) | null | undefined, receptionsMax?: (/** The maximum number of reception rooms in the property */\nnumber) | null | undefined, bathrooms?: (/** The total number of bathrooms in the property */\nnumber) | null | undefined, bathroomsMax?: (/** The maximum number of bathrooms in the property */\nnumber) | null | undefined, parkingSpaces?: (/** The total number of parking spaces the property has. This is only supported by some departments. Please refer to the glossary for support [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nnumber) | null | undefined, councilTax?: (/** The council tax banding of the property (A/B/C/D/E/F/G/H/I/notYetAvailable) */\nstring) | null | undefined, internetAdvertising?: (/** A flag denoting whether or not this property can be advertised on the internet */\nboolean) | null | undefined, viewingArrangements?: (/** The arrangements regarding viewing the property */\nstring) | null | undefined, videoUrl?: (/** The url of a video associated with this property, such as a virtual tour */\nstring) | null | undefined, videoCaption?: (/** The caption for the video url associated with this property */\nstring) | null | undefined, video2Url?: (/** The url of a second video associated with this property, such as a virtual tour */\nstring) | null | undefined, video2Caption?: (/** The caption for the second video url associated with this property */\nstring) | null | undefined, notes?: (/** Any general notes regarding the property. These are not usually exposed to end users and may contain sensitive information about a sale */\nstring) | null | undefined, longDescription?: (/** The long description of the property */\nstring) | null | undefined, floorLevel?: (/** The floor level the property is on. Note that this field can only be set when certain configuration settings are enabled on the property's department. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nnumber) | null | undefined, internalFloors?: (/** The number of internal floors the property has. Note that this field can only be set when certain configuration settings are enabled on the property's department. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nnumber) | null | undefined, totalFloors?: (/** The total number of floors the property has. Note that this field can only be set when certain configuration settings are enabled on the property's department. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nnumber) | null | undefined, boardStatus?: (/** The status of the advertising board sited outside or near to the property */\nstring) | null | undefined, boardNotes?: (/** Any notes relevant to the advertising board sited outside or near to the property */\nstring) | null | undefined, boardUpdated?: (/** The date the advertising board was last updated (or should be updated when the date is in the future) */\nstring) | null | undefined, valuation?: (/** The date on which the property was valued. Note that this can differ to physical appointment dates in some cases */\nstring) | null | undefined, epc?: (CreatePropertyEpcModel) | null | undefined, externalArea?: (CreatePropertyExternalAreaModel) | null | undefined, internalArea?: (CreatePropertyInternalAreaModel) | null | undefined, rural?: (CreatePropertyRuralModel) | null | undefined, selling?: (CreatePropertySellingModel) | null | undefined, letting?: (CreatePropertyLettingModel) | null | undefined, regional?: (CreatePropertyRegionalModel) | null | undefined, type?: (/** The attributes describing the overall type of the property (eg house, bungalow, land), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<string>) | null | undefined, style?: (/** The attributes describing the style of property (eg detached, semiDetached), defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<string>) | null | undefined, situation?: (/** The attributes describing other aspects of the property - such as outside space - as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<string>) | null | undefined, parking?: (/** The attributes describing the parking available at the property (eg garage), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<string>) | null | undefined, age?: (/** The attributes describing the age of the property (eg new, period), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<string>) | null | undefined, locality?: (/** The attributes describing the general location of the property (eg rural, townCity), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<string>) | null | undefined, rooms?: (/** Details of each room in the property */\nArray<CreatePropertyRoomModel>) | null | undefined, roomDetailsApproved?: (/** A flag determining whether or not the property's room details have been approved by the vendor or landlord */\nboolean) | null | undefined, negotiatorId: /** The unique identifier of the negotiator managing the property */\nstring, officeIds: /** A collection of unique identifiers of offices attached to the property. The first item in the collection is considered the primary office */\nArray<string>, areaId?: (/** The unique identifier of the area that the property resides in */\nstring) | null | undefined, url?: (/** The url to the property on an external website */\nstring) | null | undefined, urlCaption?: (/** The caption to accompany the url to the property on an external website */\nstring) | null | undefined, groundRent?: (/** Any ground rent payment that applies to the property */\nnumber) | null | undefined, groundRentComment?: (/** Comments regarding the ground rent of the property */\nstring) | null | undefined, groundRentReviewDate?: (/** The date when the ground rent payable on the property should be reviewed */\nDate) | null | undefined, groundRentIncrease?: (/** The annual percentage increase of the ground rent after being reviewed */\nnumber) | null | undefined, serviceCharge?: (/** Any service charge payment that applies to the property */\nnumber) | null | undefined, serviceChargeComment?: (/** Comments regarding the service charge of the property */\nstring) | null | undefined, metadata?: (/** App specific metadata to set against the property */\nRecord<string, Record<string, never>>) | null | undefined};\nexport const createPropertyModel = /** Request body used to create a new property */\nz.object({lastCall: /** The date the owner of the property was last called */\nz.string().optional().nullable(), nextCall: /** The date the owner of the property is next due to be called */\nz.string().optional().nullable(), marketingMode: /** The marketing mode of the property (selling/letting/sellingAndLetting) */\nz.string().min(1), departmentId: /** The unique identifier of the department the property is associated with. The property will only match to applicants with the same values set. See the [Platform Glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information about departments */\nz.string().min(1), strapline: /** The strapline description containing a short summary about the property */\nz.string().optional().nullable(), description: /** The brief description of the property */\nz.string().optional().nullable(), summary: /** The summary of accommodation, typically short phrases or bullet points describing the key features of the property */\nz.string().optional().nullable(), alternateId: /** An optional alternative identifier specified for this property */\nz.string().optional().nullable(), specialFeatures: /** The property's special feature property requirements (eg Swimming Pool, Tennis Court), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(z.string().min(1)).optional().nullable(), address: createPropertyAddressModel, bedrooms: /** The total number of bedrooms in the property */\nz.number().int().optional().nullable(), bedroomsMax: /** The maximum number of bedrooms in the property */\nz.number().int().optional().nullable(), numberOfUnits: /** The number of units offered on the market. This is typically used when marketing development sites. */\nz.number().int().optional().nullable(), receptions: /** The total number of reception rooms in the property */\nz.number().int().optional().nullable(), receptionsMax: /** The maximum number of reception rooms in the property */\nz.number().int().optional().nullable(), bathrooms: /** The total number of bathrooms in the property */\nz.number().int().optional().nullable(), bathroomsMax: /** The maximum number of bathrooms in the property */\nz.number().int().optional().nullable(), parkingSpaces: /** The total number of parking spaces the property has. This is only supported by some departments. Please refer to the glossary for support [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.number().int().optional().nullable(), councilTax: /** The council tax banding of the property (A/B/C/D/E/F/G/H/I/notYetAvailable) */\nz.string().optional().nullable(), internetAdvertising: /** A flag denoting whether or not this property can be advertised on the internet */\nz.boolean().optional().nullable(), viewingArrangements: /** The arrangements regarding viewing the property */\nz.string().optional().nullable(), videoUrl: /** The url of a video associated with this property, such as a virtual tour */\nz.string().optional().nullable(), videoCaption: /** The caption for the video url associated with this property */\nz.string().optional().nullable(), video2Url: /** The url of a second video associated with this property, such as a virtual tour */\nz.string().optional().nullable(), video2Caption: /** The caption for the second video url associated with this property */\nz.string().optional().nullable(), notes: /** Any general notes regarding the property. These are not usually exposed to end users and may contain sensitive information about a sale */\nz.string().optional().nullable(), longDescription: /** The long description of the property */\nz.string().optional().nullable(), floorLevel: /** The floor level the property is on. Note that this field can only be set when certain configuration settings are enabled on the property's department. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nz.number().int().optional().nullable(), internalFloors: /** The number of internal floors the property has. Note that this field can only be set when certain configuration settings are enabled on the property's department. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nz.number().int().optional().nullable(), totalFloors: /** The total number of floors the property has. Note that this field can only be set when certain configuration settings are enabled on the property's department. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nz.number().int().optional().nullable(), boardStatus: /** The status of the advertising board sited outside or near to the property */\nz.string().optional().nullable(), boardNotes: /** Any notes relevant to the advertising board sited outside or near to the property */\nz.string().optional().nullable(), boardUpdated: /** The date the advertising board was last updated (or should be updated when the date is in the future) */\nz.string().optional().nullable(), valuation: /** The date on which the property was valued. Note that this can differ to physical appointment dates in some cases */\nz.string().optional().nullable(), epc: createPropertyEpcModel.optional().nullable(), externalArea: createPropertyExternalAreaModel.optional().nullable(), internalArea: createPropertyInternalAreaModel.optional().nullable(), rural: createPropertyRuralModel.optional().nullable(), selling: createPropertySellingModel.optional().nullable(), letting: createPropertyLettingModel.optional().nullable(), regional: createPropertyRegionalModel.optional().nullable(), type: /** The attributes describing the overall type of the property (eg house, bungalow, land), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(z.string().min(1)).optional().nullable(), style: /** The attributes describing the style of property (eg detached, semiDetached), defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(z.string().min(1)).optional().nullable(), situation: /** The attributes describing other aspects of the property - such as outside space - as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(z.string().min(1)).optional().nullable(), parking: /** The attributes describing the parking available at the property (eg garage), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(z.string().min(1)).optional().nullable(), age: /** The attributes describing the age of the property (eg new, period), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(z.string().min(1)).optional().nullable(), locality: /** The attributes describing the general location of the property (eg rural, townCity), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(z.string().min(1)).optional().nullable(), rooms: /** Details of each room in the property */\nz.array(createPropertyRoomModel).optional().nullable(), roomDetailsApproved: /** A flag determining whether or not the property's room details have been approved by the vendor or landlord */\nz.boolean().optional().nullable(), negotiatorId: /** The unique identifier of the negotiator managing the property */\nz.string().min(1), officeIds: /** A collection of unique identifiers of offices attached to the property. The first item in the collection is considered the primary office */\nz.array(z.string().min(1)), areaId: /** The unique identifier of the area that the property resides in */\nz.string().optional().nullable(), url: /** The url to the property on an external website */\nz.string().optional().nullable(), urlCaption: /** The caption to accompany the url to the property on an external website */\nz.string().optional().nullable(), groundRent: /** Any ground rent payment that applies to the property */\nz.number().optional().nullable(), groundRentComment: /** Comments regarding the ground rent of the property */\nz.string().optional().nullable(), groundRentReviewDate: /** The date when the ground rent payable on the property should be reviewed */\nz.string().pipe( z.coerce.date() ).optional().nullable(), groundRentIncrease: /** The annual percentage increase of the ground rent after being reviewed */\nz.number().optional().nullable(), serviceCharge: /** Any service charge payment that applies to the property */\nz.number().optional().nullable(), serviceChargeComment: /** Comments regarding the service charge of the property */\nz.string().optional().nullable(), metadata: /** App specific metadata to set against the property */\nz.record(z.string(), z.object({})).optional().nullable()});",
  "src/schemas/createPropertyAddressModel.generated.tsx": "import { CreatePropertyGeolocationModel, createPropertyGeolocationModel } from '@/schemas/createPropertyGeolocationModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type CreatePropertyAddressModel = /** Request body used to set the address of a new property */\n{buildingName?: (/** The building name */\nstring) | null | undefined, buildingNumber?: (/** The building number */\nstring) | null | undefined, line1: /** The first line of the address */\nstring, line2?: (/** The second line of the address */\nstring) | null | undefined, line3?: (/** The third line of the address */\nstring) | null | undefined, line4?: (/** The fourth line of the address */\nstring) | null | undefined, postcode?: (/** The postcode */\nstring) | null | undefined, countryId?: (/** The ISO-3166 country code that the address resides within */\nstring) | null | undefined, geolocation?: (CreatePropertyGeolocationModel) | null | undefined};\nexport const createPropertyAddressModel = /** Request body used to set the address of a new property */\nz.object({buildingName: /** The building name */\nz.string().optional().nullable(), buildingNumber: /** The building number */\nz.string().optional().nullable(), line1: /** The first line of the address */\nz.string().min(1), line2: /** The second line of the address */\nz.string().optional().nullable(), line3: /** The third line of the address */\nz.string().optional().nullable(), line4: /** The fourth line of the address */\nz.string().optional().nullable(), postcode: /** The postcode */\nz.string().optional().nullable(), countryId: /** The ISO-3166 country code that the address resides within */\nz.string().optional().nullable(), geolocation: createPropertyGeolocationModel.optional().nullable()});",
  "src/schemas/createPropertyGeolocationModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreatePropertyGeolocationModel = /** Request body used to set the geolocation coordinates of a new property's address */\n{latitude: /** The latitude coordinate of the coordinate pair */\nnumber, longitude: /** The longitude coordinate of the coordinate pair */\nnumber};\nexport const createPropertyGeolocationModel = /** Request body used to set the geolocation coordinates of a new property's address */\nz.object({latitude: /** The latitude coordinate of the coordinate pair */\nz.number(), longitude: /** The longitude coordinate of the coordinate pair */\nz.number()});",
  "src/schemas/createPropertyEpcModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreatePropertyEpcModel = /** Request body used to set the EPC statistic of a new property */\n{exempt?: (/** A flag denoting whether or not this property is exempt from requiring an EPC certificate */\nboolean) | null | undefined, eer?: (/** The current energy efficiency rating */\nnumber) | null | undefined, eerPotential?: (/** The potential energy efficiency rating */\nnumber) | null | undefined, eir?: (/** The current environmental impact rating */\nnumber) | null | undefined, eirPotential?: (/** The potential environmental impact rating */\nnumber) | null | undefined, fullDocumentUrl?: (/** The URL to access the full EPC document */\nstring) | null | undefined, firstPageDocumentUrl?: (/** The URL to access the first page of the EPC document */\nstring) | null | undefined};\nexport const createPropertyEpcModel = /** Request body used to set the EPC statistic of a new property */\nz.object({exempt: /** A flag denoting whether or not this property is exempt from requiring an EPC certificate */\nz.boolean().optional().nullable(), eer: /** The current energy efficiency rating */\nz.number().int().optional().nullable(), eerPotential: /** The potential energy efficiency rating */\nz.number().int().optional().nullable(), eir: /** The current environmental impact rating */\nz.number().int().optional().nullable(), eirPotential: /** The potential environmental impact rating */\nz.number().int().optional().nullable(), fullDocumentUrl: /** The URL to access the full EPC document */\nz.string().optional().nullable(), firstPageDocumentUrl: /** The URL to access the first page of the EPC document */\nz.string().optional().nullable()});",
  "src/schemas/createPropertyExternalAreaModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreatePropertyExternalAreaModel = /** Request body to set the external land area of a new property */\n{type?: (/** The unit of area (acres/hectares) */\nstring) | null | undefined, min?: (/** The minimum area bound */\nnumber) | null | undefined, max?: (/** The maximum area bound (please note there is no corresponding field in the Reapit CRM) */\nnumber) | null | undefined};\nexport const createPropertyExternalAreaModel = /** Request body to set the external land area of a new property */\nz.object({type: /** The unit of area (acres/hectares) */\nz.string().optional().nullable(), min: /** The minimum area bound */\nz.number().optional().nullable(), max: /** The maximum area bound (please note there is no corresponding field in the Reapit CRM) */\nz.number().optional().nullable()});",
  "src/schemas/createPropertyInternalAreaModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreatePropertyInternalAreaModel = /** Request body to set the internal dimensions of a new property */\n{type?: (/** The unit of area (squareFeet/squareMetres) */\nstring) | null | undefined, min?: (/** The minimum area bound */\nnumber) | null | undefined, max?: (/** The maximum area bound */\nnumber) | null | undefined};\nexport const createPropertyInternalAreaModel = /** Request body to set the internal dimensions of a new property */\nz.object({type: /** The unit of area (squareFeet/squareMetres) */\nz.string().optional().nullable(), min: /** The minimum area bound */\nz.number().optional().nullable(), max: /** The maximum area bound */\nz.number().optional().nullable()});",
  "src/schemas/createPropertyRuralModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreatePropertyRuralModel = /** Request body used to set details specific to rural properties */\n{buildingsDescription?: (/** Details of the buildings associated with the property. */\nstring) | null | undefined, landDescription?: (/** Details of the land associated with the property. */\nstring) | null | undefined};\nexport const createPropertyRuralModel = /** Request body used to set details specific to rural properties */\nz.object({buildingsDescription: /** Details of the buildings associated with the property. */\nz.string().optional().nullable(), landDescription: /** Details of the land associated with the property. */\nz.string().optional().nullable()});",
  "src/schemas/createPropertySellingModel.generated.tsx": "import { CreatePropertyTenureModel, createPropertyTenureModel } from '@/schemas/createPropertyTenureModel.generated.tsx'\nimport { CreatePropertyCommissionFeeModel, createPropertyCommissionFeeModel } from '@/schemas/createPropertyCommissionFeeModel.generated.tsx'\nimport { CreatePropertySharedOwnershipModel, createPropertySharedOwnershipModel } from '@/schemas/createPropertySharedOwnershipModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type CreatePropertySellingModel = /** Request body used to set details specific to sales marketing on a new property. When creating a new sales property, a vendor record is automatically created. Please refer to the [Platform Glossary](http://foundations.link/glossary#vendor) for full details */\n{instructed?: (/** The date that the property was marked as for sale */\nstring) | null | undefined, price?: (/** The marketing price of the property */\nnumber) | null | undefined, reservationFee?: (/** The fee charged by the agent to reserve a property (typically a new build) */\nnumber) | null | undefined, qualifier?: (/** The price qualifier (askingPrice/priceOnApplication/guidePrice/offersInRegion/offersOver/offersInExcess/fixedPrice/priceReducedTo) */\nstring) | null | undefined, status?: (/** The current status of the sale (preAppraisal/valuation/paidValuation/forSale/forSaleUnavailable/underOffer/underOfferUnavailable/reserved/exchanged/completed/soldExternally/withdrawn) */\nstring) | null | undefined, disposal?: (/** The method used to sell the property (auction/confidential/tender/offersInvited/privateTreaty/sharedOwnership) */\nstring) | null | undefined, completed?: (/** The date the property sale was completed */\nstring) | null | undefined, exchanged?: (/** The date the property was exchanged */\nstring) | null | undefined, accountPaid?: (/** The date the property account was paid */\nstring) | null | undefined, tenure?: (CreatePropertyTenureModel) | null | undefined, sellingAgency?: (/** The selling agency type (marketingForAssociate/clientsOnly/comparable/subAgent/jointSole/jointSoleFeeAvailable/multiple/multipleFeeAvailable/ownToSell/soleSellingRights/soleSellingRightsFeeAvailable/soleAgent/soleAgentFeeAvailable) */\nstring) | null | undefined, agencyId?: (/** The unique identifier of the custom selling agency type - only applicable when SellingAgency is not set */\nstring) | null | undefined, agreementExpiry?: (/** The date on which the agreement between the vendor and agent expires */\nstring) | null | undefined, fee?: (CreatePropertyCommissionFeeModel) | null | undefined, recommendedPrice?: (/** The agent's recommended asking price */\nnumber) | null | undefined, valuationPrice?: (/** The agent's valuation price */\nnumber) | null | undefined, decoration?: (/** The property's decorative condition (unmodernised/fair/good/veryGood) */\nArray<string>) | null | undefined, sharedOwnership?: (CreatePropertySharedOwnershipModel) | null | undefined};\nexport const createPropertySellingModel = /** Request body used to set details specific to sales marketing on a new property. When creating a new sales property, a vendor record is automatically created. Please refer to the [Platform Glossary](http://foundations.link/glossary#vendor) for full details */\nz.object({instructed: /** The date that the property was marked as for sale */\nz.string().optional().nullable(), price: /** The marketing price of the property */\nz.number().int().optional().nullable(), reservationFee: /** The fee charged by the agent to reserve a property (typically a new build) */\nz.number().int().optional().nullable(), qualifier: /** The price qualifier (askingPrice/priceOnApplication/guidePrice/offersInRegion/offersOver/offersInExcess/fixedPrice/priceReducedTo) */\nz.string().optional().nullable(), status: /** The current status of the sale (preAppraisal/valuation/paidValuation/forSale/forSaleUnavailable/underOffer/underOfferUnavailable/reserved/exchanged/completed/soldExternally/withdrawn) */\nz.string().optional().nullable(), disposal: /** The method used to sell the property (auction/confidential/tender/offersInvited/privateTreaty/sharedOwnership) */\nz.string().optional().nullable(), completed: /** The date the property sale was completed */\nz.string().optional().nullable(), exchanged: /** The date the property was exchanged */\nz.string().optional().nullable(), accountPaid: /** The date the property account was paid */\nz.string().optional().nullable(), tenure: createPropertyTenureModel.optional().nullable(), sellingAgency: /** The selling agency type (marketingForAssociate/clientsOnly/comparable/subAgent/jointSole/jointSoleFeeAvailable/multiple/multipleFeeAvailable/ownToSell/soleSellingRights/soleSellingRightsFeeAvailable/soleAgent/soleAgentFeeAvailable) */\nz.string().optional().nullable(), agencyId: /** The unique identifier of the custom selling agency type - only applicable when SellingAgency is not set */\nz.string().optional().nullable(), agreementExpiry: /** The date on which the agreement between the vendor and agent expires */\nz.string().optional().nullable(), fee: createPropertyCommissionFeeModel.optional().nullable(), recommendedPrice: /** The agent's recommended asking price */\nz.number().int().optional().nullable(), valuationPrice: /** The agent's valuation price */\nz.number().int().optional().nullable(), decoration: /** The property's decorative condition (unmodernised/fair/good/veryGood) */\nz.array(z.string().min(1)).optional().nullable(), sharedOwnership: createPropertySharedOwnershipModel.optional().nullable()});",
  "src/schemas/createPropertyTenureModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreatePropertyTenureModel = /** Request body used to set the tenure of a new property */\n{type?: (/** The type of tenure that applies to the property (freehold/leasehold/shareOfFreehold/commonhold/tba) */\nstring) | null | undefined, expiry?: (/** The tenure expiration date */\nstring) | null | undefined};\nexport const createPropertyTenureModel = /** Request body used to set the tenure of a new property */\nz.object({type: /** The type of tenure that applies to the property (freehold/leasehold/shareOfFreehold/commonhold/tba) */\nz.string().optional().nullable(), expiry: /** The tenure expiration date */\nz.string().optional().nullable()});",
  "src/schemas/createPropertyCommissionFeeModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreatePropertyCommissionFeeModel = /** Request body used to set the commission fee for a property */\n{type?: (/** The commission letting fee type (percentage/fixed) */\nstring) | null | undefined, amount?: (/** The commission letting fee amount */\nnumber) | null | undefined};\nexport const createPropertyCommissionFeeModel = /** Request body used to set the commission fee for a property */\nz.object({type: /** The commission letting fee type (percentage/fixed) */\nz.string().optional().nullable(), amount: /** The commission letting fee amount */\nz.number().optional().nullable()});",
  "src/schemas/createPropertySharedOwnershipModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreatePropertySharedOwnershipModel = /** Details relating to the shared ownership of the property */\n{sharedPercentage?: (/** The percentage of the shared ownership property being sold by the vendor */\nnumber) | null | undefined, rent?: (/** The rent payable on the remainder of the shared ownership property */\nnumber) | null | undefined, rentFrequency?: (/** The frequency at which the shared ownership rent should be paid */\nstring) | null | undefined};\nexport const createPropertySharedOwnershipModel = /** Details relating to the shared ownership of the property */\nz.object({sharedPercentage: /** The percentage of the shared ownership property being sold by the vendor */\nz.number().optional().nullable(), rent: /** The rent payable on the remainder of the shared ownership property */\nz.number().optional().nullable(), rentFrequency: /** The frequency at which the shared ownership rent should be paid */\nz.string().optional().nullable()});",
  "src/schemas/createPropertyLettingModel.generated.tsx": "import { CreatePropertyCommissionFeeModel, createPropertyCommissionFeeModel } from '@/schemas/createPropertyCommissionFeeModel.generated.tsx'\nimport { CreateUtilityModel, createUtilityModel } from '@/schemas/createUtilityModel.generated.tsx'\nimport { CreatePropertyLettingsDepositModel, createPropertyLettingsDepositModel } from '@/schemas/createPropertyLettingsDepositModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type CreatePropertyLettingModel = /** Request body used to set details specific to lettings marketing on a new property */\n{instructed?: (/** The date the property was marked as to let */\nstring) | null | undefined, availableFrom?: (/** The date the property is available from */\nstring) | null | undefined, availableTo?: (/** The date the property is available to */\nstring) | null | undefined, agreementSigned?: (/** The date the letting agreement between the landlord and agent was signed */\nstring) | null | undefined, rent?: (/** The rent being charged for the property */\nnumber) | null | undefined, rentFrequency?: (/** The frequency at which rent will be collected (weekly/monthly/annually) */\nstring) | null | undefined, rentIncludes?: (/** Details of any bills that are included in the rent */\nstring) | null | undefined, furnishing?: (/** The furnishing state that the property can be offered in (furnished/unfurnished/partFurnished) */\nArray<string>) | null | undefined, agentRole?: (/** The role that the agent will be performing for this lettings property (managed/rentCollection/collectFirstPayment/collectRentToDate/lettingOnly/introducingTenant) */\nstring) | null | undefined, term?: (/** The acceptable letting terms (short/long/any) */\nstring) | null | undefined, status?: (/** The current status of the let (valuation/toLet/toLetUnavailable/underOffer/underOfferUnavailable/arrangingTenancyUnavailable/arrangingTenancy/tenancyCurrentUnavailable/tenancyCurrent/tenancyFinished/tenancyCancelled/sold/letByOtherAgent/letPrivately/provisional/withdrawn) */\nstring) | null | undefined, landlordId?: (/** The unique identifier of the landlord letting the property */\nstring) | null | undefined, worksOrderNote?: (/** A note to accompany any works orders created for the property */\nstring) | null | undefined, minimumTerm?: (/** Sets the minimum number of months the property can be let out for */\nnumber) | null | undefined, managementFee?: (CreatePropertyCommissionFeeModel) | null | undefined, lettingFee?: (CreatePropertyCommissionFeeModel) | null | undefined, qualifier?: (/** The rent qualifier (rentOnApplication/askingRent) */\nstring) | null | undefined, utilities?: (CreateUtilityModel) | null | undefined, deposit?: (CreatePropertyLettingsDepositModel) | null | undefined};\nexport const createPropertyLettingModel = /** Request body used to set details specific to lettings marketing on a new property */\nz.object({instructed: /** The date the property was marked as to let */\nz.string().optional().nullable(), availableFrom: /** The date the property is available from */\nz.string().optional().nullable(), availableTo: /** The date the property is available to */\nz.string().optional().nullable(), agreementSigned: /** The date the letting agreement between the landlord and agent was signed */\nz.string().optional().nullable(), rent: /** The rent being charged for the property */\nz.number().optional().nullable(), rentFrequency: /** The frequency at which rent will be collected (weekly/monthly/annually) */\nz.string().optional().nullable(), rentIncludes: /** Details of any bills that are included in the rent */\nz.string().optional().nullable(), furnishing: /** The furnishing state that the property can be offered in (furnished/unfurnished/partFurnished) */\nz.array(z.string().min(1)).optional().nullable(), agentRole: /** The role that the agent will be performing for this lettings property (managed/rentCollection/collectFirstPayment/collectRentToDate/lettingOnly/introducingTenant) */\nz.string().optional().nullable(), term: /** The acceptable letting terms (short/long/any) */\nz.string().optional().nullable(), status: /** The current status of the let (valuation/toLet/toLetUnavailable/underOffer/underOfferUnavailable/arrangingTenancyUnavailable/arrangingTenancy/tenancyCurrentUnavailable/tenancyCurrent/tenancyFinished/tenancyCancelled/sold/letByOtherAgent/letPrivately/provisional/withdrawn) */\nz.string().optional().nullable(), landlordId: /** The unique identifier of the landlord letting the property */\nz.string().optional().nullable(), worksOrderNote: /** A note to accompany any works orders created for the property */\nz.string().optional().nullable(), minimumTerm: /** Sets the minimum number of months the property can be let out for */\nz.number().int().optional().nullable(), managementFee: createPropertyCommissionFeeModel.optional().nullable(), lettingFee: createPropertyCommissionFeeModel.optional().nullable(), qualifier: /** The rent qualifier (rentOnApplication/askingRent) */\nz.string().optional().nullable(), utilities: createUtilityModel.optional().nullable(), deposit: createPropertyLettingsDepositModel.optional().nullable()});",
  "src/schemas/createUtilityModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateUtilityModel = /** Representation of property details specific to utilities */\n{hasGas?: (/** A flag denoting whether or not the property has gas connected */\nboolean) | null | undefined, gasCompanyId?: (/** The unique identifier of the company supplying the gas to the property */\nstring) | null | undefined, gasMeterPoint?: (/** The gas meter point number */\nstring) | null | undefined, electricityCompanyId?: (/** The unique identifier of the company supplying the electricity to the property */\nstring) | null | undefined, electricityMeterPoint?: (/** The electricity meter point number */\nstring) | null | undefined, waterCompanyId?: (/** The unique identifier of the company supplying the water to the property */\nstring) | null | undefined, waterMeterPoint?: (/** The water meter point number */\nstring) | null | undefined, telephoneCompanyId?: (/** The unique identifier of the company supplying the telephone to the property */\nstring) | null | undefined, internetCompanyId?: (/** The unique identifier of the company supplying the internet to the property */\nstring) | null | undefined, cableTvCompanyId?: (/** The unique identifier of the company supplying the cable tv to the property */\nstring) | null | undefined};\nexport const createUtilityModel = /** Representation of property details specific to utilities */\nz.object({hasGas: /** A flag denoting whether or not the property has gas connected */\nz.boolean().optional().nullable(), gasCompanyId: /** The unique identifier of the company supplying the gas to the property */\nz.string().optional().nullable(), gasMeterPoint: /** The gas meter point number */\nz.string().optional().nullable(), electricityCompanyId: /** The unique identifier of the company supplying the electricity to the property */\nz.string().optional().nullable(), electricityMeterPoint: /** The electricity meter point number */\nz.string().optional().nullable(), waterCompanyId: /** The unique identifier of the company supplying the water to the property */\nz.string().optional().nullable(), waterMeterPoint: /** The water meter point number */\nz.string().optional().nullable(), telephoneCompanyId: /** The unique identifier of the company supplying the telephone to the property */\nz.string().optional().nullable(), internetCompanyId: /** The unique identifier of the company supplying the internet to the property */\nz.string().optional().nullable(), cableTvCompanyId: /** The unique identifier of the company supplying the cable tv to the property */\nz.string().optional().nullable()});",
  "src/schemas/createPropertyLettingsDepositModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreatePropertyLettingsDepositModel = /** Representation of a property details related to deposit */\n{type?: (/** The type of deposit (weeks/months/fixed) */\nstring) | null | undefined, amount?: (/** The deposit amount. This can be the number of weeks or months rent or a monetary amount based on the `type` */\nnumber) | null | undefined};\nexport const createPropertyLettingsDepositModel = /** Representation of a property details related to deposit */\nz.object({type: /** The type of deposit (weeks/months/fixed) */\nz.string().optional().nullable(), amount: /** The deposit amount. This can be the number of weeks or months rent or a monetary amount based on the `type` */\nz.number().optional().nullable()});",
  "src/schemas/createPropertyRegionalModel.generated.tsx": "import { CreateIrelandPropertyModel, createIrelandPropertyModel } from '@/schemas/createIrelandPropertyModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type CreatePropertyRegionalModel = /** Request body used to set region specific property details. Child models are named based on the ISO3166 country code that the data inside the model relates to */\n{irl?: (CreateIrelandPropertyModel) | null | undefined};\nexport const createPropertyRegionalModel = /** Request body used to set region specific property details. Child models are named based on the ISO3166 country code that the data inside the model relates to */\nz.object({irl: createIrelandPropertyModel.optional().nullable()});",
  "src/schemas/createIrelandPropertyModel.generated.tsx": "import { CreateIrelandPropertyBERModel, createIrelandPropertyBERModel } from '@/schemas/createIrelandPropertyBERModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type CreateIrelandPropertyModel = /** Request body used to set the data specific to properties in Ireland */\n{buildingEnergyRating?: (CreateIrelandPropertyBERModel) | null | undefined};\nexport const createIrelandPropertyModel = /** Request body used to set the data specific to properties in Ireland */\nz.object({buildingEnergyRating: createIrelandPropertyBERModel.optional().nullable()});",
  "src/schemas/createIrelandPropertyBERModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateIrelandPropertyBERModel = /** Request body used to set the energy performance rating information for properties in Ireland */\n{exempt?: (/** A flag denoting whether or not this property is exempt from requiring a Building Energy Rating (BER) certificate */\nboolean) | null | undefined, rating?: (/** The BER rating of the property */\nstring) | null | undefined, refNumber?: (/** The BER certificate reference number */\nstring) | null | undefined, epi?: (/** The energy performance indicator for the property */\nstring) | null | undefined};\nexport const createIrelandPropertyBERModel = /** Request body used to set the energy performance rating information for properties in Ireland */\nz.object({exempt: /** A flag denoting whether or not this property is exempt from requiring a Building Energy Rating (BER) certificate */\nz.boolean().optional().nullable(), rating: /** The BER rating of the property */\nz.string().optional().nullable(), refNumber: /** The BER certificate reference number */\nz.string().optional().nullable(), epi: /** The energy performance indicator for the property */\nz.string().optional().nullable()});",
  "src/schemas/createPropertyRoomModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreatePropertyRoomModel = /** Request body to create a room in the Rooms collection of a new property */\n{name?: (/** The name of the room */\nstring) | null | undefined, dimensions?: (/** Details about the dimensions of the room */\nstring) | null | undefined, description?: (/** Short description of the room */\nstring) | null | undefined};\nexport const createPropertyRoomModel = /** Request body to create a room in the Rooms collection of a new property */\nz.object({name: /** The name of the room */\nz.string().optional().nullable(), dimensions: /** Details about the dimensions of the room */\nz.string().optional().nullable(), description: /** Short description of the room */\nz.string().optional().nullable()});",
  "src/sections/Properties/config/createPropertiesConfig.example.tsx": "import { CreateApiPropertiesBody } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { DateInput } from '@/inputs/DateInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { Switch } from '@/inputs/Switch.tsx'\nimport { OfficesInput } from '@/sections/Offices/inputs/OfficesInput.generated.tsx'\nimport { NumberInput } from '@/inputs/NumberInput.tsx'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createPropertiesConfig: ModelConfig<CreateApiPropertiesBody> = {lastCall: {\n      key: 'lastCall',\n      label: 'lastCall',\n      defaultValue: null,\n      placeholder: 'lastCall',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><DateInput {...props} /></InputWrap>\n    }, nextCall: {\n      key: 'nextCall',\n      label: 'nextCall',\n      defaultValue: null,\n      placeholder: 'nextCall',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><DateInput {...props} /></InputWrap>\n    }, marketingMode: {\n      key: 'marketingMode',\n      label: 'marketingMode',\n      defaultValue: '',\n      placeholder: 'marketingMode',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, departmentId: {\n      key: 'departmentId',\n      label: 'departmentId',\n      defaultValue: '',\n      placeholder: 'departmentId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, strapline: {\n      key: 'strapline',\n      label: 'strapline',\n      defaultValue: '',\n      placeholder: 'strapline',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, description: {\n      key: 'description',\n      label: 'description',\n      defaultValue: '',\n      placeholder: 'description',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, summary: {\n      key: 'summary',\n      label: 'summary',\n      defaultValue: '',\n      placeholder: 'summary',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, alternateId: {\n      key: 'alternateId',\n      label: 'alternateId',\n      defaultValue: '',\n      placeholder: 'alternateId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, specialFeatures: {\n      key: 'specialFeatures',\n      label: 'specialFeatures',\n      defaultValue: [],\n      placeholder: 'specialFeatures',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, address: {\n      key: 'address',\n      label: 'address',\n      defaultValue: null,\n      placeholder: 'address',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, bedrooms: {\n      key: 'bedrooms',\n      label: 'bedrooms',\n      defaultValue: null,\n      placeholder: 'bedrooms',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, bedroomsMax: {\n      key: 'bedroomsMax',\n      label: 'bedroomsMax',\n      defaultValue: null,\n      placeholder: 'bedroomsMax',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, numberOfUnits: {\n      key: 'numberOfUnits',\n      label: 'numberOfUnits',\n      defaultValue: null,\n      placeholder: 'numberOfUnits',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, receptions: {\n      key: 'receptions',\n      label: 'receptions',\n      defaultValue: null,\n      placeholder: 'receptions',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, receptionsMax: {\n      key: 'receptionsMax',\n      label: 'receptionsMax',\n      defaultValue: null,\n      placeholder: 'receptionsMax',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, bathrooms: {\n      key: 'bathrooms',\n      label: 'bathrooms',\n      defaultValue: null,\n      placeholder: 'bathrooms',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, bathroomsMax: {\n      key: 'bathroomsMax',\n      label: 'bathroomsMax',\n      defaultValue: null,\n      placeholder: 'bathroomsMax',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, parkingSpaces: {\n      key: 'parkingSpaces',\n      label: 'parkingSpaces',\n      defaultValue: null,\n      placeholder: 'parkingSpaces',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, councilTax: {\n      key: 'councilTax',\n      label: 'councilTax',\n      defaultValue: '',\n      placeholder: 'councilTax',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, internetAdvertising: {\n      key: 'internetAdvertising',\n      label: 'internetAdvertising',\n      defaultValue: false,\n      placeholder: 'internetAdvertising',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><Switch {...props} /></InputWrap>\n    }, viewingArrangements: {\n      key: 'viewingArrangements',\n      label: 'viewingArrangements',\n      defaultValue: '',\n      placeholder: 'viewingArrangements',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, videoUrl: {\n      key: 'videoUrl',\n      label: 'videoUrl',\n      defaultValue: '',\n      placeholder: 'videoUrl',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, videoCaption: {\n      key: 'videoCaption',\n      label: 'videoCaption',\n      defaultValue: '',\n      placeholder: 'videoCaption',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, video2Url: {\n      key: 'video2Url',\n      label: 'video2Url',\n      defaultValue: '',\n      placeholder: 'video2Url',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, video2Caption: {\n      key: 'video2Caption',\n      label: 'video2Caption',\n      defaultValue: '',\n      placeholder: 'video2Caption',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, notes: {\n      key: 'notes',\n      label: 'notes',\n      defaultValue: '',\n      placeholder: 'notes',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, longDescription: {\n      key: 'longDescription',\n      label: 'longDescription',\n      defaultValue: '',\n      placeholder: 'longDescription',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, floorLevel: {\n      key: 'floorLevel',\n      label: 'floorLevel',\n      defaultValue: null,\n      placeholder: 'floorLevel',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, internalFloors: {\n      key: 'internalFloors',\n      label: 'internalFloors',\n      defaultValue: null,\n      placeholder: 'internalFloors',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, totalFloors: {\n      key: 'totalFloors',\n      label: 'totalFloors',\n      defaultValue: null,\n      placeholder: 'totalFloors',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, boardStatus: {\n      key: 'boardStatus',\n      label: 'boardStatus',\n      defaultValue: '',\n      placeholder: 'boardStatus',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, boardNotes: {\n      key: 'boardNotes',\n      label: 'boardNotes',\n      defaultValue: '',\n      placeholder: 'boardNotes',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, boardUpdated: {\n      key: 'boardUpdated',\n      label: 'boardUpdated',\n      defaultValue: null,\n      placeholder: 'boardUpdated',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><DateInput {...props} /></InputWrap>\n    }, valuation: {\n      key: 'valuation',\n      label: 'valuation',\n      defaultValue: null,\n      placeholder: 'valuation',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><DateInput {...props} /></InputWrap>\n    }, epc: {\n      key: 'epc',\n      label: 'epc',\n      defaultValue: null,\n      placeholder: 'epc',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, externalArea: {\n      key: 'externalArea',\n      label: 'externalArea',\n      defaultValue: null,\n      placeholder: 'externalArea',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, internalArea: {\n      key: 'internalArea',\n      label: 'internalArea',\n      defaultValue: null,\n      placeholder: 'internalArea',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, rural: {\n      key: 'rural',\n      label: 'rural',\n      defaultValue: null,\n      placeholder: 'rural',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, selling: {\n      key: 'selling',\n      label: 'selling',\n      defaultValue: null,\n      placeholder: 'selling',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, letting: {\n      key: 'letting',\n      label: 'letting',\n      defaultValue: null,\n      placeholder: 'letting',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, regional: {\n      key: 'regional',\n      label: 'regional',\n      defaultValue: null,\n      placeholder: 'regional',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, type: {\n      key: 'type',\n      label: 'type',\n      defaultValue: [],\n      placeholder: 'type',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, style: {\n      key: 'style',\n      label: 'style',\n      defaultValue: [],\n      placeholder: 'style',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, situation: {\n      key: 'situation',\n      label: 'situation',\n      defaultValue: [],\n      placeholder: 'situation',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, parking: {\n      key: 'parking',\n      label: 'parking',\n      defaultValue: [],\n      placeholder: 'parking',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, age: {\n      key: 'age',\n      label: 'age',\n      defaultValue: [],\n      placeholder: 'age',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, locality: {\n      key: 'locality',\n      label: 'locality',\n      defaultValue: [],\n      placeholder: 'locality',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, rooms: {\n      key: 'rooms',\n      label: 'rooms',\n      defaultValue: [],\n      placeholder: 'rooms',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, roomDetailsApproved: {\n      key: 'roomDetailsApproved',\n      label: 'roomDetailsApproved',\n      defaultValue: false,\n      placeholder: 'roomDetailsApproved',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><Switch {...props} /></InputWrap>\n    }, negotiatorId: {\n      key: 'negotiatorId',\n      label: 'negotiatorId',\n      defaultValue: '',\n      placeholder: 'negotiatorId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, officeIds: {\n      key: 'officeIds',\n      label: 'officeIds',\n      defaultValue: [],\n      placeholder: 'officeIds',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><OfficesInput {...props} /></InputWrap>\n    }, areaId: {\n      key: 'areaId',\n      label: 'areaId',\n      defaultValue: '',\n      placeholder: 'areaId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, url: {\n      key: 'url',\n      label: 'url',\n      defaultValue: '',\n      placeholder: 'url',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, urlCaption: {\n      key: 'urlCaption',\n      label: 'urlCaption',\n      defaultValue: '',\n      placeholder: 'urlCaption',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, groundRent: {\n      key: 'groundRent',\n      label: 'groundRent',\n      defaultValue: null,\n      placeholder: 'groundRent',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><NumberInput {...props} /></InputWrap>\n    }, groundRentComment: {\n      key: 'groundRentComment',\n      label: 'groundRentComment',\n      defaultValue: '',\n      placeholder: 'groundRentComment',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, groundRentReviewDate: {\n      key: 'groundRentReviewDate',\n      label: 'groundRentReviewDate',\n      defaultValue: null,\n      placeholder: 'groundRentReviewDate',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, groundRentIncrease: {\n      key: 'groundRentIncrease',\n      label: 'groundRentIncrease',\n      defaultValue: null,\n      placeholder: 'groundRentIncrease',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><NumberInput {...props} /></InputWrap>\n    }, serviceCharge: {\n      key: 'serviceCharge',\n      label: 'serviceCharge',\n      defaultValue: null,\n      placeholder: 'serviceCharge',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><NumberInput {...props} /></InputWrap>\n    }, serviceChargeComment: {\n      key: 'serviceChargeComment',\n      label: 'serviceChargeComment',\n      defaultValue: '',\n      placeholder: 'serviceChargeComment',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, metadata: {\n      key: 'metadata',\n      label: 'metadata',\n      defaultValue: null,\n      placeholder: 'metadata',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/Properties/services/useCreateApiProperties.generated.ts": "import { CreatePropertyModel } from '@/schemas/createPropertyModel.generated.tsx'\nimport { createApiPropertiesResponse } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiPropertiesFnArgs = {body: CreatePropertyModel};\nexport const createApiPropertiesFn = async ({body}: CreateApiPropertiesFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/properties/${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiPropertiesResponse.parse(data)\n    };\nexport const useCreateApiProperties = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiPropertiesFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Properties']})\n        }\n      })\n    };",
  "src/sections/Properties/tables/PropertiesIdCertificatesTable.generated.tsx": "import { useGetApiPropertiesIdCertificates } from '@/sections/Properties/services/useGetApiPropertiesIdCertificates.generated.ts'\nimport { useState } from 'react'\nimport { useParams, useNavigate } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\n\nexport type UsePropertiesIdCertificatesTableArgs = {id: string, category?: (Array<'safetyCertificate' | 'insurancePolicy' | 'warranty'>) | null | undefined};\nexport const usePropertiesIdCertificatesTable = (args: UsePropertiesIdCertificatesTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiPropertiesIdCertificates({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const PropertiesIdCertificatesTable = () => {\n  const {id} = useParams()\n    \n    invariant(id, 'Missing id param')\n    \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = usePropertiesIdCertificatesTable({id}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Properties',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New propertiesIdCertificatesTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/properties/${id}/certificates/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Properties/services/useGetApiPropertiesIdCertificates.generated.ts": "import { getApiPropertiesIdCertificatesResponse } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiPropertiesIdCertificatesFnArgs = {id: string, pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, category?: (Array<'safetyCertificate' | 'insurancePolicy' | 'warranty'>) | null | undefined};\nexport const getApiPropertiesIdCertificatesFn = async ({id, pageSize, pageNumber, category}: GetApiPropertiesIdCertificatesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/properties/${id}/certificates${querySerialiser({args:{pageSize, pageNumber, category}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiPropertiesIdCertificatesResponse.parse(data)\n    };\nexport const useGetApiPropertiesIdCertificates = ({id, pageSize, pageNumber, category}: GetApiPropertiesIdCertificatesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Properties', id, pageSize, pageNumber, category],\n        queryFn: () => getApiPropertiesIdCertificatesFn({id, pageSize, pageNumber, category}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/schemas/certificateModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { certificateModel, CertificateModel } from '@/schemas/certificateModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const certificateModelPagedResult = z.object({_embedded: z.array(certificateModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type CertificateModelPagedResult = {_embedded?: (Array<CertificateModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/certificateModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\n\nexport const certificateModel = /** Representation of a cerificate */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the certificate */\nz.string().optional().nullable(), created: /** The date and time when the certificate was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the certificate was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), category: /** The certificate's category (safetyCertificate/insurancePolicy/warranty) */\nz.string().optional().nullable(), typeId: /** The certificate's type */\nz.string().optional().nullable(), start: /** The certificate's start date */\nz.string().pipe( z.coerce.date() ).optional().nullable(), expiry: /** The certificate's expiry date */\nz.string().pipe( z.coerce.date() ).optional().nullable(), propertyId: /** The unique identifier of the property */\nz.string().optional().nullable(), companyId: /** The unique identifier of the company */\nz.string().optional().nullable(), statusId: /** The unique identifier of the certificates status */\nz.string().optional().nullable(), notes: /** Any general notes regarding the certificate */\nz.string().optional().nullable(), referenceNumber: /** The certificate's reference number */\nz.string().optional().nullable(), responsibleParty: /** The party responsible for the certificate, as defined in property configuration (agent/landlord/notRequired/notSet) */\nz.string().optional().nullable(), _eTag: /** The ETag for the current version of the certificate. Used for managing update concurrency */\nz.string().optional().nullable()});\nexport type CertificateModel = /** Representation of a cerificate */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the certificate */\nstring) | null | undefined, created?: (/** The date and time when the certificate was created */\nDate) | null | undefined, modified?: (/** The date and time when the certificate was last modified */\nDate) | null | undefined, category?: (/** The certificate's category (safetyCertificate/insurancePolicy/warranty) */\nstring) | null | undefined, typeId?: (/** The certificate's type */\nstring) | null | undefined, start?: (/** The certificate's start date */\nDate) | null | undefined, expiry?: (/** The certificate's expiry date */\nDate) | null | undefined, propertyId?: (/** The unique identifier of the property */\nstring) | null | undefined, companyId?: (/** The unique identifier of the company */\nstring) | null | undefined, statusId?: (/** The unique identifier of the certificates status */\nstring) | null | undefined, notes?: (/** Any general notes regarding the certificate */\nstring) | null | undefined, referenceNumber?: (/** The certificate's reference number */\nstring) | null | undefined, responsibleParty?: (/** The party responsible for the certificate, as defined in property configuration (agent/landlord/notRequired/notSet) */\nstring) | null | undefined, _eTag?: (/** The ETag for the current version of the certificate. Used for managing update concurrency */\nstring) | null | undefined};",
  "src/sections/Properties/forms/CreatePropertiesIdCertificates.example.tsx": "import { CreatePropertiesIdCertificatesForm, fieldNames, CreatePropertiesIdCertificatesFormFields } from '@/sections/Properties/forms/CreatePropertiesIdCertificatesForm.generated.tsx'\nimport { useParams } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreatePropertiesIdCertificates = () => {\n      const { id } = useParams()\n\n      invariant(id, 'Expected id to be defined')\n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreatePropertiesIdCertificatesForm id={id}>\n              <FormLayout>\n                <CreatePropertiesIdCertificatesFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreatePropertiesIdCertificatesForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Properties/forms/CreatePropertiesIdCertificatesForm.generated.tsx": "import { CreateApiPropertiesIdCertificatesBody, createApiPropertiesIdCertificatesBody } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { createPropertiesIdCertificatesConfig } from '@/sections/Properties/config/createPropertiesIdCertificatesConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiPropertiesIdCertificates } from '@/sections/Properties/services/useCreateApiPropertiesIdCertificates.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreatePropertiesIdCertificatesFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiPropertiesIdCertificatesBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createPropertiesIdCertificatesConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreatePropertiesIdCertificatesFormProps = {id: string, children: ReactNode, defaultValues?: CreateApiPropertiesIdCertificatesBody, onSuccess?: () => void};\nexport const CreatePropertiesIdCertificatesForm = (props: CreatePropertiesIdCertificatesFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiPropertiesIdCertificatesBody>({\n        resolver: zodResolver(createApiPropertiesIdCertificatesBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiPropertiesIdCertificates()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiPropertiesIdCertificatesBody>({category: true, typeId: true, start: true, expiry: true, companyId: true, notes: true, referenceNumber: true});",
  "src/schemas/createCertificateModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateCertificateModel = /** Request body used to create a new certificate */\n{category?: (/** The certificate's category (safetyCertificate/insurancePolicy/warranty) */\nstring) | null | undefined, typeId?: (/** The certificate's type */\nstring) | null | undefined, start?: (/** The certificate's start date */\nstring) | null | undefined, expiry?: (/** The certificate's expiry date */\nstring) | null | undefined, companyId?: (/** The unique identifier of the company that supplied, or is supplying, the certificate */\nstring) | null | undefined, notes?: (/** Any general notes regarding the certificate */\nstring) | null | undefined, referenceNumber?: (/** The certificate's reference number */\nstring) | null | undefined};\nexport const createCertificateModel = /** Request body used to create a new certificate */\nz.object({category: /** The certificate's category (safetyCertificate/insurancePolicy/warranty) */\nz.string().optional().nullable(), typeId: /** The certificate's type */\nz.string().optional().nullable(), start: /** The certificate's start date */\nz.string().optional().nullable(), expiry: /** The certificate's expiry date */\nz.string().optional().nullable(), companyId: /** The unique identifier of the company that supplied, or is supplying, the certificate */\nz.string().optional().nullable(), notes: /** Any general notes regarding the certificate */\nz.string().optional().nullable(), referenceNumber: /** The certificate's reference number */\nz.string().optional().nullable()});",
  "src/sections/Properties/config/createPropertiesIdCertificatesConfig.example.tsx": "import { CreateApiPropertiesIdCertificatesBody } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { DateInput } from '@/inputs/DateInput.tsx'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createPropertiesIdCertificatesConfig: ModelConfig<CreateApiPropertiesIdCertificatesBody> = {category: {\n      key: 'category',\n      label: 'category',\n      defaultValue: '',\n      placeholder: 'category',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, typeId: {\n      key: 'typeId',\n      label: 'typeId',\n      defaultValue: '',\n      placeholder: 'typeId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, start: {\n      key: 'start',\n      label: 'start',\n      defaultValue: null,\n      placeholder: 'start',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><DateInput {...props} /></InputWrap>\n    }, expiry: {\n      key: 'expiry',\n      label: 'expiry',\n      defaultValue: null,\n      placeholder: 'expiry',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><DateInput {...props} /></InputWrap>\n    }, companyId: {\n      key: 'companyId',\n      label: 'companyId',\n      defaultValue: '',\n      placeholder: 'companyId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, notes: {\n      key: 'notes',\n      label: 'notes',\n      defaultValue: '',\n      placeholder: 'notes',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, referenceNumber: {\n      key: 'referenceNumber',\n      label: 'referenceNumber',\n      defaultValue: '',\n      placeholder: 'referenceNumber',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/Properties/services/useCreateApiPropertiesIdCertificates.generated.ts": "import { CreateCertificateModel } from '@/schemas/createCertificateModel.generated.tsx'\nimport { createApiPropertiesIdCertificatesResponse } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiPropertiesIdCertificatesFnArgs = {id: string, body: CreateCertificateModel};\nexport const createApiPropertiesIdCertificatesFn = async ({id, body}: CreateApiPropertiesIdCertificatesFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/properties/${id}/certificates${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiPropertiesIdCertificatesResponse.parse(data)\n    };\nexport const useCreateApiPropertiesIdCertificates = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiPropertiesIdCertificatesFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Properties']})\n        }\n      })\n    };",
  "src/sections/Properties/tables/PropertiesIdKeysTable.generated.tsx": "import { useGetApiPropertiesIdKeys } from '@/sections/Properties/services/useGetApiPropertiesIdKeys.generated.ts'\nimport { useState } from 'react'\nimport { useParams, useNavigate } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\n\nexport type UsePropertiesIdKeysTableArgs = {id: string};\nexport const usePropertiesIdKeysTable = (args: UsePropertiesIdKeysTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiPropertiesIdKeys({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const PropertiesIdKeysTable = () => {\n  const {id} = useParams()\n    \n    invariant(id, 'Missing id param')\n    \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = usePropertiesIdKeysTable({id}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Properties',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New propertiesIdKeysTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/properties/${id}/keys/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Properties/services/useGetApiPropertiesIdKeys.generated.ts": "import { getApiPropertiesIdKeysResponse } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiPropertiesIdKeysFnArgs = {id: string, pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined};\nexport const getApiPropertiesIdKeysFn = async ({id, pageSize, pageNumber}: GetApiPropertiesIdKeysFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/properties/${id}/keys${querySerialiser({args:{pageSize, pageNumber}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiPropertiesIdKeysResponse.parse(data)\n    };\nexport const useGetApiPropertiesIdKeys = ({id, pageSize, pageNumber}: GetApiPropertiesIdKeysFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Properties', id, pageSize, pageNumber],\n        queryFn: () => getApiPropertiesIdKeysFn({id, pageSize, pageNumber}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/schemas/keysModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { keysModel, KeysModel } from '@/schemas/keysModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const keysModelPagedResult = z.object({_embedded: z.array(keysModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type KeysModelPagedResult = {_embedded?: (Array<KeysModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/keysModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\nimport { individualKeyModel, IndividualKeyModel } from '@/schemas/individualKeyModel.generated.tsx'\n\nexport const keysModel = /** Representation of a set of keys */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the key */\nz.string().optional().nullable(), created: /** The date and time when the key was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the key was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), number: /** The number assigned to the key - key numbers can only be occupied by a single property within an office concurrently */\nz.string().optional().nullable(), typeId: /** The unique identifier of the key type */\nz.string().optional().nullable(), officeId: /** The unique identifier of the office responsible for the key */\nz.string().optional().nullable(), propertyId: /** The unique identifier of the property that the key belongs to */\nz.string().optional().nullable(), status: /** The status of the key (checkedIn/checkedOut/noLongerHeld) */\nz.string().optional().nullable(), keysInSet: /** A listing of the individual keys included in the set */\nz.array(individualKeyModel).optional().nullable(), _eTag: /** The ETag for the current version of the keys. Used for managing update concurrency */\nz.string().optional().nullable()});\nexport type KeysModel = /** Representation of a set of keys */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the key */\nstring) | null | undefined, created?: (/** The date and time when the key was created */\nDate) | null | undefined, modified?: (/** The date and time when the key was last modified */\nDate) | null | undefined, number?: (/** The number assigned to the key - key numbers can only be occupied by a single property within an office concurrently */\nstring) | null | undefined, typeId?: (/** The unique identifier of the key type */\nstring) | null | undefined, officeId?: (/** The unique identifier of the office responsible for the key */\nstring) | null | undefined, propertyId?: (/** The unique identifier of the property that the key belongs to */\nstring) | null | undefined, status?: (/** The status of the key (checkedIn/checkedOut/noLongerHeld) */\nstring) | null | undefined, keysInSet?: (/** A listing of the individual keys included in the set */\nArray<IndividualKeyModel>) | null | undefined, _eTag?: (/** The ETag for the current version of the keys. Used for managing update concurrency */\nstring) | null | undefined};",
  "src/schemas/individualKeyModel.generated.tsx": "import { z } from 'zod'\n\nexport const individualKeyModel = /** Representation of an individual key included in a key set */\nz.object({name: /** The name of the individual key in the set */\nz.string().optional().nullable()});\nexport type IndividualKeyModel = /** Representation of an individual key included in a key set */\n{name?: (/** The name of the individual key in the set */\nstring) | null | undefined};",
  "src/sections/Properties/forms/CreatePropertiesIdKeys.example.tsx": "import { CreatePropertiesIdKeysForm, fieldNames, CreatePropertiesIdKeysFormFields } from '@/sections/Properties/forms/CreatePropertiesIdKeysForm.generated.tsx'\nimport { useParams } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreatePropertiesIdKeys = () => {\n      const { id } = useParams()\n\n      invariant(id, 'Expected id to be defined')\n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreatePropertiesIdKeysForm id={id}>\n              <FormLayout>\n                <CreatePropertiesIdKeysFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreatePropertiesIdKeysForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Properties/forms/CreatePropertiesIdKeysForm.generated.tsx": "import { CreateApiPropertiesIdKeysBody, createApiPropertiesIdKeysBody } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { createPropertiesIdKeysConfig } from '@/sections/Properties/config/createPropertiesIdKeysConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiPropertiesIdKeys } from '@/sections/Properties/services/useCreateApiPropertiesIdKeys.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreatePropertiesIdKeysFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiPropertiesIdKeysBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createPropertiesIdKeysConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreatePropertiesIdKeysFormProps = {id: string, children: ReactNode, defaultValues?: CreateApiPropertiesIdKeysBody, onSuccess?: () => void};\nexport const CreatePropertiesIdKeysForm = (props: CreatePropertiesIdKeysFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiPropertiesIdKeysBody>({\n        resolver: zodResolver(createApiPropertiesIdKeysBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiPropertiesIdKeys()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiPropertiesIdKeysBody>({number: true, typeId: true, officeId: true, keysInSet: true});",
  "src/schemas/createKeyModel.generated.tsx": "import { CreateIndividualKeyModel, createIndividualKeyModel } from '@/schemas/createIndividualKeyModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type CreateKeyModel = /** Request body used to create a new set of keys */\n{number?: (/** The number assigned to the key - key numbers can only be occupied by a single property within an office concurrently */\nstring) | null | undefined, typeId?: (/** The unique identifier of the key type */\nstring) | null | undefined, officeId?: (/** The unique identifier of the office responsible for the key */\nstring) | null | undefined, keysInSet?: (/** A listing of the individual keys included in the set */\nArray<CreateIndividualKeyModel>) | null | undefined};\nexport const createKeyModel = /** Request body used to create a new set of keys */\nz.object({number: /** The number assigned to the key - key numbers can only be occupied by a single property within an office concurrently */\nz.string().optional().nullable(), typeId: /** The unique identifier of the key type */\nz.string().optional().nullable(), officeId: /** The unique identifier of the office responsible for the key */\nz.string().optional().nullable(), keysInSet: /** A listing of the individual keys included in the set */\nz.array(createIndividualKeyModel).optional().nullable()});",
  "src/schemas/createIndividualKeyModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateIndividualKeyModel = /** Request body used to create an individual key included in a key set */\n{name?: (/** The name of the individual key in the set */\nstring) | null | undefined};\nexport const createIndividualKeyModel = /** Request body used to create an individual key included in a key set */\nz.object({name: /** The name of the individual key in the set */\nz.string().optional().nullable()});",
  "src/sections/Properties/config/createPropertiesIdKeysConfig.example.tsx": "import { CreateApiPropertiesIdKeysBody } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createPropertiesIdKeysConfig: ModelConfig<CreateApiPropertiesIdKeysBody> = {number: {\n      key: 'number',\n      label: 'number',\n      defaultValue: '',\n      placeholder: 'number',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, typeId: {\n      key: 'typeId',\n      label: 'typeId',\n      defaultValue: '',\n      placeholder: 'typeId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, officeId: {\n      key: 'officeId',\n      label: 'officeId',\n      defaultValue: '',\n      placeholder: 'officeId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, keysInSet: {\n      key: 'keysInSet',\n      label: 'keysInSet',\n      defaultValue: [],\n      placeholder: 'keysInSet',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/Properties/services/useCreateApiPropertiesIdKeys.generated.ts": "import { CreateKeyModel } from '@/schemas/createKeyModel.generated.tsx'\nimport { createApiPropertiesIdKeysResponse } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiPropertiesIdKeysFnArgs = {id: string, body: CreateKeyModel};\nexport const createApiPropertiesIdKeysFn = async ({id, body}: CreateApiPropertiesIdKeysFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/properties/${id}/keys${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiPropertiesIdKeysResponse.parse(data)\n    };\nexport const useCreateApiPropertiesIdKeys = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiPropertiesIdKeysFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Properties']})\n        }\n      })\n    };",
  "src/sections/Properties/tables/PropertiesIdKeysKeyIdMovementsTable.generated.tsx": "import { useGetApiPropertiesIdKeysKeyIdMovements } from '@/sections/Properties/services/useGetApiPropertiesIdKeysKeyIdMovements.generated.ts'\nimport { useState } from 'react'\nimport { useParams, useNavigate } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\n\nexport type UsePropertiesIdKeysKeyIdMovementsTableArgs = {id: string, keyId: string};\nexport const usePropertiesIdKeysKeyIdMovementsTable = (args: UsePropertiesIdKeysKeyIdMovementsTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiPropertiesIdKeysKeyIdMovements({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const PropertiesIdKeysKeyIdMovementsTable = () => {\n  const {id, keyId} = useParams()\n    \n    invariant(id, 'Missing id param')\ninvariant(keyId, 'Missing keyId param')\n    \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = usePropertiesIdKeysKeyIdMovementsTable({id, keyId}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Properties',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New propertiesIdKeysKeyIdMovementsTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/properties/${id}/keys/${keyId}/movements/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Properties/services/useGetApiPropertiesIdKeysKeyIdMovements.generated.ts": "import { getApiPropertiesIdKeysKeyIdMovementsResponse } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiPropertiesIdKeysKeyIdMovementsFnArgs = {id: string, keyId: string, pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined};\nexport const getApiPropertiesIdKeysKeyIdMovementsFn = async ({id, keyId, pageSize, pageNumber}: GetApiPropertiesIdKeysKeyIdMovementsFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/properties/${id}/keys/${keyId}/movements${querySerialiser({args:{pageSize, pageNumber}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiPropertiesIdKeysKeyIdMovementsResponse.parse(data)\n    };\nexport const useGetApiPropertiesIdKeysKeyIdMovements = ({id, keyId, pageSize, pageNumber}: GetApiPropertiesIdKeysKeyIdMovementsFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Properties', id, keyId, pageSize, pageNumber],\n        queryFn: () => getApiPropertiesIdKeysKeyIdMovementsFn({id, keyId, pageSize, pageNumber}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/schemas/keyMovementModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { keyMovementModel, KeyMovementModel } from '@/schemas/keyMovementModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const keyMovementModelPagedResult = z.object({_embedded: z.array(keyMovementModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type KeyMovementModelPagedResult = {_embedded?: (Array<KeyMovementModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/keyMovementModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\n\nexport const keyMovementModel = /** Representation of a key movement */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the key movement */\nz.string().optional().nullable(), created: /** The date and time when the key movement was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the key movement was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), keyId: /** The unique identifier of the key set this movement belongs to */\nz.string().optional().nullable(), propertyId: /** The unique identifier of the property that the key set belongs to */\nz.string().optional().nullable(), checkOutToId: /** The unique identifier of the contact/negotiator that the key is checked out with */\nz.string().optional().nullable(), checkOutToType: /** The type of entity that checked out the key (contact/negotiator) */\nz.string().optional().nullable(), checkOutAt: /** The date and time of when the key set was checked out */\nz.string().pipe( z.coerce.date() ).optional().nullable(), checkOutNegotiatorId: /** The unique identifier of the negotiator who performed the key check out */\nz.string().optional().nullable(), checkInAt: /** The date and time of when the key set was checked in */\nz.string().pipe( z.coerce.date() ).optional().nullable(), checkInNegotiatorId: /** The unique identifier of the negotiator who performed the key check in */\nz.string().optional().nullable(), _eTag: /** The ETag for the current version of the key movement. Used for managing update concurrency */\nz.string().optional().nullable()});\nexport type KeyMovementModel = /** Representation of a key movement */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the key movement */\nstring) | null | undefined, created?: (/** The date and time when the key movement was created */\nDate) | null | undefined, modified?: (/** The date and time when the key movement was last modified */\nDate) | null | undefined, keyId?: (/** The unique identifier of the key set this movement belongs to */\nstring) | null | undefined, propertyId?: (/** The unique identifier of the property that the key set belongs to */\nstring) | null | undefined, checkOutToId?: (/** The unique identifier of the contact/negotiator that the key is checked out with */\nstring) | null | undefined, checkOutToType?: (/** The type of entity that checked out the key (contact/negotiator) */\nstring) | null | undefined, checkOutAt?: (/** The date and time of when the key set was checked out */\nDate) | null | undefined, checkOutNegotiatorId?: (/** The unique identifier of the negotiator who performed the key check out */\nstring) | null | undefined, checkInAt?: (/** The date and time of when the key set was checked in */\nDate) | null | undefined, checkInNegotiatorId?: (/** The unique identifier of the negotiator who performed the key check in */\nstring) | null | undefined, _eTag?: (/** The ETag for the current version of the key movement. Used for managing update concurrency */\nstring) | null | undefined};",
  "src/sections/Properties/forms/CreatePropertiesIdKeysKeyIdMovements.example.tsx": "import { CreatePropertiesIdKeysKeyIdMovementsForm, fieldNames, CreatePropertiesIdKeysKeyIdMovementsFormFields } from '@/sections/Properties/forms/CreatePropertiesIdKeysKeyIdMovementsForm.generated.tsx'\nimport { useParams } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreatePropertiesIdKeysKeyIdMovements = () => {\n      const { id, keyId } = useParams()\n\n      invariant(id, 'Expected id to be defined')\ninvariant(keyId, 'Expected keyId to be defined')\n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreatePropertiesIdKeysKeyIdMovementsForm id={id} keyId={keyId}>\n              <FormLayout>\n                <CreatePropertiesIdKeysKeyIdMovementsFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreatePropertiesIdKeysKeyIdMovementsForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Properties/forms/CreatePropertiesIdKeysKeyIdMovementsForm.generated.tsx": "import { CreateApiPropertiesIdKeysKeyIdMovementsBody, createApiPropertiesIdKeysKeyIdMovementsBody } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { createPropertiesIdKeysKeyIdMovementsConfig } from '@/sections/Properties/config/createPropertiesIdKeysKeyIdMovementsConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiPropertiesIdKeysKeyIdMovements } from '@/sections/Properties/services/useCreateApiPropertiesIdKeysKeyIdMovements.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreatePropertiesIdKeysKeyIdMovementsFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiPropertiesIdKeysKeyIdMovementsBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createPropertiesIdKeysKeyIdMovementsConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreatePropertiesIdKeysKeyIdMovementsFormProps = {id: string, keyId: string, children: ReactNode, defaultValues?: CreateApiPropertiesIdKeysKeyIdMovementsBody, onSuccess?: () => void};\nexport const CreatePropertiesIdKeysKeyIdMovementsForm = (props: CreatePropertiesIdKeysKeyIdMovementsFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiPropertiesIdKeysKeyIdMovementsBody>({\n        resolver: zodResolver(createApiPropertiesIdKeysKeyIdMovementsBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiPropertiesIdKeysKeyIdMovements()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiPropertiesIdKeysKeyIdMovementsBody>({checkInRequired: true, checkOutToId: true, checkOutToType: true, checkOutNegotiatorId: true});",
  "src/schemas/createKeyMovementModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateKeyMovementModel = /** Request body used to create a new key movement */\n{checkInRequired?: (/** Indicates whether the key is expected to be checked back in. Set to true when the key is no longer held (eg. returned to the landlord) */\nboolean) | null | undefined, checkOutToId?: (/** The unique identifier of the contact or negotiator to check out the key with - this person will be recorded as holding the key */\nstring) | null | undefined, checkOutToType?: (/** The type of entity that checked out the key (contact/negotiator) */\nstring) | null | undefined, checkOutNegotiatorId?: (/** The unique identifier of the negotiator who performed the key check out */\nstring) | null | undefined};\nexport const createKeyMovementModel = /** Request body used to create a new key movement */\nz.object({checkInRequired: /** Indicates whether the key is expected to be checked back in. Set to true when the key is no longer held (eg. returned to the landlord) */\nz.boolean().optional().nullable(), checkOutToId: /** The unique identifier of the contact or negotiator to check out the key with - this person will be recorded as holding the key */\nz.string().optional().nullable(), checkOutToType: /** The type of entity that checked out the key (contact/negotiator) */\nz.string().optional().nullable(), checkOutNegotiatorId: /** The unique identifier of the negotiator who performed the key check out */\nz.string().optional().nullable()});",
  "src/sections/Properties/config/createPropertiesIdKeysKeyIdMovementsConfig.example.tsx": "import { CreateApiPropertiesIdKeysKeyIdMovementsBody } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { Switch } from '@/inputs/Switch.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createPropertiesIdKeysKeyIdMovementsConfig: ModelConfig<CreateApiPropertiesIdKeysKeyIdMovementsBody> = {checkInRequired: {\n      key: 'checkInRequired',\n      label: 'checkInRequired',\n      defaultValue: false,\n      placeholder: 'checkInRequired',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><Switch {...props} /></InputWrap>\n    }, checkOutToId: {\n      key: 'checkOutToId',\n      label: 'checkOutToId',\n      defaultValue: '',\n      placeholder: 'checkOutToId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, checkOutToType: {\n      key: 'checkOutToType',\n      label: 'checkOutToType',\n      defaultValue: '',\n      placeholder: 'checkOutToType',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, checkOutNegotiatorId: {\n      key: 'checkOutNegotiatorId',\n      label: 'checkOutNegotiatorId',\n      defaultValue: '',\n      placeholder: 'checkOutNegotiatorId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/Properties/services/useCreateApiPropertiesIdKeysKeyIdMovements.generated.ts": "import { CreateKeyMovementModel } from '@/schemas/createKeyMovementModel.generated.tsx'\nimport { createApiPropertiesIdKeysKeyIdMovementsResponse } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiPropertiesIdKeysKeyIdMovementsFnArgs = {id: string, keyId: string, body: CreateKeyMovementModel};\nexport const createApiPropertiesIdKeysKeyIdMovementsFn = async ({id, keyId, body}: CreateApiPropertiesIdKeysKeyIdMovementsFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/properties/${id}/keys/${keyId}/movements${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiPropertiesIdKeysKeyIdMovementsResponse.parse(data)\n    };\nexport const useCreateApiPropertiesIdKeysKeyIdMovements = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiPropertiesIdKeysKeyIdMovementsFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Properties']})\n        }\n      })\n    };",
  "src/sections/Properties/tables/PropertiesIdChecksTable.generated.tsx": "import { useGetApiPropertiesIdChecks } from '@/sections/Properties/services/useGetApiPropertiesIdChecks.generated.ts'\nimport { useState } from 'react'\nimport { useParams, useNavigate } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\n\nexport type UsePropertiesIdChecksTableArgs = {id: string, type?: (string) | null | undefined};\nexport const usePropertiesIdChecksTable = (args: UsePropertiesIdChecksTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiPropertiesIdChecks({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const PropertiesIdChecksTable = () => {\n  const {id} = useParams()\n    \n    invariant(id, 'Missing id param')\n    \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = usePropertiesIdChecksTable({id}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Properties',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New propertiesIdChecksTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/properties/${id}/checks/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Properties/services/useGetApiPropertiesIdChecks.generated.ts": "import { getApiPropertiesIdChecksResponse } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiPropertiesIdChecksFnArgs = {id: string, pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, type?: (string) | null | undefined};\nexport const getApiPropertiesIdChecksFn = async ({id, pageSize, pageNumber, type}: GetApiPropertiesIdChecksFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/properties/${id}/checks${querySerialiser({args:{pageSize, pageNumber, type}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiPropertiesIdChecksResponse.parse(data)\n    };\nexport const useGetApiPropertiesIdChecks = ({id, pageSize, pageNumber, type}: GetApiPropertiesIdChecksFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Properties', id, pageSize, pageNumber, type],\n        queryFn: () => getApiPropertiesIdChecksFn({id, pageSize, pageNumber, type}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/schemas/propertyCheckModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { propertyCheckModel, PropertyCheckModel } from '@/schemas/propertyCheckModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const propertyCheckModelPagedResult = z.object({_embedded: z.array(propertyCheckModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type PropertyCheckModelPagedResult = {_embedded?: (Array<PropertyCheckModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/propertyCheckModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\n\nexport const propertyCheckModel = /** Representation of a check */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the check */\nz.string().optional().nullable(), created: /** The date and time when the check was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the check was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), description: /** Textual description of what the check relates to */\nz.string().optional().nullable(), status: /** The status of the check (needed/notNeeded/arranging/completed) */\nz.string().optional().nullable(), type: /** The type of the check (preInstruction) */\nz.string().optional().nullable(), propertyId: /** The unique identifier of the property that this check relates to */\nz.string().optional().nullable(), _eTag: /** The ETag for the current version of the check. Used for managing update concurrency */\nz.string().optional().nullable()});\nexport type PropertyCheckModel = /** Representation of a check */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the check */\nstring) | null | undefined, created?: (/** The date and time when the check was created */\nDate) | null | undefined, modified?: (/** The date and time when the check was last modified */\nDate) | null | undefined, description?: (/** Textual description of what the check relates to */\nstring) | null | undefined, status?: (/** The status of the check (needed/notNeeded/arranging/completed) */\nstring) | null | undefined, type?: (/** The type of the check (preInstruction) */\nstring) | null | undefined, propertyId?: (/** The unique identifier of the property that this check relates to */\nstring) | null | undefined, _eTag?: (/** The ETag for the current version of the check. Used for managing update concurrency */\nstring) | null | undefined};",
  "src/sections/Properties/forms/CreatePropertiesIdChecks.example.tsx": "import { CreatePropertiesIdChecksForm, fieldNames, CreatePropertiesIdChecksFormFields } from '@/sections/Properties/forms/CreatePropertiesIdChecksForm.generated.tsx'\nimport { useParams } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreatePropertiesIdChecks = () => {\n      const { id } = useParams()\n\n      invariant(id, 'Expected id to be defined')\n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreatePropertiesIdChecksForm id={id}>\n              <FormLayout>\n                <CreatePropertiesIdChecksFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreatePropertiesIdChecksForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Properties/forms/CreatePropertiesIdChecksForm.generated.tsx": "import { CreateApiPropertiesIdChecksBody, createApiPropertiesIdChecksBody } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { createPropertiesIdChecksConfig } from '@/sections/Properties/config/createPropertiesIdChecksConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiPropertiesIdChecks } from '@/sections/Properties/services/useCreateApiPropertiesIdChecks.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreatePropertiesIdChecksFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiPropertiesIdChecksBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createPropertiesIdChecksConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreatePropertiesIdChecksFormProps = {id: string, children: ReactNode, defaultValues?: CreateApiPropertiesIdChecksBody, onSuccess?: () => void};\nexport const CreatePropertiesIdChecksForm = (props: CreatePropertiesIdChecksFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiPropertiesIdChecksBody>({\n        resolver: zodResolver(createApiPropertiesIdChecksBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiPropertiesIdChecks()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiPropertiesIdChecksBody>({description: true, type: true, status: true});",
  "src/schemas/createPropertyCheckModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreatePropertyCheckModel = /** Request body used to create a new check */\n{description: /** Short, descriptive text describing the purpose of the check */\nstring, type: /** The type of the check (preInstruction) */\nstring, status: /** The status of the check (needed/notNeeded/arranging/completed) */\nstring};\nexport const createPropertyCheckModel = /** Request body used to create a new check */\nz.object({description: /** Short, descriptive text describing the purpose of the check */\nz.string().min(1), type: /** The type of the check (preInstruction) */\nz.string().min(1), status: /** The status of the check (needed/notNeeded/arranging/completed) */\nz.string().min(1)});",
  "src/sections/Properties/config/createPropertiesIdChecksConfig.example.tsx": "import { CreateApiPropertiesIdChecksBody } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createPropertiesIdChecksConfig: ModelConfig<CreateApiPropertiesIdChecksBody> = {description: {\n      key: 'description',\n      label: 'description',\n      defaultValue: '',\n      placeholder: 'description',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, type: {\n      key: 'type',\n      label: 'type',\n      defaultValue: '',\n      placeholder: 'type',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, status: {\n      key: 'status',\n      label: 'status',\n      defaultValue: '',\n      placeholder: 'status',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/Properties/services/useCreateApiPropertiesIdChecks.generated.ts": "import { CreatePropertyCheckModel } from '@/schemas/createPropertyCheckModel.generated.tsx'\nimport { createApiPropertiesIdChecksResponse } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiPropertiesIdChecksFnArgs = {id: string, body: CreatePropertyCheckModel};\nexport const createApiPropertiesIdChecksFn = async ({id, body}: CreateApiPropertiesIdChecksFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/properties/${id}/checks${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiPropertiesIdChecksResponse.parse(data)\n    };\nexport const useCreateApiPropertiesIdChecks = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiPropertiesIdChecksFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Properties']})\n        }\n      })\n    };",
  "src/sections/Properties/tables/PropertiesCertificatesTable.generated.tsx": "import { useGetApiPropertiesCertificates } from '@/sections/Properties/services/useGetApiPropertiesCertificates.generated.ts'\nimport { useState } from 'react'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\nimport { useNavigate } from 'react-router-dom'\n\nexport type UsePropertiesCertificatesTableArgs = {sortBy?: (string) | null | undefined, expiryDateFrom?: (Date) | null | undefined, expiryDateTo?: (Date) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, categories?: (Array<string>) | null | undefined, typeIds?: (Array<string>) | null | undefined, propertyIds?: (Array<string>) | null | undefined, embed?: (Array<'property'>) | null | undefined};\nexport const usePropertiesCertificatesTable = (args: UsePropertiesCertificatesTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiPropertiesCertificates({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const PropertiesCertificatesTable = () => {\n  \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = usePropertiesCertificatesTable({}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Properties',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New propertiesCertificatesTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/properties/certificates/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Properties/services/useGetApiPropertiesCertificates.generated.ts": "import { getApiPropertiesCertificatesResponse } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiPropertiesCertificatesFnArgs = {pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, sortBy?: (string) | null | undefined, expiryDateFrom?: (Date) | null | undefined, expiryDateTo?: (Date) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, categories?: (Array<string>) | null | undefined, typeIds?: (Array<string>) | null | undefined, propertyIds?: (Array<string>) | null | undefined, embed?: (Array<'property'>) | null | undefined};\nexport const getApiPropertiesCertificatesFn = async ({pageNumber, pageSize, sortBy, expiryDateFrom, expiryDateTo, createdFrom, createdTo, modifiedFrom, modifiedTo, categories, typeIds, propertyIds, embed}: GetApiPropertiesCertificatesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/properties/certificates${querySerialiser({args:{pageNumber, pageSize, sortBy, expiryDateFrom, expiryDateTo, createdFrom, createdTo, modifiedFrom, modifiedTo, categories, typeIds, propertyIds, embed}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiPropertiesCertificatesResponse.parse(data)\n    };\nexport const useGetApiPropertiesCertificates = ({pageNumber, pageSize, sortBy, expiryDateFrom, expiryDateTo, createdFrom, createdTo, modifiedFrom, modifiedTo, categories, typeIds, propertyIds, embed}: GetApiPropertiesCertificatesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Properties', pageNumber, pageSize, sortBy, expiryDateFrom, expiryDateTo, createdFrom, createdTo, modifiedFrom, modifiedTo, categories, typeIds, propertyIds, embed],\n        queryFn: () => getApiPropertiesCertificatesFn({pageNumber, pageSize, sortBy, expiryDateFrom, expiryDateTo, createdFrom, createdTo, modifiedFrom, modifiedTo, categories, typeIds, propertyIds, embed}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Properties/tables/PropertiesIdAppraisalsTable.generated.tsx": "import { useGetApiPropertiesIdAppraisals } from '@/sections/Properties/services/useGetApiPropertiesIdAppraisals.generated.ts'\nimport { useState } from 'react'\nimport { useParams, useNavigate } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\n\nexport type UsePropertiesIdAppraisalsTableArgs = {id: string};\nexport const usePropertiesIdAppraisalsTable = (args: UsePropertiesIdAppraisalsTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiPropertiesIdAppraisals({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const PropertiesIdAppraisalsTable = () => {\n  const {id} = useParams()\n    \n    invariant(id, 'Missing id param')\n    \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = usePropertiesIdAppraisalsTable({id}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Properties',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New propertiesIdAppraisalsTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/properties/${id}/appraisals/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Properties/services/useGetApiPropertiesIdAppraisals.generated.ts": "import { getApiPropertiesIdAppraisalsResponse } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiPropertiesIdAppraisalsFnArgs = {id: string, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined};\nexport const getApiPropertiesIdAppraisalsFn = async ({id, pageNumber, pageSize}: GetApiPropertiesIdAppraisalsFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/properties/${id}/appraisals${querySerialiser({args:{pageNumber, pageSize}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiPropertiesIdAppraisalsResponse.parse(data)\n    };\nexport const useGetApiPropertiesIdAppraisals = ({id, pageNumber, pageSize}: GetApiPropertiesIdAppraisalsFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Properties', id, pageNumber, pageSize],\n        queryFn: () => getApiPropertiesIdAppraisalsFn({id, pageNumber, pageSize}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/schemas/propertyAppraisalModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { propertyAppraisalModel, PropertyAppraisalModel } from '@/schemas/propertyAppraisalModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const propertyAppraisalModelPagedResult = z.object({_embedded: z.array(propertyAppraisalModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type PropertyAppraisalModelPagedResult = {_embedded?: (Array<PropertyAppraisalModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/propertyAppraisalModel.generated.tsx": "import { z } from 'zod'\nimport { propertyCommissionFeeModel, PropertyCommissionFeeModel } from '@/schemas/propertyCommissionFeeModel.generated.tsx'\n\nexport const propertyAppraisalModel = /** Representation of a property appraisal */\nz.object({id: /** Unique identifier of the appraisal */\nz.string().optional().nullable(), created: /** The date and time on which the property appraisal was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time on which the property appraisal was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), companyId: /** Unique identifier of the appraising company */\nz.string().optional().nullable(), isExternal: /** Flag indicating whether the appraisal is internal or external */\nz.boolean().optional().nullable(), date: /** The date of the appraisal */\nz.string().optional().nullable(), price: /** The appraisal value */\nz.number().int().optional().nullable(), fee: propertyCommissionFeeModel.optional().nullable(), notes: /** Free-text notes associated with the appraisal */\nz.string().optional().nullable(), _eTag: z.string().optional().nullable()});\nexport type PropertyAppraisalModel = /** Representation of a property appraisal */\n{id?: (/** Unique identifier of the appraisal */\nstring) | null | undefined, created?: (/** The date and time on which the property appraisal was created */\nDate) | null | undefined, modified?: (/** The date and time on which the property appraisal was last modified */\nDate) | null | undefined, companyId?: (/** Unique identifier of the appraising company */\nstring) | null | undefined, isExternal?: (/** Flag indicating whether the appraisal is internal or external */\nboolean) | null | undefined, date?: (/** The date of the appraisal */\nstring) | null | undefined, price?: (/** The appraisal value */\nnumber) | null | undefined, fee?: (PropertyCommissionFeeModel) | null | undefined, notes?: (/** Free-text notes associated with the appraisal */\nstring) | null | undefined, _eTag?: (string) | null | undefined};",
  "src/sections/Properties/forms/CreatePropertiesIdAppraisals.example.tsx": "import { CreatePropertiesIdAppraisalsForm, fieldNames, CreatePropertiesIdAppraisalsFormFields } from '@/sections/Properties/forms/CreatePropertiesIdAppraisalsForm.generated.tsx'\nimport { useParams } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreatePropertiesIdAppraisals = () => {\n      const { id } = useParams()\n\n      invariant(id, 'Expected id to be defined')\n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreatePropertiesIdAppraisalsForm id={id}>\n              <FormLayout>\n                <CreatePropertiesIdAppraisalsFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreatePropertiesIdAppraisalsForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Properties/forms/CreatePropertiesIdAppraisalsForm.generated.tsx": "import { CreateApiPropertiesIdAppraisalsBody, createApiPropertiesIdAppraisalsBody } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { createPropertiesIdAppraisalsConfig } from '@/sections/Properties/config/createPropertiesIdAppraisalsConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiPropertiesIdAppraisals } from '@/sections/Properties/services/useCreateApiPropertiesIdAppraisals.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreatePropertiesIdAppraisalsFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiPropertiesIdAppraisalsBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createPropertiesIdAppraisalsConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreatePropertiesIdAppraisalsFormProps = {id: string, children: ReactNode, defaultValues?: CreateApiPropertiesIdAppraisalsBody, onSuccess?: () => void};\nexport const CreatePropertiesIdAppraisalsForm = (props: CreatePropertiesIdAppraisalsFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiPropertiesIdAppraisalsBody>({\n        resolver: zodResolver(createApiPropertiesIdAppraisalsBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiPropertiesIdAppraisals()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiPropertiesIdAppraisalsBody>({companyId: true, date: true, price: true, fee: true, notes: true});",
  "src/schemas/createPropertyAppraisalModel.generated.tsx": "import { PropertyCommissionFeeModel, propertyCommissionFeeModel } from '@/schemas/propertyCommissionFeeModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type CreatePropertyAppraisalModel = /** Model for the creation of a new property appraisal */\n{companyId?: (/** Unique identifier of the appraising company */\nstring) | null | undefined, date?: (/** The date of the appraisal */\nstring) | null | undefined, price?: (/** The appraisal value */\nnumber) | null | undefined, fee?: (PropertyCommissionFeeModel) | null | undefined, notes?: (/** Free-text notes associated with the appraisal */\nstring) | null | undefined};\nexport const createPropertyAppraisalModel = /** Model for the creation of a new property appraisal */\nz.object({companyId: /** Unique identifier of the appraising company */\nz.string().optional().nullable(), date: /** The date of the appraisal */\nz.string().optional().nullable(), price: /** The appraisal value */\nz.number().int().optional().nullable(), fee: propertyCommissionFeeModel.optional().nullable(), notes: /** Free-text notes associated with the appraisal */\nz.string().optional().nullable()});",
  "src/sections/Properties/config/createPropertiesIdAppraisalsConfig.example.tsx": "import { CreateApiPropertiesIdAppraisalsBody } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { DateInput } from '@/inputs/DateInput.tsx'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createPropertiesIdAppraisalsConfig: ModelConfig<CreateApiPropertiesIdAppraisalsBody> = {companyId: {\n      key: 'companyId',\n      label: 'companyId',\n      defaultValue: '',\n      placeholder: 'companyId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, date: {\n      key: 'date',\n      label: 'date',\n      defaultValue: null,\n      placeholder: 'date',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><DateInput {...props} /></InputWrap>\n    }, price: {\n      key: 'price',\n      label: 'price',\n      defaultValue: null,\n      placeholder: 'price',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, fee: {\n      key: 'fee',\n      label: 'fee',\n      defaultValue: null,\n      placeholder: 'fee',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, notes: {\n      key: 'notes',\n      label: 'notes',\n      defaultValue: '',\n      placeholder: 'notes',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/Properties/services/useCreateApiPropertiesIdAppraisals.generated.ts": "import { CreatePropertyAppraisalModel } from '@/schemas/createPropertyAppraisalModel.generated.tsx'\nimport { createApiPropertiesIdAppraisalsResponse } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiPropertiesIdAppraisalsFnArgs = {id: string, body: CreatePropertyAppraisalModel};\nexport const createApiPropertiesIdAppraisalsFn = async ({id, body}: CreateApiPropertiesIdAppraisalsFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/properties/${id}/appraisals${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiPropertiesIdAppraisalsResponse.parse(data)\n    };\nexport const useCreateApiPropertiesIdAppraisals = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiPropertiesIdAppraisalsFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Properties']})\n        }\n      })\n    };",
  "src/sections/PropertyImages/tables/PropertyImagesTable.generated.tsx": "import { useGetApiPropertyImages } from '@/sections/PropertyImages/services/useGetApiPropertyImages.generated.ts'\nimport { useState } from 'react'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\nimport { useNavigate } from 'react-router-dom'\n\nexport type UsePropertyImagesTableArgs = {sortBy?: (string) | null | undefined, id?: (Array<string>) | null | undefined, embed?: (Array<'property'>) | null | undefined, propertyId?: (Array<string>) | null | undefined, type?: (Array<'photograph' | 'map' | 'floorPlan' | 'epc'>) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, fromArchive?: (boolean) | null | undefined, metadata?: (Array<string>) | null | undefined};\nexport const usePropertyImagesTable = (args: UsePropertyImagesTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiPropertyImages({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const PropertyImagesTable = () => {\n  \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = usePropertyImagesTable({}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'PropertyImages',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New propertyImagesTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/propertyImages/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/PropertyImages/services/useGetApiPropertyImages.generated.ts": "import { getApiPropertyImagesResponse } from '@/sections/PropertyImages/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiPropertyImagesFnArgs = {pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, sortBy?: (string) | null | undefined, id?: (Array<string>) | null | undefined, embed?: (Array<'property'>) | null | undefined, propertyId?: (Array<string>) | null | undefined, type?: (Array<'photograph' | 'map' | 'floorPlan' | 'epc'>) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, fromArchive?: (boolean) | null | undefined, metadata?: (Array<string>) | null | undefined};\nexport const getApiPropertyImagesFn = async ({pageSize, pageNumber, sortBy, id, embed, propertyId, type, createdFrom, createdTo, modifiedFrom, modifiedTo, fromArchive, metadata}: GetApiPropertyImagesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/propertyImages/${querySerialiser({args:{pageSize, pageNumber, sortBy, id, embed, propertyId, type, createdFrom, createdTo, modifiedFrom, modifiedTo, fromArchive, metadata}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiPropertyImagesResponse.parse(data)\n    };\nexport const useGetApiPropertyImages = ({pageSize, pageNumber, sortBy, id, embed, propertyId, type, createdFrom, createdTo, modifiedFrom, modifiedTo, fromArchive, metadata}: GetApiPropertyImagesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['PropertyImages', pageSize, pageNumber, sortBy, id, embed, propertyId, type, createdFrom, createdTo, modifiedFrom, modifiedTo, fromArchive, metadata],\n        queryFn: () => getApiPropertyImagesFn({pageSize, pageNumber, sortBy, id, embed, propertyId, type, createdFrom, createdTo, modifiedFrom, modifiedTo, fromArchive, metadata}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/PropertyImages/services/apiTypes.generated.ts": "import { propertyImageModelPagedResult } from '@/schemas/propertyImageModelPagedResult.generated.tsx'\nimport { CreatePropertyImageModel, createPropertyImageModel } from '@/schemas/createPropertyImageModel.generated.tsx'\nimport { z } from 'zod'\nimport { CreatePreSignedUrlsModel, createPreSignedUrlsModel } from '@/schemas/createPreSignedUrlsModel.generated.tsx'\nimport { ReindexPropertyImagesModel, reindexPropertyImagesModel } from '@/schemas/reindexPropertyImagesModel.generated.tsx'\nimport { propertyImageModel } from '@/schemas/propertyImageModel.generated.tsx'\n\nexport const getApiPropertyImagesResponse = propertyImageModelPagedResult;\nexport type CreateApiPropertyImagesBody = CreatePropertyImageModel;\nexport const createApiPropertyImagesBody = createPropertyImageModel;\nexport const createApiPropertyImagesResponse = z.void();\nexport type CreateApiPropertyImagesSignedUrlBody = CreatePreSignedUrlsModel;\nexport const createApiPropertyImagesSignedUrlBody = createPreSignedUrlsModel;\nexport const createApiPropertyImagesSignedUrlResponse = createPreSignedUrlsModel;\nexport type CreateApiPropertyImagesReindexBody = ReindexPropertyImagesModel;\nexport const createApiPropertyImagesReindexBody = reindexPropertyImagesModel;\nexport const createApiPropertyImagesReindexResponse = z.void();\nexport const getApiPropertyImagesIdResponse = propertyImageModel;\nexport const deleteApiPropertyImagesIdResponse = z.void();\nexport const patchApiPropertyImagesIdResponse = z.void();",
  "src/schemas/propertyImageModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { propertyImageModel, PropertyImageModel } from '@/schemas/propertyImageModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const propertyImageModelPagedResult = z.object({_embedded: z.array(propertyImageModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type PropertyImageModelPagedResult = {_embedded?: (Array<PropertyImageModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/propertyImageModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\n\nexport const propertyImageModel = /** Representation of a property image */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the image, which is also the filename */\nz.string().optional().nullable(), created: /** The date and time when the image was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the property image was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), propertyId: /** The unique identifier of the property attached to the image */\nz.string().optional().nullable(), url: /** The url where the image can be downloaded from. Please note that physical assets for archived images may no longer be available */\nz.string().optional().nullable(), caption: /** The image caption */\nz.string().optional().nullable(), type: /** The type of image (photograph/floorPlan/epc/map) */\nz.string().optional().nullable(), order: /** The display order index of the image which can be used to correctly order the whole collection */\nz.number().int().optional().nullable(), fromArchive: /** A flag determining whether or not the image is archived. Please note that physical assets for archived images may no longer be available */\nz.boolean().optional().nullable(), _eTag: /** The ETag for the current version of the image. Used for managing update concurrency */\nz.string().optional().nullable()});\nexport type PropertyImageModel = /** Representation of a property image */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the image, which is also the filename */\nstring) | null | undefined, created?: (/** The date and time when the image was created */\nDate) | null | undefined, modified?: (/** The date and time when the property image was last modified */\nDate) | null | undefined, propertyId?: (/** The unique identifier of the property attached to the image */\nstring) | null | undefined, url?: (/** The url where the image can be downloaded from. Please note that physical assets for archived images may no longer be available */\nstring) | null | undefined, caption?: (/** The image caption */\nstring) | null | undefined, type?: (/** The type of image (photograph/floorPlan/epc/map) */\nstring) | null | undefined, order?: (/** The display order index of the image which can be used to correctly order the whole collection */\nnumber) | null | undefined, fromArchive?: (/** A flag determining whether or not the image is archived. Please note that physical assets for archived images may no longer be available */\nboolean) | null | undefined, _eTag?: (/** The ETag for the current version of the image. Used for managing update concurrency */\nstring) | null | undefined};",
  "src/sections/PropertyImages/forms/CreatePropertyImages.example.tsx": "import { CreatePropertyImagesForm, fieldNames, CreatePropertyImagesFormFields } from '@/sections/PropertyImages/forms/CreatePropertyImagesForm.generated.tsx'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreatePropertyImages = () => {\n      \n\n      \n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreatePropertyImagesForm >\n              <FormLayout>\n                <CreatePropertyImagesFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreatePropertyImagesForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/PropertyImages/forms/CreatePropertyImagesForm.generated.tsx": "import { CreateApiPropertyImagesBody, createApiPropertyImagesBody } from '@/sections/PropertyImages/services/apiTypes.generated.ts'\nimport { createPropertyImagesConfig } from '@/sections/PropertyImages/config/createPropertyImagesConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiPropertyImages } from '@/sections/PropertyImages/services/useCreateApiPropertyImages.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreatePropertyImagesFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiPropertyImagesBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createPropertyImagesConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreatePropertyImagesFormProps = {children: ReactNode, defaultValues?: CreateApiPropertyImagesBody, onSuccess?: () => void};\nexport const CreatePropertyImagesForm = (props: CreatePropertyImagesFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiPropertyImagesBody>({\n        resolver: zodResolver(createApiPropertyImagesBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiPropertyImages()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiPropertyImagesBody>({data: true, fileUrl: true, propertyId: true, caption: true, type: true});",
  "src/schemas/createPropertyImageModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreatePropertyImageModel = /** Request body used to create a new property image */\n{data?: (/** The base64 encoded file content, prefixed with the content type (eg. data:image/jpeg;base64,VGVzdCBmaWxl) */\nstring) | null | undefined, fileUrl?: (/** The presigned s3 url which a property image has been uploaded to (This supports files up to 30MB) */\nstring) | null | undefined, propertyId: /** The unique identifier of the property attached to the image */\nstring, caption: /** The image caption */\nstring, type: /** The type of image (photograph/floorPlan/epc/map) */\nstring};\nexport const createPropertyImageModel = /** Request body used to create a new property image */\nz.object({data: /** The base64 encoded file content, prefixed with the content type (eg. data:image/jpeg;base64,VGVzdCBmaWxl) */\nz.string().optional().nullable(), fileUrl: /** The presigned s3 url which a property image has been uploaded to (This supports files up to 30MB) */\nz.string().optional().nullable(), propertyId: /** The unique identifier of the property attached to the image */\nz.string().min(1), caption: /** The image caption */\nz.string().min(1), type: /** The type of image (photograph/floorPlan/epc/map) */\nz.string().min(1)});",
  "src/sections/PropertyImages/config/createPropertyImagesConfig.example.tsx": "import { CreateApiPropertyImagesBody } from '@/sections/PropertyImages/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createPropertyImagesConfig: ModelConfig<CreateApiPropertyImagesBody> = {data: {\n      key: 'data',\n      label: 'data',\n      defaultValue: '',\n      placeholder: 'data',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, fileUrl: {\n      key: 'fileUrl',\n      label: 'fileUrl',\n      defaultValue: '',\n      placeholder: 'fileUrl',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, propertyId: {\n      key: 'propertyId',\n      label: 'propertyId',\n      defaultValue: '',\n      placeholder: 'propertyId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, caption: {\n      key: 'caption',\n      label: 'caption',\n      defaultValue: '',\n      placeholder: 'caption',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, type: {\n      key: 'type',\n      label: 'type',\n      defaultValue: '',\n      placeholder: 'type',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/PropertyImages/services/useCreateApiPropertyImages.generated.ts": "import { CreatePropertyImageModel } from '@/schemas/createPropertyImageModel.generated.tsx'\nimport { createApiPropertyImagesResponse } from '@/sections/PropertyImages/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiPropertyImagesFnArgs = {body: CreatePropertyImageModel};\nexport const createApiPropertyImagesFn = async ({body}: CreateApiPropertyImagesFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/propertyImages/${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiPropertyImagesResponse.parse(data)\n    };\nexport const useCreateApiPropertyImages = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiPropertyImagesFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['PropertyImages']})\n        }\n      })\n    };",
  "src/sections/PropertyImages/forms/CreatePropertyImagesSignedUrl.example.tsx": "import { CreatePropertyImagesSignedUrlForm, fieldNames, CreatePropertyImagesSignedUrlFormFields } from '@/sections/PropertyImages/forms/CreatePropertyImagesSignedUrlForm.generated.tsx'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreatePropertyImagesSignedUrl = () => {\n      \n\n      \n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreatePropertyImagesSignedUrlForm >\n              <FormLayout>\n                <CreatePropertyImagesSignedUrlFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreatePropertyImagesSignedUrlForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/PropertyImages/forms/CreatePropertyImagesSignedUrlForm.generated.tsx": "import { CreateApiPropertyImagesSignedUrlBody, createApiPropertyImagesSignedUrlBody } from '@/sections/PropertyImages/services/apiTypes.generated.ts'\nimport { createPropertyImagesSignedUrlConfig } from '@/sections/PropertyImages/config/createPropertyImagesSignedUrlConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiPropertyImagesSignedUrl } from '@/sections/PropertyImages/services/useCreateApiPropertyImagesSignedUrl.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreatePropertyImagesSignedUrlFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiPropertyImagesSignedUrlBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createPropertyImagesSignedUrlConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreatePropertyImagesSignedUrlFormProps = {children: ReactNode, defaultValues?: CreateApiPropertyImagesSignedUrlBody, onSuccess?: () => void};\nexport const CreatePropertyImagesSignedUrlForm = (props: CreatePropertyImagesSignedUrlFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiPropertyImagesSignedUrlBody>({\n        resolver: zodResolver(createApiPropertyImagesSignedUrlBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiPropertyImagesSignedUrl()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiPropertyImagesSignedUrlBody>({amount: true});",
  "src/sections/PropertyImages/config/createPropertyImagesSignedUrlConfig.example.tsx": "import { CreateApiPropertyImagesSignedUrlBody } from '@/sections/PropertyImages/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createPropertyImagesSignedUrlConfig: ModelConfig<CreateApiPropertyImagesSignedUrlBody> = {amount: {\n      key: 'amount',\n      label: 'amount',\n      defaultValue: null,\n      placeholder: 'amount',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/PropertyImages/services/useCreateApiPropertyImagesSignedUrl.generated.ts": "import { CreatePreSignedUrlsModel } from '@/schemas/createPreSignedUrlsModel.generated.tsx'\nimport { createApiPropertyImagesSignedUrlResponse } from '@/sections/PropertyImages/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiPropertyImagesSignedUrlFnArgs = {body: CreatePreSignedUrlsModel};\nexport const createApiPropertyImagesSignedUrlFn = async ({body}: CreateApiPropertyImagesSignedUrlFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/propertyImages/signedUrl${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiPropertyImagesSignedUrlResponse.parse(data)\n    };\nexport const useCreateApiPropertyImagesSignedUrl = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiPropertyImagesSignedUrlFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['PropertyImages']})\n        }\n      })\n    };",
  "src/sections/PropertyImages/forms/CreatePropertyImagesReindex.example.tsx": "import { CreatePropertyImagesReindexForm, fieldNames, CreatePropertyImagesReindexFormFields } from '@/sections/PropertyImages/forms/CreatePropertyImagesReindexForm.generated.tsx'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreatePropertyImagesReindex = () => {\n      \n\n      \n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreatePropertyImagesReindexForm >\n              <FormLayout>\n                <CreatePropertyImagesReindexFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreatePropertyImagesReindexForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/PropertyImages/forms/CreatePropertyImagesReindexForm.generated.tsx": "import { CreateApiPropertyImagesReindexBody, createApiPropertyImagesReindexBody } from '@/sections/PropertyImages/services/apiTypes.generated.ts'\nimport { createPropertyImagesReindexConfig } from '@/sections/PropertyImages/config/createPropertyImagesReindexConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiPropertyImagesReindex } from '@/sections/PropertyImages/services/useCreateApiPropertyImagesReindex.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreatePropertyImagesReindexFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiPropertyImagesReindexBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createPropertyImagesReindexConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreatePropertyImagesReindexFormProps = {children: ReactNode, defaultValues?: CreateApiPropertyImagesReindexBody, onSuccess?: () => void};\nexport const CreatePropertyImagesReindexForm = (props: CreatePropertyImagesReindexFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiPropertyImagesReindexBody>({\n        resolver: zodResolver(createApiPropertyImagesReindexBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiPropertyImagesReindex()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiPropertyImagesReindexBody>({propertyId: true, imageOrder: true});",
  "src/schemas/reindexPropertyImagesModel.generated.tsx": "import { z } from 'zod'\n\nexport type ReindexPropertyImagesModel = /** Request body used to reindex property images */\n{propertyId?: (/** The unique identifier of the property to update */\nstring) | null | undefined, imageOrder?: (/** Ordered collection of image identifiers for the property.\r\nThe first image in the collection will be set as the properties primary image. */\nArray<string>) | null | undefined};\nexport const reindexPropertyImagesModel = /** Request body used to reindex property images */\nz.object({propertyId: /** The unique identifier of the property to update */\nz.string().optional().nullable(), imageOrder: /** Ordered collection of image identifiers for the property.\r\nThe first image in the collection will be set as the properties primary image. */\nz.array(z.string().min(1)).optional().nullable()});",
  "src/sections/PropertyImages/config/createPropertyImagesReindexConfig.example.tsx": "import { CreateApiPropertyImagesReindexBody } from '@/sections/PropertyImages/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createPropertyImagesReindexConfig: ModelConfig<CreateApiPropertyImagesReindexBody> = {propertyId: {\n      key: 'propertyId',\n      label: 'propertyId',\n      defaultValue: '',\n      placeholder: 'propertyId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, imageOrder: {\n      key: 'imageOrder',\n      label: 'imageOrder',\n      defaultValue: [],\n      placeholder: 'imageOrder',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/PropertyImages/services/useCreateApiPropertyImagesReindex.generated.ts": "import { ReindexPropertyImagesModel } from '@/schemas/reindexPropertyImagesModel.generated.tsx'\nimport { createApiPropertyImagesReindexResponse } from '@/sections/PropertyImages/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiPropertyImagesReindexFnArgs = {body: ReindexPropertyImagesModel};\nexport const createApiPropertyImagesReindexFn = async ({body}: CreateApiPropertyImagesReindexFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/propertyImages/reindex${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiPropertyImagesReindexResponse.parse(data)\n    };\nexport const useCreateApiPropertyImagesReindex = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiPropertyImagesReindexFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['PropertyImages']})\n        }\n      })\n    };",
  "src/sections/Referrals/tables/ReferralsTable.generated.tsx": "import { useGetApiReferrals } from '@/sections/Referrals/services/useGetApiReferrals.generated.ts'\nimport { useState } from 'react'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\nimport { useNavigate } from 'react-router-dom'\n\nexport type UseReferralsTableArgs = {id?: (Array<string>) | null | undefined, propertyId?: (Array<string>) | null | undefined, applicantId?: (Array<string>) | null | undefined, contactId?: (Array<string>) | null | undefined, negotiatorId?: (Array<string>) | null | undefined, referralTypeId?: (Array<string>) | null | undefined, status?: (Array<'sent' | 'inProgress' | 'succeeded' | 'cancelled' | 'failed' | 'paid' | 'declined'>) | null | undefined, embed?: (Array<'applicant' | 'contact' | 'negotiator' | 'property' | 'type'>) | null | undefined, sortBy?: (string) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined};\nexport const useReferralsTable = (args: UseReferralsTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiReferrals({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const ReferralsTable = () => {\n  \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useReferralsTable({}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Referrals',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New referralsTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/referrals/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Referrals/services/useGetApiReferrals.generated.ts": "import { getApiReferralsResponse } from '@/sections/Referrals/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiReferralsFnArgs = {id?: (Array<string>) | null | undefined, propertyId?: (Array<string>) | null | undefined, applicantId?: (Array<string>) | null | undefined, contactId?: (Array<string>) | null | undefined, negotiatorId?: (Array<string>) | null | undefined, referralTypeId?: (Array<string>) | null | undefined, status?: (Array<'sent' | 'inProgress' | 'succeeded' | 'cancelled' | 'failed' | 'paid' | 'declined'>) | null | undefined, embed?: (Array<'applicant' | 'contact' | 'negotiator' | 'property' | 'type'>) | null | undefined, pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, sortBy?: (string) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined};\nexport const getApiReferralsFn = async ({id, propertyId, applicantId, contactId, negotiatorId, referralTypeId, status, embed, pageSize, pageNumber, sortBy, createdFrom, createdTo, modifiedFrom, modifiedTo}: GetApiReferralsFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/referrals/${querySerialiser({args:{id, propertyId, applicantId, contactId, negotiatorId, referralTypeId, status, embed, pageSize, pageNumber, sortBy, createdFrom, createdTo, modifiedFrom, modifiedTo}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiReferralsResponse.parse(data)\n    };\nexport const useGetApiReferrals = ({id, propertyId, applicantId, contactId, negotiatorId, referralTypeId, status, embed, pageSize, pageNumber, sortBy, createdFrom, createdTo, modifiedFrom, modifiedTo}: GetApiReferralsFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Referrals', id, propertyId, applicantId, contactId, negotiatorId, referralTypeId, status, embed, pageSize, pageNumber, sortBy, createdFrom, createdTo, modifiedFrom, modifiedTo],\n        queryFn: () => getApiReferralsFn({id, propertyId, applicantId, contactId, negotiatorId, referralTypeId, status, embed, pageSize, pageNumber, sortBy, createdFrom, createdTo, modifiedFrom, modifiedTo}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Referrals/services/apiTypes.generated.ts": "import { referralModelPagedResult } from '@/schemas/referralModelPagedResult.generated.tsx'\nimport { CreateReferralModel, createReferralModel } from '@/schemas/createReferralModel.generated.tsx'\nimport { z } from 'zod'\nimport { referralTypeModelPagedResult } from '@/schemas/referralTypeModelPagedResult.generated.tsx'\nimport { referralModel } from '@/schemas/referralModel.generated.tsx'\nimport { referralTypeModel } from '@/schemas/referralTypeModel.generated.tsx'\n\nexport const getApiReferralsResponse = referralModelPagedResult;\nexport type CreateApiReferralsBody = CreateReferralModel;\nexport const createApiReferralsBody = createReferralModel;\nexport const createApiReferralsResponse = z.void();\nexport const getApiReferralsTypesResponse = referralTypeModelPagedResult;\nexport const getApiReferralsIdResponse = referralModel;\nexport const patchApiReferralsIdResponse = z.void();\nexport const getApiReferralsTypesIdResponse = referralTypeModel;",
  "src/schemas/referralModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { referralModel, ReferralModel } from '@/schemas/referralModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const referralModelPagedResult = z.object({_embedded: z.array(referralModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type ReferralModelPagedResult = {_embedded?: (Array<ReferralModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/referralModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\nimport { referralContactModel, ReferralContactModel } from '@/schemas/referralContactModel.generated.tsx'\n\nexport const referralModel = /** Representation of a referral */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the referral */\nz.string().optional().nullable(), created: /** The date and time when the referral was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the referral was amended */\nz.string().pipe( z.coerce.date() ).optional().nullable(), referralTypeId: /** The unique identifier of the referralTypeId the referral is associated with, where applicable */\nz.string().optional().nullable(), type: /** The type of referral (referral/lead). Please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#referral) for further information */\nz.string().optional().nullable(), negotiatorId: /** The unique identifier of the negotiator the referral is associated with, where applicable */\nz.string().optional().nullable(), propertyId: /** The unique identifier of the property the referral is associated with, where applicable */\nz.string().optional().nullable(), applicantId: /** The unique identifier of the applicant the referral is associated with, where applicable */\nz.string().optional().nullable(), contactId: /** The unique identifier of the applicant the referral is associated with, where applicable */\nz.string().optional().nullable(), status: /** The status of the referral (sent/succeeded/cancelled/failed/paid/declined/inProgress) */\nz.string().optional().nullable(), amount: /** The amount paid to the agent for the referral */\nz.number().optional().nullable(), paid: /** The date and time when the referral was paid */\nz.string().pipe( z.coerce.date() ).optional().nullable(), accepted: /** The date and time when the referral was accepted */\nz.string().pipe( z.coerce.date() ).optional().nullable(), related: referralContactModel.optional().nullable(), metadata: /** App specific metadata that has been set against the referral */\nz.record(z.string(), z.object({})).optional().nullable(), _eTag: /** The ETag for the current version of the referral. Used for managing update concurrency */\nz.string().optional().nullable()});\nexport type ReferralModel = /** Representation of a referral */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the referral */\nstring) | null | undefined, created?: (/** The date and time when the referral was created */\nDate) | null | undefined, modified?: (/** The date and time when the referral was amended */\nDate) | null | undefined, referralTypeId?: (/** The unique identifier of the referralTypeId the referral is associated with, where applicable */\nstring) | null | undefined, type?: (/** The type of referral (referral/lead). Please [see the documentation](https://foundations-documentation.reapit.cloud/platform-glossary#referral) for further information */\nstring) | null | undefined, negotiatorId?: (/** The unique identifier of the negotiator the referral is associated with, where applicable */\nstring) | null | undefined, propertyId?: (/** The unique identifier of the property the referral is associated with, where applicable */\nstring) | null | undefined, applicantId?: (/** The unique identifier of the applicant the referral is associated with, where applicable */\nstring) | null | undefined, contactId?: (/** The unique identifier of the applicant the referral is associated with, where applicable */\nstring) | null | undefined, status?: (/** The status of the referral (sent/succeeded/cancelled/failed/paid/declined/inProgress) */\nstring) | null | undefined, amount?: (/** The amount paid to the agent for the referral */\nnumber) | null | undefined, paid?: (/** The date and time when the referral was paid */\nDate) | null | undefined, accepted?: (/** The date and time when the referral was accepted */\nDate) | null | undefined, related?: (ReferralContactModel) | null | undefined, metadata?: (/** App specific metadata that has been set against the referral */\nRecord<string, Record<string, never>>) | null | undefined, _eTag?: (/** The ETag for the current version of the referral. Used for managing update concurrency */\nstring) | null | undefined};",
  "src/schemas/referralContactModel.generated.tsx": "import { z } from 'zod'\n\nexport const referralContactModel = /** Representation of a contact */\nz.object({id: z.string().optional().nullable(), title: /** The contact's title  (eg. Mr, Mrs, Miss, Dr) */\nz.string().optional().nullable(), forename: /** The contact's forename */\nz.string().optional().nullable(), surname: /** The contact's surname */\nz.string().optional().nullable(), mobilePhone: /** The mobile phone number of the contact */\nz.string().optional().nullable(), email: /** The email address of the contact */\nz.string().optional().nullable()});\nexport type ReferralContactModel = /** Representation of a contact */\n{id?: (string) | null | undefined, title?: (/** The contact's title  (eg. Mr, Mrs, Miss, Dr) */\nstring) | null | undefined, forename?: (/** The contact's forename */\nstring) | null | undefined, surname?: (/** The contact's surname */\nstring) | null | undefined, mobilePhone?: (/** The mobile phone number of the contact */\nstring) | null | undefined, email?: (/** The email address of the contact */\nstring) | null | undefined};",
  "src/sections/Referrals/forms/CreateReferrals.example.tsx": "import { CreateReferralsForm, fieldNames, CreateReferralsFormFields } from '@/sections/Referrals/forms/CreateReferralsForm.generated.tsx'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateReferrals = () => {\n      \n\n      \n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateReferralsForm >\n              <FormLayout>\n                <CreateReferralsFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateReferralsForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Referrals/forms/CreateReferralsForm.generated.tsx": "import { CreateApiReferralsBody, createApiReferralsBody } from '@/sections/Referrals/services/apiTypes.generated.ts'\nimport { createReferralsConfig } from '@/sections/Referrals/config/createReferralsConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiReferrals } from '@/sections/Referrals/services/useCreateApiReferrals.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateReferralsFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiReferralsBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createReferralsConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateReferralsFormProps = {children: ReactNode, defaultValues?: CreateApiReferralsBody, onSuccess?: () => void};\nexport const CreateReferralsForm = (props: CreateReferralsFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiReferralsBody>({\n        resolver: zodResolver(createApiReferralsBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiReferrals()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiReferralsBody>({referralTypeId: true, negotiatorId: true, propertyId: true, applicantId: true, contactId: true, amount: true});",
  "src/schemas/createReferralModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateReferralModel = /** Create Referral Model */\n{referralTypeId: /** The unique identifier of the referral type */\nstring, negotiatorId?: (/** The unique identifier of the negotiator creating the referral */\nstring) | null | undefined, propertyId?: (/** The unique identifier of the property */\nstring) | null | undefined, applicantId?: (/** The unique identifier of the applicant */\nstring) | null | undefined, contactId: /** The unique identifier of the contact that has been referred */\nstring, amount?: (/** The amount paid to the agent for the referral */\nnumber) | null | undefined};\nexport const createReferralModel = /** Create Referral Model */\nz.object({referralTypeId: /** The unique identifier of the referral type */\nz.string().min(1), negotiatorId: /** The unique identifier of the negotiator creating the referral */\nz.string().optional().nullable(), propertyId: /** The unique identifier of the property */\nz.string().optional().nullable(), applicantId: /** The unique identifier of the applicant */\nz.string().optional().nullable(), contactId: /** The unique identifier of the contact that has been referred */\nz.string().min(1), amount: /** The amount paid to the agent for the referral */\nz.number().optional().nullable()});",
  "src/sections/Referrals/config/createReferralsConfig.example.tsx": "import { CreateApiReferralsBody } from '@/sections/Referrals/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { NumberInput } from '@/inputs/NumberInput.tsx'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createReferralsConfig: ModelConfig<CreateApiReferralsBody> = {referralTypeId: {\n      key: 'referralTypeId',\n      label: 'referralTypeId',\n      defaultValue: '',\n      placeholder: 'referralTypeId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, negotiatorId: {\n      key: 'negotiatorId',\n      label: 'negotiatorId',\n      defaultValue: '',\n      placeholder: 'negotiatorId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, propertyId: {\n      key: 'propertyId',\n      label: 'propertyId',\n      defaultValue: '',\n      placeholder: 'propertyId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, applicantId: {\n      key: 'applicantId',\n      label: 'applicantId',\n      defaultValue: '',\n      placeholder: 'applicantId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, contactId: {\n      key: 'contactId',\n      label: 'contactId',\n      defaultValue: '',\n      placeholder: 'contactId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, amount: {\n      key: 'amount',\n      label: 'amount',\n      defaultValue: null,\n      placeholder: 'amount',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><NumberInput {...props} /></InputWrap>\n    }};",
  "src/sections/Referrals/services/useCreateApiReferrals.generated.ts": "import { CreateReferralModel } from '@/schemas/createReferralModel.generated.tsx'\nimport { createApiReferralsResponse } from '@/sections/Referrals/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiReferralsFnArgs = {body: CreateReferralModel};\nexport const createApiReferralsFn = async ({body}: CreateApiReferralsFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/referrals/${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiReferralsResponse.parse(data)\n    };\nexport const useCreateApiReferrals = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiReferralsFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Referrals']})\n        }\n      })\n    };",
  "src/sections/Referrals/tables/ReferralsTypesTable.generated.tsx": "import { useGetApiReferralsTypes } from '@/sections/Referrals/services/useGetApiReferralsTypes.generated.ts'\nimport { useState } from 'react'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\nimport { useNavigate } from 'react-router-dom'\n\nexport type UseReferralsTypesTableArgs = {id?: (Array<string>) | null | undefined, sortBy?: (string) | null | undefined};\nexport const useReferralsTypesTable = (args: UseReferralsTypesTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiReferralsTypes({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const ReferralsTypesTable = () => {\n  \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useReferralsTypesTable({}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Referrals',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New referralsTypesTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/referrals/types/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Referrals/services/useGetApiReferralsTypes.generated.ts": "import { getApiReferralsTypesResponse } from '@/sections/Referrals/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiReferralsTypesFnArgs = {id?: (Array<string>) | null | undefined, pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, sortBy?: (string) | null | undefined};\nexport const getApiReferralsTypesFn = async ({id, pageSize, pageNumber, sortBy}: GetApiReferralsTypesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/referrals/types${querySerialiser({args:{id, pageSize, pageNumber, sortBy}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiReferralsTypesResponse.parse(data)\n    };\nexport const useGetApiReferralsTypes = ({id, pageSize, pageNumber, sortBy}: GetApiReferralsTypesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Referrals', id, pageSize, pageNumber, sortBy],\n        queryFn: () => getApiReferralsTypesFn({id, pageSize, pageNumber, sortBy}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/schemas/referralTypeModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { referralTypeModel, ReferralTypeModel } from '@/schemas/referralTypeModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const referralTypeModelPagedResult = z.object({_embedded: z.array(referralTypeModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type ReferralTypeModelPagedResult = {_embedded?: (Array<ReferralTypeModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/referralTypeModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\n\nexport const referralTypeModel = /** Representation of a referral type */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: z.string().optional().nullable(), name: /** The name of the referral type */\nz.string().optional().nullable()});\nexport type ReferralTypeModel = /** Representation of a referral type */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (string) | null | undefined, name?: (/** The name of the referral type */\nstring) | null | undefined};",
  "src/sections/RestHooks/tables/ResthooksTable.generated.tsx": "import { useGetApiResthooks } from '@/sections/RestHooks/services/useGetApiResthooks.generated.ts'\nimport { useState } from 'react'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\nimport { useNavigate } from 'react-router-dom'\n\nexport type UseResthooksTableArgs = {sortBy?: (string) | null | undefined, active?: (boolean) | null | undefined};\nexport const useResthooksTable = (args: UseResthooksTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiResthooks({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const ResthooksTable = () => {\n  \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useResthooksTable({}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'RestHooks',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New resthooksTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/resthooks/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/RestHooks/services/useGetApiResthooks.generated.ts": "import { getApiResthooksResponse } from '@/sections/RestHooks/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiResthooksFnArgs = {pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, sortBy?: (string) | null | undefined, active?: (boolean) | null | undefined};\nexport const getApiResthooksFn = async ({pageSize, pageNumber, sortBy, active}: GetApiResthooksFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/resthooks/${querySerialiser({args:{pageSize, pageNumber, sortBy, active}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiResthooksResponse.parse(data)\n    };\nexport const useGetApiResthooks = ({pageSize, pageNumber, sortBy, active}: GetApiResthooksFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['RestHooks', pageSize, pageNumber, sortBy, active],\n        queryFn: () => getApiResthooksFn({pageSize, pageNumber, sortBy, active}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/RestHooks/services/apiTypes.generated.ts": "import { webhookModelPagedResult } from '@/schemas/webhookModelPagedResult.generated.tsx'\nimport { CreateWebhookModel, createWebhookModel } from '@/schemas/createWebhookModel.generated.tsx'\nimport { z } from 'zod'\nimport { webhookModel } from '@/schemas/webhookModel.generated.tsx'\n\nexport const getApiResthooksResponse = webhookModelPagedResult;\nexport type CreateApiResthooksBody = CreateWebhookModel;\nexport const createApiResthooksBody = createWebhookModel;\nexport const createApiResthooksResponse = z.void();\nexport const getApiResthooksIdResponse = webhookModel;\nexport const updateApiResthooksIdResponse = z.void();\nexport const deleteApiResthooksIdResponse = z.void();",
  "src/schemas/webhookModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { webhookModel, WebhookModel } from '@/schemas/webhookModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const webhookModelPagedResult = z.object({_embedded: z.array(webhookModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type WebhookModelPagedResult = {_embedded?: (Array<WebhookModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/webhookModel.generated.tsx": "import { z } from 'zod'\n\nexport const webhookModel = /** Representation of a webhook subscription */\nz.object({id: /** The unique identifier of the webhook */\nz.string().optional().nullable(), created: /** The date and time when the webhook was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the webhook was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), url: /** The url where the payload associated with the webhook should be sent to */\nz.string().optional().nullable(), description: /** A short description associated with the webhook (ie a friendly name or label) */\nz.string().optional().nullable(), topicIds: /** The identifiers of the topics the webhook is associated with */\nz.array(z.string().min(1)).optional().nullable(), active: /** Flag denoting whether or not the webhook is active and ready to receive data */\nz.boolean().optional().nullable(), ignoreEtagOnlyChanges: /** Flag denoting whether or events that only contain changes to etags and/or modified dates are emitted */\nz.boolean().optional().nullable()});\nexport type WebhookModel = /** Representation of a webhook subscription */\n{id?: (/** The unique identifier of the webhook */\nstring) | null | undefined, created?: (/** The date and time when the webhook was created */\nDate) | null | undefined, modified?: (/** The date and time when the webhook was last modified */\nDate) | null | undefined, url?: (/** The url where the payload associated with the webhook should be sent to */\nstring) | null | undefined, description?: (/** A short description associated with the webhook (ie a friendly name or label) */\nstring) | null | undefined, topicIds?: (/** The identifiers of the topics the webhook is associated with */\nArray<string>) | null | undefined, active?: (/** Flag denoting whether or not the webhook is active and ready to receive data */\nboolean) | null | undefined, ignoreEtagOnlyChanges?: (/** Flag denoting whether or events that only contain changes to etags and/or modified dates are emitted */\nboolean) | null | undefined};",
  "src/sections/RestHooks/forms/CreateResthooks.example.tsx": "import { CreateResthooksForm, fieldNames, CreateResthooksFormFields } from '@/sections/RestHooks/forms/CreateResthooksForm.generated.tsx'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateResthooks = () => {\n      \n\n      \n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateResthooksForm >\n              <FormLayout>\n                <CreateResthooksFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateResthooksForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/RestHooks/forms/CreateResthooksForm.generated.tsx": "import { CreateApiResthooksBody, createApiResthooksBody } from '@/sections/RestHooks/services/apiTypes.generated.ts'\nimport { createResthooksConfig } from '@/sections/RestHooks/config/createResthooksConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiResthooks } from '@/sections/RestHooks/services/useCreateApiResthooks.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateResthooksFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiResthooksBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createResthooksConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateResthooksFormProps = {children: ReactNode, defaultValues?: CreateApiResthooksBody, onSuccess?: () => void};\nexport const CreateResthooksForm = (props: CreateResthooksFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiResthooksBody>({\n        resolver: zodResolver(createApiResthooksBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiResthooks()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiResthooksBody>({url: true, description: true, topicIds: true, active: true, ignoreEtagOnlyChanges: true});",
  "src/schemas/createWebhookModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateWebhookModel = /** Request body used to create a new webhook subscription */\n{url: /** The url where the payload associated with the webhook should be sent to */\nstring, description?: (/** A short description associated with the webhook (ie a friendly name or label) */\nstring) | null | undefined, topicIds?: (/** The identifiers of the topics the subscription is associated with */\nArray<string>) | null | undefined, active?: (/** Flag denoting whether or not the webhook is active and ready to receive data */\nboolean) | null | undefined, ignoreEtagOnlyChanges?: (/** Flag denoting whether or events that only contain changes to etags and/or modified dates are emitted\r\nPass true to disable emitting of these events */\nboolean) | null | undefined};\nexport const createWebhookModel = /** Request body used to create a new webhook subscription */\nz.object({url: /** The url where the payload associated with the webhook should be sent to */\nz.string().min(1), description: /** A short description associated with the webhook (ie a friendly name or label) */\nz.string().optional().nullable(), topicIds: /** The identifiers of the topics the subscription is associated with */\nz.array(z.string().min(1)).optional().nullable(), active: /** Flag denoting whether or not the webhook is active and ready to receive data */\nz.boolean().optional().nullable(), ignoreEtagOnlyChanges: /** Flag denoting whether or events that only contain changes to etags and/or modified dates are emitted\r\nPass true to disable emitting of these events */\nz.boolean().optional().nullable()});",
  "src/sections/RestHooks/config/createResthooksConfig.example.tsx": "import { CreateApiResthooksBody } from '@/sections/RestHooks/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { Switch } from '@/inputs/Switch.tsx'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createResthooksConfig: ModelConfig<CreateApiResthooksBody> = {url: {\n      key: 'url',\n      label: 'url',\n      defaultValue: '',\n      placeholder: 'url',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, description: {\n      key: 'description',\n      label: 'description',\n      defaultValue: '',\n      placeholder: 'description',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, topicIds: {\n      key: 'topicIds',\n      label: 'topicIds',\n      defaultValue: [],\n      placeholder: 'topicIds',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, active: {\n      key: 'active',\n      label: 'active',\n      defaultValue: false,\n      placeholder: 'active',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><Switch {...props} /></InputWrap>\n    }, ignoreEtagOnlyChanges: {\n      key: 'ignoreEtagOnlyChanges',\n      label: 'ignoreEtagOnlyChanges',\n      defaultValue: false,\n      placeholder: 'ignoreEtagOnlyChanges',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><Switch {...props} /></InputWrap>\n    }};",
  "src/sections/RestHooks/services/useCreateApiResthooks.generated.ts": "import { CreateWebhookModel } from '@/schemas/createWebhookModel.generated.tsx'\nimport { createApiResthooksResponse } from '@/sections/RestHooks/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiResthooksFnArgs = {body: CreateWebhookModel};\nexport const createApiResthooksFn = async ({body}: CreateApiResthooksFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/resthooks/${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiResthooksResponse.parse(data)\n    };\nexport const useCreateApiResthooks = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiResthooksFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['RestHooks']})\n        }\n      })\n    };",
  "src/sections/Sources/tables/SourcesTable.generated.tsx": "import { useGetApiSources } from '@/sections/Sources/services/useGetApiSources.generated.ts'\nimport { useState } from 'react'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\nimport { useNavigate } from 'react-router-dom'\n\nexport type UseSourcesTableArgs = {sortBy?: (string) | null | undefined, id?: (Array<string>) | null | undefined, officeId?: (Array<string>) | null | undefined, departmentId?: (Array<string>) | null | undefined, name?: (string) | null | undefined, type?: (string) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined};\nexport const useSourcesTable = (args: UseSourcesTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiSources({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const SourcesTable = () => {\n  \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useSourcesTable({}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Sources',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New sourcesTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/sources/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Sources/services/useGetApiSources.generated.ts": "import { getApiSourcesResponse } from '@/sections/Sources/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiSourcesFnArgs = {pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, sortBy?: (string) | null | undefined, id?: (Array<string>) | null | undefined, officeId?: (Array<string>) | null | undefined, departmentId?: (Array<string>) | null | undefined, name?: (string) | null | undefined, type?: (string) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined};\nexport const getApiSourcesFn = async ({pageSize, pageNumber, sortBy, id, officeId, departmentId, name, type, createdFrom, createdTo, modifiedFrom, modifiedTo}: GetApiSourcesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/sources/${querySerialiser({args:{pageSize, pageNumber, sortBy, id, officeId, departmentId, name, type, createdFrom, createdTo, modifiedFrom, modifiedTo}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiSourcesResponse.parse(data)\n    };\nexport const useGetApiSources = ({pageSize, pageNumber, sortBy, id, officeId, departmentId, name, type, createdFrom, createdTo, modifiedFrom, modifiedTo}: GetApiSourcesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Sources', pageSize, pageNumber, sortBy, id, officeId, departmentId, name, type, createdFrom, createdTo, modifiedFrom, modifiedTo],\n        queryFn: () => getApiSourcesFn({pageSize, pageNumber, sortBy, id, officeId, departmentId, name, type, createdFrom, createdTo, modifiedFrom, modifiedTo}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Sources/services/apiTypes.generated.ts": "import { sourceModelPagedResult } from '@/schemas/sourceModelPagedResult.generated.tsx'\nimport { CreateSourceModel, createSourceModel } from '@/schemas/createSourceModel.generated.tsx'\nimport { z } from 'zod'\nimport { sourceModel } from '@/schemas/sourceModel.generated.tsx'\n\nexport const getApiSourcesResponse = sourceModelPagedResult;\nexport type CreateApiSourcesBody = CreateSourceModel;\nexport const createApiSourcesBody = createSourceModel;\nexport const createApiSourcesResponse = z.void();\nexport const getApiSourcesIdResponse = sourceModel;\nexport const patchApiSourcesIdResponse = z.void();",
  "src/schemas/sourceModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { sourceModel, SourceModel } from '@/schemas/sourceModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const sourceModelPagedResult = z.object({_embedded: z.array(sourceModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type SourceModelPagedResult = {_embedded?: (Array<SourceModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/sourceModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\n\nexport const sourceModel = /** Representation of a source of business */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the source */\nz.string().optional().nullable(), created: /** The date and time when the source was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the source was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), name: /** The name of the source or advertising publication */\nz.string().optional().nullable(), type: /** The type of the source (source/advertisement) */\nz.string().optional().nullable(), officeIds: /** A collection of the unique identifiers of offices that regularly get business from the source */\nz.array(z.string().min(1)).optional().nullable(), departmentIds: /** A collection of unique identifiers of departments that regularly get business from the source */\nz.array(z.string().min(1)).optional().nullable(), _eTag: /** The ETag for the current version of the source. Used for managing update concurrency */\nz.string().optional().nullable()});\nexport type SourceModel = /** Representation of a source of business */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the source */\nstring) | null | undefined, created?: (/** The date and time when the source was created */\nDate) | null | undefined, modified?: (/** The date and time when the source was last modified */\nDate) | null | undefined, name?: (/** The name of the source or advertising publication */\nstring) | null | undefined, type?: (/** The type of the source (source/advertisement) */\nstring) | null | undefined, officeIds?: (/** A collection of the unique identifiers of offices that regularly get business from the source */\nArray<string>) | null | undefined, departmentIds?: (/** A collection of unique identifiers of departments that regularly get business from the source */\nArray<string>) | null | undefined, _eTag?: (/** The ETag for the current version of the source. Used for managing update concurrency */\nstring) | null | undefined};",
  "src/sections/Sources/forms/CreateSources.example.tsx": "import { CreateSourcesForm, fieldNames, CreateSourcesFormFields } from '@/sections/Sources/forms/CreateSourcesForm.generated.tsx'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateSources = () => {\n      \n\n      \n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateSourcesForm >\n              <FormLayout>\n                <CreateSourcesFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateSourcesForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Sources/forms/CreateSourcesForm.generated.tsx": "import { CreateApiSourcesBody, createApiSourcesBody } from '@/sections/Sources/services/apiTypes.generated.ts'\nimport { createSourcesConfig } from '@/sections/Sources/config/createSourcesConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiSources } from '@/sections/Sources/services/useCreateApiSources.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateSourcesFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiSourcesBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createSourcesConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateSourcesFormProps = {children: ReactNode, defaultValues?: CreateApiSourcesBody, onSuccess?: () => void};\nexport const CreateSourcesForm = (props: CreateSourcesFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiSourcesBody>({\n        resolver: zodResolver(createApiSourcesBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiSources()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiSourcesBody>({name: true, type: true, officeIds: true, departmentIds: true});",
  "src/schemas/createSourceModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateSourceModel = /** Request body used to create a new source of business */\n{name: /** The name of the source or advertising publication */\nstring, type: /** The type of the source (source/advertisement) */\nstring, officeIds?: (/** A collection of the unique identifiers of offices that regularly get business from the source */\nArray<string>) | null | undefined, departmentIds?: (/** A collection of unique identifiers of departments that regularly get business from the source */\nArray<string>) | null | undefined};\nexport const createSourceModel = /** Request body used to create a new source of business */\nz.object({name: /** The name of the source or advertising publication */\nz.string().min(1), type: /** The type of the source (source/advertisement) */\nz.string().min(1), officeIds: /** A collection of the unique identifiers of offices that regularly get business from the source */\nz.array(z.string().min(1)).optional().nullable(), departmentIds: /** A collection of unique identifiers of departments that regularly get business from the source */\nz.array(z.string().min(1)).optional().nullable()});",
  "src/sections/Sources/config/createSourcesConfig.example.tsx": "import { CreateApiSourcesBody } from '@/sections/Sources/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { OfficesInput } from '@/sections/Offices/inputs/OfficesInput.generated.tsx'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createSourcesConfig: ModelConfig<CreateApiSourcesBody> = {name: {\n      key: 'name',\n      label: 'name',\n      defaultValue: '',\n      placeholder: 'name',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, type: {\n      key: 'type',\n      label: 'type',\n      defaultValue: '',\n      placeholder: 'type',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, officeIds: {\n      key: 'officeIds',\n      label: 'officeIds',\n      defaultValue: [],\n      placeholder: 'officeIds',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><OfficesInput {...props} /></InputWrap>\n    }, departmentIds: {\n      key: 'departmentIds',\n      label: 'departmentIds',\n      defaultValue: [],\n      placeholder: 'departmentIds',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/Sources/services/useCreateApiSources.generated.ts": "import { CreateSourceModel } from '@/schemas/createSourceModel.generated.tsx'\nimport { createApiSourcesResponse } from '@/sections/Sources/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiSourcesFnArgs = {body: CreateSourceModel};\nexport const createApiSourcesFn = async ({body}: CreateApiSourcesFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/sources/${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiSourcesResponse.parse(data)\n    };\nexport const useCreateApiSources = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiSourcesFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Sources']})\n        }\n      })\n    };",
  "src/sections/Tasks/tables/TasksTable.generated.tsx": "import { useGetApiTasks } from '@/sections/Tasks/services/useGetApiTasks.generated.ts'\nimport { useState } from 'react'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\nimport { useNavigate } from 'react-router-dom'\n\nexport type UseTasksTableArgs = {sortBy?: (string) | null | undefined, embed?: (Array<'applicant' | 'contact' | 'landlord' | 'property' | 'tenancy' | 'type'>) | null | undefined, id?: (Array<string>) | null | undefined, applicantId?: (Array<string>) | null | undefined, contactId?: (Array<string>) | null | undefined, landlordId?: (Array<string>) | null | undefined, officeId?: (Array<string>) | null | undefined, propertyId?: (Array<string>) | null | undefined, recipientId?: (Array<string>) | null | undefined, senderId?: (Array<string>) | null | undefined, typeId?: (Array<string>) | null | undefined, tenancyId?: (Array<string>) | null | undefined, activatesFrom?: (Date) | null | undefined, activatesTo?: (Date) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, metadata?: (Array<string>) | null | undefined};\nexport const useTasksTable = (args: UseTasksTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiTasks({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const TasksTable = () => {\n  \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useTasksTable({}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Tasks',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New tasksTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/tasks/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Tasks/services/useGetApiTasks.generated.ts": "import { getApiTasksResponse } from '@/sections/Tasks/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiTasksFnArgs = {pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, sortBy?: (string) | null | undefined, embed?: (Array<'applicant' | 'contact' | 'landlord' | 'property' | 'tenancy' | 'type'>) | null | undefined, id?: (Array<string>) | null | undefined, applicantId?: (Array<string>) | null | undefined, contactId?: (Array<string>) | null | undefined, landlordId?: (Array<string>) | null | undefined, officeId?: (Array<string>) | null | undefined, propertyId?: (Array<string>) | null | undefined, recipientId?: (Array<string>) | null | undefined, senderId?: (Array<string>) | null | undefined, typeId?: (Array<string>) | null | undefined, tenancyId?: (Array<string>) | null | undefined, activatesFrom?: (Date) | null | undefined, activatesTo?: (Date) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, metadata?: (Array<string>) | null | undefined};\nexport const getApiTasksFn = async ({pageSize, pageNumber, sortBy, embed, id, applicantId, contactId, landlordId, officeId, propertyId, recipientId, senderId, typeId, tenancyId, activatesFrom, activatesTo, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata}: GetApiTasksFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/tasks/${querySerialiser({args:{pageSize, pageNumber, sortBy, embed, id, applicantId, contactId, landlordId, officeId, propertyId, recipientId, senderId, typeId, tenancyId, activatesFrom, activatesTo, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiTasksResponse.parse(data)\n    };\nexport const useGetApiTasks = ({pageSize, pageNumber, sortBy, embed, id, applicantId, contactId, landlordId, officeId, propertyId, recipientId, senderId, typeId, tenancyId, activatesFrom, activatesTo, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata}: GetApiTasksFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Tasks', pageSize, pageNumber, sortBy, embed, id, applicantId, contactId, landlordId, officeId, propertyId, recipientId, senderId, typeId, tenancyId, activatesFrom, activatesTo, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata],\n        queryFn: () => getApiTasksFn({pageSize, pageNumber, sortBy, embed, id, applicantId, contactId, landlordId, officeId, propertyId, recipientId, senderId, typeId, tenancyId, activatesFrom, activatesTo, createdFrom, createdTo, modifiedFrom, modifiedTo, metadata}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Tasks/services/apiTypes.generated.ts": "import { taskModelPagedResult } from '@/schemas/taskModelPagedResult.generated.tsx'\nimport { CreateTaskModel, createTaskModel } from '@/schemas/createTaskModel.generated.tsx'\nimport { z } from 'zod'\nimport { taskModel } from '@/schemas/taskModel.generated.tsx'\n\nexport const getApiTasksResponse = taskModelPagedResult;\nexport type CreateApiTasksBody = CreateTaskModel;\nexport const createApiTasksBody = createTaskModel;\nexport const createApiTasksResponse = z.void();\nexport const getApiTasksIdResponse = taskModel;\nexport const patchApiTasksIdResponse = z.void();",
  "src/schemas/taskModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { taskModel, TaskModel } from '@/schemas/taskModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const taskModelPagedResult = z.object({_embedded: z.array(taskModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type TaskModelPagedResult = {_embedded?: (Array<TaskModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/taskModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\n\nexport const taskModel = /** Representation of a task, which can also be an internal message */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the task */\nz.string().optional().nullable(), created: /** The date and time when the task was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the task was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), activates: /** The date the task becomes active */\nz.string().optional().nullable(), completed: /** The date the task was completed */\nz.string().optional().nullable(), typeId: /** The unique identifier of the task type */\nz.string().optional().nullable(), senderId: /** The unique identifer of the negotiator that created the task */\nz.string().optional().nullable(), text: /** The textual contents of the task or message */\nz.string().optional().nullable(), landlordId: /** The unique identifier of the landlord the task is associated to */\nz.string().optional().nullable(), propertyId: /** The unique identifier of the property the task is associated to */\nz.string().optional().nullable(), applicantId: /** The unique identifier of the applicant the task is associated to */\nz.string().optional().nullable(), tenancyId: /** The unique identifier of the tenancy the task is associated to */\nz.string().optional().nullable(), contactId: /** The unique identifier of the contact the task is associated to */\nz.string().optional().nullable(), recipientId: /** The unique identifier of the negotiator or office the task is being sent to */\nz.string().optional().nullable(), recipientType: /** The type of the recipient (office/negotiator) */\nz.string().optional().nullable(), metadata: /** App specific metadata that has been set against the task */\nz.record(z.string(), z.object({})).optional().nullable(), _eTag: /** The ETag for the current version of the task. Used for managing update concurrency */\nz.string().optional().nullable()});\nexport type TaskModel = /** Representation of a task, which can also be an internal message */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the task */\nstring) | null | undefined, created?: (/** The date and time when the task was created */\nDate) | null | undefined, modified?: (/** The date and time when the task was last modified */\nDate) | null | undefined, activates?: (/** The date the task becomes active */\nstring) | null | undefined, completed?: (/** The date the task was completed */\nstring) | null | undefined, typeId?: (/** The unique identifier of the task type */\nstring) | null | undefined, senderId?: (/** The unique identifer of the negotiator that created the task */\nstring) | null | undefined, text?: (/** The textual contents of the task or message */\nstring) | null | undefined, landlordId?: (/** The unique identifier of the landlord the task is associated to */\nstring) | null | undefined, propertyId?: (/** The unique identifier of the property the task is associated to */\nstring) | null | undefined, applicantId?: (/** The unique identifier of the applicant the task is associated to */\nstring) | null | undefined, tenancyId?: (/** The unique identifier of the tenancy the task is associated to */\nstring) | null | undefined, contactId?: (/** The unique identifier of the contact the task is associated to */\nstring) | null | undefined, recipientId?: (/** The unique identifier of the negotiator or office the task is being sent to */\nstring) | null | undefined, recipientType?: (/** The type of the recipient (office/negotiator) */\nstring) | null | undefined, metadata?: (/** App specific metadata that has been set against the task */\nRecord<string, Record<string, never>>) | null | undefined, _eTag?: (/** The ETag for the current version of the task. Used for managing update concurrency */\nstring) | null | undefined};",
  "src/sections/Tasks/forms/CreateTasks.example.tsx": "import { CreateTasksForm, fieldNames, CreateTasksFormFields } from '@/sections/Tasks/forms/CreateTasksForm.generated.tsx'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateTasks = () => {\n      \n\n      \n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateTasksForm >\n              <FormLayout>\n                <CreateTasksFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateTasksForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Tasks/forms/CreateTasksForm.generated.tsx": "import { CreateApiTasksBody, createApiTasksBody } from '@/sections/Tasks/services/apiTypes.generated.ts'\nimport { createTasksConfig } from '@/sections/Tasks/config/createTasksConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiTasks } from '@/sections/Tasks/services/useCreateApiTasks.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateTasksFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiTasksBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createTasksConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateTasksFormProps = {children: ReactNode, defaultValues?: CreateApiTasksBody, onSuccess?: () => void};\nexport const CreateTasksForm = (props: CreateTasksFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiTasksBody>({\n        resolver: zodResolver(createApiTasksBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiTasks()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiTasksBody>({activates: true, completed: true, typeId: true, senderId: true, text: true, landlordId: true, propertyId: true, applicantId: true, tenancyId: true, contactId: true, recipientId: true, recipientType: true, metadata: true});",
  "src/schemas/createTaskModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateTaskModel = /** Request body used to create a new task, which can also be an internal message */\n{activates?: (/** The date the task becomes active (Required when 'TypeId' is given) */\nstring) | null | undefined, completed?: (/** The date the task was completed */\nstring) | null | undefined, typeId?: (/** The unique identifier of the task type */\nstring) | null | undefined, senderId: /** The unique identifer of the negotiator that created the task */\nstring, text: /** The textual contents of the task or message */\nstring, landlordId?: (/** The unique identifier of the landlord the task is associated to */\nstring) | null | undefined, propertyId?: (/** The unique identifier of the property the task is associated to */\nstring) | null | undefined, applicantId?: (/** The unique identifier of the applicant the task is associated to */\nstring) | null | undefined, tenancyId?: (/** The unique identifier of the tenancy the task is associated to */\nstring) | null | undefined, contactId?: (/** The unique identifier of the contact the task is associated to */\nstring) | null | undefined, recipientId: /** The unique identifier of the negotiator or office the task is being sent to */\nstring, recipientType: /** The type of the recipient (office/negotiator) */\nstring, metadata?: (/** App specific metadata that has been set against the task */\nRecord<string, Record<string, never>>) | null | undefined};\nexport const createTaskModel = /** Request body used to create a new task, which can also be an internal message */\nz.object({activates: /** The date the task becomes active (Required when 'TypeId' is given) */\nz.string().optional().nullable(), completed: /** The date the task was completed */\nz.string().optional().nullable(), typeId: /** The unique identifier of the task type */\nz.string().optional().nullable(), senderId: /** The unique identifer of the negotiator that created the task */\nz.string().min(1), text: /** The textual contents of the task or message */\nz.string().min(1), landlordId: /** The unique identifier of the landlord the task is associated to */\nz.string().optional().nullable(), propertyId: /** The unique identifier of the property the task is associated to */\nz.string().optional().nullable(), applicantId: /** The unique identifier of the applicant the task is associated to */\nz.string().optional().nullable(), tenancyId: /** The unique identifier of the tenancy the task is associated to */\nz.string().optional().nullable(), contactId: /** The unique identifier of the contact the task is associated to */\nz.string().optional().nullable(), recipientId: /** The unique identifier of the negotiator or office the task is being sent to */\nz.string().min(1), recipientType: /** The type of the recipient (office/negotiator) */\nz.string().min(1), metadata: /** App specific metadata that has been set against the task */\nz.record(z.string(), z.object({})).optional().nullable()});",
  "src/sections/Tasks/config/createTasksConfig.example.tsx": "import { CreateApiTasksBody } from '@/sections/Tasks/services/apiTypes.generated.ts'\nimport { DateInput } from '@/inputs/DateInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createTasksConfig: ModelConfig<CreateApiTasksBody> = {activates: {\n      key: 'activates',\n      label: 'activates',\n      defaultValue: null,\n      placeholder: 'activates',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><DateInput {...props} /></InputWrap>\n    }, completed: {\n      key: 'completed',\n      label: 'completed',\n      defaultValue: null,\n      placeholder: 'completed',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><DateInput {...props} /></InputWrap>\n    }, typeId: {\n      key: 'typeId',\n      label: 'typeId',\n      defaultValue: '',\n      placeholder: 'typeId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, senderId: {\n      key: 'senderId',\n      label: 'senderId',\n      defaultValue: '',\n      placeholder: 'senderId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, text: {\n      key: 'text',\n      label: 'text',\n      defaultValue: '',\n      placeholder: 'text',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, landlordId: {\n      key: 'landlordId',\n      label: 'landlordId',\n      defaultValue: '',\n      placeholder: 'landlordId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, propertyId: {\n      key: 'propertyId',\n      label: 'propertyId',\n      defaultValue: '',\n      placeholder: 'propertyId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, applicantId: {\n      key: 'applicantId',\n      label: 'applicantId',\n      defaultValue: '',\n      placeholder: 'applicantId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, tenancyId: {\n      key: 'tenancyId',\n      label: 'tenancyId',\n      defaultValue: '',\n      placeholder: 'tenancyId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, contactId: {\n      key: 'contactId',\n      label: 'contactId',\n      defaultValue: '',\n      placeholder: 'contactId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, recipientId: {\n      key: 'recipientId',\n      label: 'recipientId',\n      defaultValue: '',\n      placeholder: 'recipientId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, recipientType: {\n      key: 'recipientType',\n      label: 'recipientType',\n      defaultValue: '',\n      placeholder: 'recipientType',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, metadata: {\n      key: 'metadata',\n      label: 'metadata',\n      defaultValue: null,\n      placeholder: 'metadata',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/Tasks/services/useCreateApiTasks.generated.ts": "import { CreateTaskModel } from '@/schemas/createTaskModel.generated.tsx'\nimport { createApiTasksResponse } from '@/sections/Tasks/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiTasksFnArgs = {body: CreateTaskModel};\nexport const createApiTasksFn = async ({body}: CreateApiTasksFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/tasks/${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiTasksResponse.parse(data)\n    };\nexport const useCreateApiTasks = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiTasksFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Tasks']})\n        }\n      })\n    };",
  "src/sections/Tenancies/tables/TenanciesTable.generated.tsx": "import { useGetApiTenancies } from '@/sections/Tenancies/services/useGetApiTenancies.generated.ts'\nimport { useState } from 'react'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\nimport { useNavigate } from 'react-router-dom'\n\nexport type UseTenanciesTableArgs = {sortBy?: (string) | null | undefined, fromArchive?: (boolean) | null | undefined, embed?: (Array<'appointments' | 'applicant' | 'extensions' | 'documents' | 'negotiator' | 'property' | 'source' | 'tasks' | 'type'>) | null | undefined, id?: (Array<string>) | null | undefined, negotiatorId?: (Array<string>) | null | undefined, applicantId?: (Array<string>) | null | undefined, propertyId?: (Array<string>) | null | undefined, name?: (string) | null | undefined, nameType?: (string) | null | undefined, status?: (Array<'offerPending' | 'offerWithdrawn' | 'offerRejected' | 'arranging' | 'current' | 'finished' | 'cancelled'>) | null | undefined, email?: (Array<string>) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, endDateFrom?: (Date) | null | undefined, endDateTo?: (Date) | null | undefined, startDateFrom?: (Date) | null | undefined, startDateTo?: (Date) | null | undefined, metadata?: (Array<string>) | null | undefined};\nexport const useTenanciesTable = (args: UseTenanciesTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiTenancies({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const TenanciesTable = () => {\n  \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useTenanciesTable({}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Tenancies',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New tenanciesTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/tenancies/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Tenancies/services/useGetApiTenancies.generated.ts": "import { getApiTenanciesResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiTenanciesFnArgs = {pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, sortBy?: (string) | null | undefined, fromArchive?: (boolean) | null | undefined, embed?: (Array<'appointments' | 'applicant' | 'extensions' | 'documents' | 'negotiator' | 'property' | 'source' | 'tasks' | 'type'>) | null | undefined, id?: (Array<string>) | null | undefined, negotiatorId?: (Array<string>) | null | undefined, applicantId?: (Array<string>) | null | undefined, propertyId?: (Array<string>) | null | undefined, name?: (string) | null | undefined, nameType?: (string) | null | undefined, status?: (Array<'offerPending' | 'offerWithdrawn' | 'offerRejected' | 'arranging' | 'current' | 'finished' | 'cancelled'>) | null | undefined, email?: (Array<string>) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, endDateFrom?: (Date) | null | undefined, endDateTo?: (Date) | null | undefined, startDateFrom?: (Date) | null | undefined, startDateTo?: (Date) | null | undefined, metadata?: (Array<string>) | null | undefined};\nexport const getApiTenanciesFn = async ({pageSize, pageNumber, sortBy, fromArchive, embed, id, negotiatorId, applicantId, propertyId, name, nameType, status, email, createdFrom, createdTo, modifiedFrom, modifiedTo, endDateFrom, endDateTo, startDateFrom, startDateTo, metadata}: GetApiTenanciesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${querySerialiser({args:{pageSize, pageNumber, sortBy, fromArchive, embed, id, negotiatorId, applicantId, propertyId, name, nameType, status, email, createdFrom, createdTo, modifiedFrom, modifiedTo, endDateFrom, endDateTo, startDateFrom, startDateTo, metadata}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiTenanciesResponse.parse(data)\n    };\nexport const useGetApiTenancies = ({pageSize, pageNumber, sortBy, fromArchive, embed, id, negotiatorId, applicantId, propertyId, name, nameType, status, email, createdFrom, createdTo, modifiedFrom, modifiedTo, endDateFrom, endDateTo, startDateFrom, startDateTo, metadata}: GetApiTenanciesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Tenancies', pageSize, pageNumber, sortBy, fromArchive, embed, id, negotiatorId, applicantId, propertyId, name, nameType, status, email, createdFrom, createdTo, modifiedFrom, modifiedTo, endDateFrom, endDateTo, startDateFrom, startDateTo, metadata],\n        queryFn: () => getApiTenanciesFn({pageSize, pageNumber, sortBy, fromArchive, embed, id, negotiatorId, applicantId, propertyId, name, nameType, status, email, createdFrom, createdTo, modifiedFrom, modifiedTo, endDateFrom, endDateTo, startDateFrom, startDateTo, metadata}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Tenancies/services/apiTypes.generated.ts": "import { tenancyModelPagedResult } from '@/schemas/tenancyModelPagedResult.generated.tsx'\nimport { CreateTenancyModel, createTenancyModel } from '@/schemas/createTenancyModel.generated.tsx'\nimport { z } from 'zod'\nimport { tenancyContactRelationshipModelPagedResult } from '@/schemas/tenancyContactRelationshipModelPagedResult.generated.tsx'\nimport { tenancyCheckModelPagedResult } from '@/schemas/tenancyCheckModelPagedResult.generated.tsx'\nimport { CreateTenancyCheckModel, createTenancyCheckModel } from '@/schemas/createTenancyCheckModel.generated.tsx'\nimport { tenancyBreakClauseModelPagedResult } from '@/schemas/tenancyBreakClauseModelPagedResult.generated.tsx'\nimport { CreateTenancyBreakClauseModel, createTenancyBreakClauseModel } from '@/schemas/createTenancyBreakClauseModel.generated.tsx'\nimport { tenancyAllowanceModelPagedResult } from '@/schemas/tenancyAllowanceModelPagedResult.generated.tsx'\nimport { CreateTenancyAllowanceModel, createTenancyAllowanceModel } from '@/schemas/createTenancyAllowanceModel.generated.tsx'\nimport { tenancyResponsibilityModelPagedResult } from '@/schemas/tenancyResponsibilityModelPagedResult.generated.tsx'\nimport { CreateTenancyResponsibilityModel, createTenancyResponsibilityModel } from '@/schemas/createTenancyResponsibilityModel.generated.tsx'\nimport { tenancyRenewalModelPagedResult } from '@/schemas/tenancyRenewalModelPagedResult.generated.tsx'\nimport { CreateTenancyRenewalModel, createTenancyRenewalModel } from '@/schemas/createTenancyRenewalModel.generated.tsx'\nimport { tenancyExtensionAlterationModelPagedResult } from '@/schemas/tenancyExtensionAlterationModelPagedResult.generated.tsx'\nimport { tenancyRenewalCheckModelPagedResult } from '@/schemas/tenancyRenewalCheckModelPagedResult.generated.tsx'\nimport { CreateTenancyRenewalCheckModel, createTenancyRenewalCheckModel } from '@/schemas/createTenancyRenewalCheckModel.generated.tsx'\nimport { tenancyModel } from '@/schemas/tenancyModel.generated.tsx'\nimport { tenancyContactRelationshipModel } from '@/schemas/tenancyContactRelationshipModel.generated.tsx'\nimport { tenancyCheckModel } from '@/schemas/tenancyCheckModel.generated.tsx'\nimport { tenancyBreakClauseModel } from '@/schemas/tenancyBreakClauseModel.generated.tsx'\nimport { tenancyAllowanceModel } from '@/schemas/tenancyAllowanceModel.generated.tsx'\nimport { tenancyResponsibilityModel } from '@/schemas/tenancyResponsibilityModel.generated.tsx'\nimport { tenancyRenewalCheckModel } from '@/schemas/tenancyRenewalCheckModel.generated.tsx'\n\nexport const getApiTenanciesResponse = tenancyModelPagedResult;\nexport type CreateApiTenanciesBody = CreateTenancyModel;\nexport const createApiTenanciesBody = createTenancyModel;\nexport const createApiTenanciesResponse = z.void();\nexport const getApiTenanciesIdRelationshipsResponse = tenancyContactRelationshipModelPagedResult;\nexport const getApiTenanciesIdChecksResponse = tenancyCheckModelPagedResult;\nexport type CreateApiTenanciesIdChecksBody = CreateTenancyCheckModel;\nexport const createApiTenanciesIdChecksBody = createTenancyCheckModel;\nexport const createApiTenanciesIdChecksResponse = z.void();\nexport const getApiTenanciesIdBreakClausesResponse = tenancyBreakClauseModelPagedResult;\nexport type CreateApiTenanciesIdBreakClausesBody = CreateTenancyBreakClauseModel;\nexport const createApiTenanciesIdBreakClausesBody = createTenancyBreakClauseModel;\nexport const createApiTenanciesIdBreakClausesResponse = z.void();\nexport const getApiTenanciesIdAllowancesResponse = tenancyAllowanceModelPagedResult;\nexport type CreateApiTenanciesIdAllowancesBody = CreateTenancyAllowanceModel;\nexport const createApiTenanciesIdAllowancesBody = createTenancyAllowanceModel;\nexport const createApiTenanciesIdAllowancesResponse = z.void();\nexport const getApiTenanciesIdResponsibilitiesResponse = tenancyResponsibilityModelPagedResult;\nexport type CreateApiTenanciesIdResponsibilitiesBody = CreateTenancyResponsibilityModel;\nexport const createApiTenanciesIdResponsibilitiesBody = createTenancyResponsibilityModel;\nexport const createApiTenanciesIdResponsibilitiesResponse = z.void();\nexport const getApiTenanciesIdRenewalNegotiationsResponse = tenancyRenewalModelPagedResult;\nexport type CreateApiTenanciesIdRenewalNegotiationsBody = CreateTenancyRenewalModel;\nexport const createApiTenanciesIdRenewalNegotiationsBody = createTenancyRenewalModel;\nexport const createApiTenanciesIdRenewalNegotiationsResponse = z.void();\nexport const getApiTenanciesIdExtensionsResponse = tenancyExtensionAlterationModelPagedResult;\nexport const getApiTenanciesIdRenewalNegotiationsRenewalIdChecksResponse = tenancyRenewalCheckModelPagedResult;\nexport type CreateApiTenanciesIdRenewalNegotiationsRenewalIdChecksBody = CreateTenancyRenewalCheckModel;\nexport const createApiTenanciesIdRenewalNegotiationsRenewalIdChecksBody = createTenancyRenewalCheckModel;\nexport const createApiTenanciesIdRenewalNegotiationsRenewalIdChecksResponse = z.void();\nexport const getApiTenanciesIdResponse = tenancyModel;\nexport const patchApiTenanciesIdResponse = z.void();\nexport const getApiTenanciesIdRelationshipsRelationshipIdResponse = tenancyContactRelationshipModel;\nexport const getApiTenanciesIdChecksCheckIdResponse = tenancyCheckModel;\nexport const deleteApiTenanciesIdChecksCheckIdResponse = z.void();\nexport const patchApiTenanciesIdChecksCheckIdResponse = z.void();\nexport const getApiTenanciesIdBreakClausesClauseIdResponse = tenancyBreakClauseModel;\nexport const deleteApiTenanciesIdBreakClausesClauseIdResponse = z.void();\nexport const patchApiTenanciesIdBreakClausesClauseIdResponse = z.void();\nexport const getApiTenanciesIdAllowancesAllowanceIdResponse = tenancyAllowanceModel;\nexport const deleteApiTenanciesIdAllowancesAllowanceIdResponse = z.void();\nexport const patchApiTenanciesIdAllowancesAllowanceIdResponse = z.void();\nexport const getApiTenanciesIdResponsibilitiesResponsibilityIdResponse = tenancyResponsibilityModel;\nexport const deleteApiTenanciesIdResponsibilitiesResponsibilityIdResponse = z.void();\nexport const patchApiTenanciesIdResponsibilitiesResponsibilityIdResponse = z.void();\nexport const getApiTenanciesIdRenewalNegotiationsRenewalIdResponse = tenancyRenewalModelPagedResult;\nexport const patchApiTenanciesIdRenewalNegotiationsRenewalIdResponse = z.void();\nexport const getApiTenanciesIdExtensionsExtensionIdResponse = tenancyExtensionAlterationModelPagedResult;\nexport const getApiTenanciesIdRenewalNegotiationsRenewalIdChecksCheckIdResponse = tenancyRenewalCheckModel;\nexport const deleteApiTenanciesIdRenewalNegotiationsRenewalIdChecksCheckIdResponse = z.void();\nexport const patchApiTenanciesIdRenewalNegotiationsRenewalIdChecksCheckIdResponse = z.void();",
  "src/schemas/tenancyModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { tenancyModel, TenancyModel } from '@/schemas/tenancyModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const tenancyModelPagedResult = z.object({_embedded: z.array(tenancyModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type TenancyModelPagedResult = {_embedded?: (Array<TenancyModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/tenancyModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\nimport { tenancyLettingFeeModel, TenancyLettingFeeModel } from '@/schemas/tenancyLettingFeeModel.generated.tsx'\nimport { tenancyManagementFeeModel, TenancyManagementFeeModel } from '@/schemas/tenancyManagementFeeModel.generated.tsx'\nimport { tenancySourceModel, TenancySourceModel } from '@/schemas/tenancySourceModel.generated.tsx'\nimport { tenancyDepositModel, TenancyDepositModel } from '@/schemas/tenancyDepositModel.generated.tsx'\nimport { tenancyContactModel, TenancyContactModel } from '@/schemas/tenancyContactModel.generated.tsx'\nimport { renewalOptionsModel, RenewalOptionsModel } from '@/schemas/renewalOptionsModel.generated.tsx'\nimport { tenancyArrearsModel, TenancyArrearsModel } from '@/schemas/tenancyArrearsModel.generated.tsx'\n\nexport const tenancyModel = /** Representation of a tenancy */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the tenancy */\nz.string().optional().nullable(), created: /** The date and time when the tenancy was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the tenancy was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), startDate: /** The start date of the tenancy */\nz.string().optional().nullable(), endDate: /** The end date of the tenancy */\nz.string().optional().nullable(), status: /** The current status of the tenancy (offerPending/offerWithdrawn/offerRejected/arranging/current/finished/cancelled) */\nz.string().optional().nullable(), agentRole: /** The role that the agent is performing for this tenancy (managed/rentCollection/collectFirstPayment/collectRentToDate/lettingOnly/introducingTenant) */\nz.string().optional().nullable(), rent: /** The amount of rent required, returned in relation to the collection frequency\r\nNote that this is the original rent set on the tenancy. For tenancies that have been extended with a rent change you MUST use the extensions endpoint */\nz.number().optional().nullable(), rentFrequency: /** The rent collection frequency (weekly/monthly/annually) */\nz.string().optional().nullable(), endDateConfirmed: /** A flag determining whether or not the tenancy is confirmed to finish at the end date */\nz.boolean().optional().nullable(), isPeriodic: /** A flag determining whether or not the tenancy has been extended indefinitely */\nz.boolean().optional().nullable(), rentInstalmentsFrequency: /** The frequency of rental instalment payments (weekly/fortnightly/monthly/quarterly/halfYearly/yearly/every28Days/other) */\nz.string().optional().nullable(), rentInstalmentsAmount: /** The amount due for each rent instalment (where specified) */\nz.number().optional().nullable(), rentInstalmentsStart: /** The date that the first instalment is due */\nz.string().optional().nullable(), meterReadingGas: /** The recorded utility reading for the gas meter */\nz.string().optional().nullable(), meterReadingGasLastRead: /** Date of when the reading of gas utility was last recorded */\nz.string().optional().nullable(), meterReadingElectricity: /** The recorded utility reading for the electricity meter */\nz.string().optional().nullable(), meterReadingElectricityLastRead: /** Date of when the reading of electricity utility was last recorded */\nz.string().optional().nullable(), meterReadingWater: /** The recorded utility reading for the water meter */\nz.string().optional().nullable(), meterReadingWaterLastRead: /** Date of when the reading of water utility was last recorded */\nz.string().optional().nullable(), typeId: /** The unique identifier of the type of tenancy */\nz.string().optional().nullable(), negotiatorId: /** The unique identifier of the negotiator who is managing the tenancy */\nz.string().optional().nullable(), propertyId: /** The unique identifier of the property that relates to the tenancy */\nz.string().optional().nullable(), applicantId: /** The unique identifier of the applicant who has applied to be a tenant. Whilst the tenancy is an in arranging state, information about the individual such as name and contact details can be obtained from GET /applicants/{id}. Use the link in the _links collection for a relative URI */\nz.string().optional().nullable(), managerId: /** The unique identifier of the negotiator assigned as the manager of the tenancy */\nz.string().optional().nullable(), groupPaymentReference: /** An optional payment reference to be used for transactions related to this tenancy associated with all tenants in the property */\nz.string().optional().nullable(), lettingFee: tenancyLettingFeeModel.optional().nullable(), managementFee: tenancyManagementFeeModel.optional().nullable(), source: tenancySourceModel.optional().nullable(), deposit: tenancyDepositModel.optional().nullable(), related: /** A collection of contact / company tenants associated to the tenancy. The first item in the collection is considered the primary relationship. This collection is only populated once a tenant moves into a property and the tenancy status becomes current */\nz.array(tenancyContactModel).optional().nullable(), fromArchive: /** A flag denoting whether or not this tenancy is archived */\nz.boolean().optional().nullable(), metadata: /** App specific metadata that has been set against the tenancy */\nz.record(z.string(), z.object({})).optional().nullable(), feeNotes: /** Financial notes set against the tenancy */\nz.string().optional().nullable(), legalStatusId: /** The identifier of the legal status to set against the tenancy */\nz.string().optional().nullable(), renewalOptions: renewalOptionsModel.optional().nullable(), arrears: tenancyArrearsModel.optional().nullable(), _eTag: /** The ETag for the current version of the tenancy. Used for managing update concurrency */\nz.string().optional().nullable()});\nexport type TenancyModel = /** Representation of a tenancy */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the tenancy */\nstring) | null | undefined, created?: (/** The date and time when the tenancy was created */\nDate) | null | undefined, modified?: (/** The date and time when the tenancy was last modified */\nDate) | null | undefined, startDate?: (/** The start date of the tenancy */\nstring) | null | undefined, endDate?: (/** The end date of the tenancy */\nstring) | null | undefined, status?: (/** The current status of the tenancy (offerPending/offerWithdrawn/offerRejected/arranging/current/finished/cancelled) */\nstring) | null | undefined, agentRole?: (/** The role that the agent is performing for this tenancy (managed/rentCollection/collectFirstPayment/collectRentToDate/lettingOnly/introducingTenant) */\nstring) | null | undefined, rent?: (/** The amount of rent required, returned in relation to the collection frequency\r\nNote that this is the original rent set on the tenancy. For tenancies that have been extended with a rent change you MUST use the extensions endpoint */\nnumber) | null | undefined, rentFrequency?: (/** The rent collection frequency (weekly/monthly/annually) */\nstring) | null | undefined, endDateConfirmed?: (/** A flag determining whether or not the tenancy is confirmed to finish at the end date */\nboolean) | null | undefined, isPeriodic?: (/** A flag determining whether or not the tenancy has been extended indefinitely */\nboolean) | null | undefined, rentInstalmentsFrequency?: (/** The frequency of rental instalment payments (weekly/fortnightly/monthly/quarterly/halfYearly/yearly/every28Days/other) */\nstring) | null | undefined, rentInstalmentsAmount?: (/** The amount due for each rent instalment (where specified) */\nnumber) | null | undefined, rentInstalmentsStart?: (/** The date that the first instalment is due */\nstring) | null | undefined, meterReadingGas?: (/** The recorded utility reading for the gas meter */\nstring) | null | undefined, meterReadingGasLastRead?: (/** Date of when the reading of gas utility was last recorded */\nstring) | null | undefined, meterReadingElectricity?: (/** The recorded utility reading for the electricity meter */\nstring) | null | undefined, meterReadingElectricityLastRead?: (/** Date of when the reading of electricity utility was last recorded */\nstring) | null | undefined, meterReadingWater?: (/** The recorded utility reading for the water meter */\nstring) | null | undefined, meterReadingWaterLastRead?: (/** Date of when the reading of water utility was last recorded */\nstring) | null | undefined, typeId?: (/** The unique identifier of the type of tenancy */\nstring) | null | undefined, negotiatorId?: (/** The unique identifier of the negotiator who is managing the tenancy */\nstring) | null | undefined, propertyId?: (/** The unique identifier of the property that relates to the tenancy */\nstring) | null | undefined, applicantId?: (/** The unique identifier of the applicant who has applied to be a tenant. Whilst the tenancy is an in arranging state, information about the individual such as name and contact details can be obtained from GET /applicants/{id}. Use the link in the _links collection for a relative URI */\nstring) | null | undefined, managerId?: (/** The unique identifier of the negotiator assigned as the manager of the tenancy */\nstring) | null | undefined, groupPaymentReference?: (/** An optional payment reference to be used for transactions related to this tenancy associated with all tenants in the property */\nstring) | null | undefined, lettingFee?: (TenancyLettingFeeModel) | null | undefined, managementFee?: (TenancyManagementFeeModel) | null | undefined, source?: (TenancySourceModel) | null | undefined, deposit?: (TenancyDepositModel) | null | undefined, related?: (/** A collection of contact / company tenants associated to the tenancy. The first item in the collection is considered the primary relationship. This collection is only populated once a tenant moves into a property and the tenancy status becomes current */\nArray<TenancyContactModel>) | null | undefined, fromArchive?: (/** A flag denoting whether or not this tenancy is archived */\nboolean) | null | undefined, metadata?: (/** App specific metadata that has been set against the tenancy */\nRecord<string, Record<string, never>>) | null | undefined, feeNotes?: (/** Financial notes set against the tenancy */\nstring) | null | undefined, legalStatusId?: (/** The identifier of the legal status to set against the tenancy */\nstring) | null | undefined, renewalOptions?: (RenewalOptionsModel) | null | undefined, arrears?: (TenancyArrearsModel) | null | undefined, _eTag?: (/** The ETag for the current version of the tenancy. Used for managing update concurrency */\nstring) | null | undefined};",
  "src/schemas/tenancyLettingFeeModel.generated.tsx": "import { z } from 'zod'\n\nexport const tenancyLettingFeeModel = /** Representation of the tenancy letting fee */\nz.object({type: /** The letting fee type (percentage/fixed) */\nz.string().optional().nullable(), amount: /** The fee amount */\nz.number().optional().nullable(), frequency: /** The frequency of when the fee is to be collected (upfront/upfrontOver2Months/monthly/quarterly/halfYearly/yearly/28days/other/notApplicable) */\nz.string().optional().nullable()});\nexport type TenancyLettingFeeModel = /** Representation of the tenancy letting fee */\n{type?: (/** The letting fee type (percentage/fixed) */\nstring) | null | undefined, amount?: (/** The fee amount */\nnumber) | null | undefined, frequency?: (/** The frequency of when the fee is to be collected (upfront/upfrontOver2Months/monthly/quarterly/halfYearly/yearly/28days/other/notApplicable) */\nstring) | null | undefined};",
  "src/schemas/tenancyManagementFeeModel.generated.tsx": "import { z } from 'zod'\n\nexport const tenancyManagementFeeModel = /** Representation of the tenancy management fee */\nz.object({type: /** The management fee type (percentage/fixed) */\nz.string().optional().nullable(), amount: /** The fee amount */\nz.number().optional().nullable(), frequency: /** The frequency of when the fee is to be collected (monthly/quarterly/halfYearly/yearly/28days/sameAsLettingFee) */\nz.string().optional().nullable()});\nexport type TenancyManagementFeeModel = /** Representation of the tenancy management fee */\n{type?: (/** The management fee type (percentage/fixed) */\nstring) | null | undefined, amount?: (/** The fee amount */\nnumber) | null | undefined, frequency?: (/** The frequency of when the fee is to be collected (monthly/quarterly/halfYearly/yearly/28days/sameAsLettingFee) */\nstring) | null | undefined};",
  "src/schemas/tenancySourceModel.generated.tsx": "import { z } from 'zod'\n\nexport const tenancySourceModel = /** A tenancy source of enquiry */\nz.object({id: /** The unique identifier of the source for this tenancy */\nz.string().optional().nullable(), type: /** The source type (office/source) */\nz.string().optional().nullable()});\nexport type TenancySourceModel = /** A tenancy source of enquiry */\n{id?: (/** The unique identifier of the source for this tenancy */\nstring) | null | undefined, type?: (/** The source type (office/source) */\nstring) | null | undefined};",
  "src/schemas/tenancyDepositModel.generated.tsx": "import { z } from 'zod'\n\nexport const tenancyDepositModel = /** A tenancy deposit model */\nz.object({heldBy: /** The deposit holder (depositProtectionScheme/stakeholder/landlordsAgent/landlord/notApplicable) */\nz.string().optional().nullable(), period: /** The number of weeks or months rent collected as the deposit on the tenancy */\nz.number().int().optional().nullable(), type: /** The type of deposit (weeksRent/monthsRent/fixedSum/guarantee) */\nz.string().optional().nullable(), sum: /** The amount of deposit held */\nz.number().optional().nullable()});\nexport type TenancyDepositModel = /** A tenancy deposit model */\n{heldBy?: (/** The deposit holder (depositProtectionScheme/stakeholder/landlordsAgent/landlord/notApplicable) */\nstring) | null | undefined, period?: (/** The number of weeks or months rent collected as the deposit on the tenancy */\nnumber) | null | undefined, type?: (/** The type of deposit (weeksRent/monthsRent/fixedSum/guarantee) */\nstring) | null | undefined, sum?: (/** The amount of deposit held */\nnumber) | null | undefined};",
  "src/schemas/tenancyContactModel.generated.tsx": "import { z } from 'zod'\nimport { tenancyContactAddressModel, TenancyContactAddressModel } from '@/schemas/tenancyContactAddressModel.generated.tsx'\nimport { additionalContactDetailModel, AdditionalContactDetailModel } from '@/schemas/additionalContactDetailModel.generated.tsx'\n\nexport const tenancyContactModel = /** A summarised view of the details of a contact or company associated to a tenancy */\nz.object({id: /** The unique identifier of the contact or company */\nz.string().optional().nullable(), name: /** The complete name of the contact or company */\nz.string().optional().nullable(), title: /** The title of the contact (Available when 'type' is 'contact') */\nz.string().optional().nullable(), forename: /** The forename of the contact (Available when 'type' is 'contact') */\nz.string().optional().nullable(), surname: /** The surname of the contact (Available when 'type' is 'contact') */\nz.string().optional().nullable(), dateOfBirth: /** The date of birth of the contact (Available when 'type' is 'contact') */\nz.string().optional().nullable(), type: /** The type of the contact (company/contact) */\nz.string().optional().nullable(), homePhone: /** The home phone number of the contact or company */\nz.string().optional().nullable(), workPhone: /** The work phone number of the contact or company */\nz.string().optional().nullable(), mobilePhone: /** The mobile phone number of the contact or company */\nz.string().optional().nullable(), email: /** The email address of the contact or company */\nz.string().optional().nullable(), paymentReference: /** An optional payment reference to be used for transactions related to this tenancy associated with this tenant */\nz.string().optional().nullable(), fromArchive: /** A flag denoting whether or not this roie on the system is now archived */\nz.boolean().optional().nullable(), marketingConsent: /** The marketing consent status of the contact (grant/deny/notAsked/unknown) */\nz.string().optional().nullable(), primaryAddress: tenancyContactAddressModel.optional().nullable(), occupyOn: /** The date the tenant moved in (or will move in) to the property */\nz.string().optional().nullable(), vacateOn: /** The date the tenant vacated (or is due to vacate) the property */\nz.string().optional().nullable(), additionalContactDetails: /** A collection of additional contact details */\nz.array(additionalContactDetailModel).optional().nullable()});\nexport type TenancyContactModel = /** A summarised view of the details of a contact or company associated to a tenancy */\n{id?: (/** The unique identifier of the contact or company */\nstring) | null | undefined, name?: (/** The complete name of the contact or company */\nstring) | null | undefined, title?: (/** The title of the contact (Available when 'type' is 'contact') */\nstring) | null | undefined, forename?: (/** The forename of the contact (Available when 'type' is 'contact') */\nstring) | null | undefined, surname?: (/** The surname of the contact (Available when 'type' is 'contact') */\nstring) | null | undefined, dateOfBirth?: (/** The date of birth of the contact (Available when 'type' is 'contact') */\nstring) | null | undefined, type?: (/** The type of the contact (company/contact) */\nstring) | null | undefined, homePhone?: (/** The home phone number of the contact or company */\nstring) | null | undefined, workPhone?: (/** The work phone number of the contact or company */\nstring) | null | undefined, mobilePhone?: (/** The mobile phone number of the contact or company */\nstring) | null | undefined, email?: (/** The email address of the contact or company */\nstring) | null | undefined, paymentReference?: (/** An optional payment reference to be used for transactions related to this tenancy associated with this tenant */\nstring) | null | undefined, fromArchive?: (/** A flag denoting whether or not this roie on the system is now archived */\nboolean) | null | undefined, marketingConsent?: (/** The marketing consent status of the contact (grant/deny/notAsked/unknown) */\nstring) | null | undefined, primaryAddress?: (TenancyContactAddressModel) | null | undefined, occupyOn?: (/** The date the tenant moved in (or will move in) to the property */\nstring) | null | undefined, vacateOn?: (/** The date the tenant vacated (or is due to vacate) the property */\nstring) | null | undefined, additionalContactDetails?: (/** A collection of additional contact details */\nArray<AdditionalContactDetailModel>) | null | undefined};",
  "src/schemas/tenancyContactAddressModel.generated.tsx": "import { z } from 'zod'\n\nexport const tenancyContactAddressModel = /** Representation of the physical address of a building or premise */\nz.object({buildingName: /** The building name */\nz.string().optional().nullable(), buildingNumber: /** The building number */\nz.string().optional().nullable(), line1: /** The first line of the address */\nz.string().optional().nullable(), line2: /** The second line of the address */\nz.string().optional().nullable(), line3: /** The third line of the address */\nz.string().optional().nullable(), line4: /** The fourth line of the address */\nz.string().optional().nullable(), postcode: /** The postcode */\nz.string().optional().nullable(), countryId: /** The ISO-3166 country code that the address resides within */\nz.string().optional().nullable()});\nexport type TenancyContactAddressModel = /** Representation of the physical address of a building or premise */\n{buildingName?: (/** The building name */\nstring) | null | undefined, buildingNumber?: (/** The building number */\nstring) | null | undefined, line1?: (/** The first line of the address */\nstring) | null | undefined, line2?: (/** The second line of the address */\nstring) | null | undefined, line3?: (/** The third line of the address */\nstring) | null | undefined, line4?: (/** The fourth line of the address */\nstring) | null | undefined, postcode?: (/** The postcode */\nstring) | null | undefined, countryId?: (/** The ISO-3166 country code that the address resides within */\nstring) | null | undefined};",
  "src/schemas/renewalOptionsModel.generated.tsx": "import { z } from 'zod'\n\nexport const renewalOptionsModel = /** Representation of renewal options in a tenancy */\nz.object({optionId: /** The unique identifier of the renewal option */\nz.string().optional().nullable(), optionText: /** The associated renewal option text */\nz.string().optional().nullable(), expiry: /** The renewal option expiry date */\nz.string().optional().nullable(), conditionIds: /** The renewal options associated condition Ids */\nz.array(z.string().min(1)).optional().nullable()});\nexport type RenewalOptionsModel = /** Representation of renewal options in a tenancy */\n{optionId?: (/** The unique identifier of the renewal option */\nstring) | null | undefined, optionText?: (/** The associated renewal option text */\nstring) | null | undefined, expiry?: (/** The renewal option expiry date */\nstring) | null | undefined, conditionIds?: (/** The renewal options associated condition Ids */\nArray<string>) | null | undefined};",
  "src/schemas/tenancyArrearsModel.generated.tsx": "import { z } from 'zod'\n\nexport const tenancyArrearsModel = /** Representation of tenancy arrears data (populated only when Client Accounts functionality is enabled) */\nz.object({chaseArrears: /** A flag determining whether or not tenancy arrears should be chased */\nz.boolean().optional().nullable(), paymentPlan: /** Indicates whether or not a payment plan is set up for a tenancy in arrears (no/yes/negotiating) */\nz.string().optional().nullable()});\nexport type TenancyArrearsModel = /** Representation of tenancy arrears data (populated only when Client Accounts functionality is enabled) */\n{chaseArrears?: (/** A flag determining whether or not tenancy arrears should be chased */\nboolean) | null | undefined, paymentPlan?: (/** Indicates whether or not a payment plan is set up for a tenancy in arrears (no/yes/negotiating) */\nstring) | null | undefined};",
  "src/sections/Tenancies/forms/CreateTenancies.example.tsx": "import { CreateTenanciesForm, fieldNames, CreateTenanciesFormFields } from '@/sections/Tenancies/forms/CreateTenanciesForm.generated.tsx'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateTenancies = () => {\n      \n\n      \n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateTenanciesForm >\n              <FormLayout>\n                <CreateTenanciesFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateTenanciesForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Tenancies/forms/CreateTenanciesForm.generated.tsx": "import { CreateApiTenanciesBody, createApiTenanciesBody } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { createTenanciesConfig } from '@/sections/Tenancies/config/createTenanciesConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiTenancies } from '@/sections/Tenancies/services/useCreateApiTenancies.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateTenanciesFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiTenanciesBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createTenanciesConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateTenanciesFormProps = {children: ReactNode, defaultValues?: CreateApiTenanciesBody, onSuccess?: () => void};\nexport const CreateTenanciesForm = (props: CreateTenanciesFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiTenanciesBody>({\n        resolver: zodResolver(createApiTenanciesBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiTenancies()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiTenanciesBody>({startDate: true, endDate: true, status: true, agentRole: true, rent: true, rentFrequency: true, rentInstalmentsFrequency: true, rentInstalmentsAmount: true, rentInstalmentsStart: true, meterReadingGas: true, meterReadingGasLastRead: true, meterReadingElectricity: true, meterReadingElectricityLastRead: true, meterReadingWater: true, meterReadingWaterLastRead: true, isPeriodic: true, typeId: true, negotiatorId: true, propertyId: true, applicantId: true, feeNotes: true, lettingFee: true, managementFee: true, deposit: true, source: true, metadata: true});",
  "src/schemas/createTenancyModel.generated.tsx": "import { CreateTenancyLettingFeeModel, createTenancyLettingFeeModel } from '@/schemas/createTenancyLettingFeeModel.generated.tsx'\nimport { CreateTenancyManagementFeeModel, createTenancyManagementFeeModel } from '@/schemas/createTenancyManagementFeeModel.generated.tsx'\nimport { CreateTenancyDepositModel, createTenancyDepositModel } from '@/schemas/createTenancyDepositModel.generated.tsx'\nimport { CreateTenancySourceModel, createTenancySourceModel } from '@/schemas/createTenancySourceModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type CreateTenancyModel = /** Request body used to create a new tenancy */\n{startDate?: (string) | null | undefined, endDate?: (string) | null | undefined, status?: (/** The current status of the tenancy (offerPending/offerWithdrawn/offerRejected/arranging) */\nstring) | null | undefined, agentRole: /** The role that the agent is performing for the tenancy (managed/rentCollection/collectFirstPayment/collectRentToDate/lettingOnly/introducingTenant) */\nstring, rent: /** The amount of rent required, returned in relation to the collection frequency */\nnumber, rentFrequency: /** The rent collection frequency (weekly/monthly/annually) */\nstring, rentInstalmentsFrequency?: (/** The frequency of rental instalment payments (weekly/fortnightly/monthly/quarterly/halfYearly/yearly/every28Days/other) */\nstring) | null | undefined, rentInstalmentsAmount?: (/** The amount due for each rent instalment (where specified) */\nnumber) | null | undefined, rentInstalmentsStart?: (/** The date that the first instalment is due */\nstring) | null | undefined, meterReadingGas?: (/** The recorded utility reading for the gas meter */\nstring) | null | undefined, meterReadingGasLastRead?: (/** Date of when the reading of gas utility was last recorded */\nstring) | null | undefined, meterReadingElectricity?: (/** The recorded utility reading for the electricity meter */\nstring) | null | undefined, meterReadingElectricityLastRead?: (/** Date of when the reading of electricity utility was last recorded */\nstring) | null | undefined, meterReadingWater?: (/** The recorded utility reading for the water meter */\nstring) | null | undefined, meterReadingWaterLastRead?: (/** Date of when the reading of water utility was last recorded */\nstring) | null | undefined, isPeriodic?: (/** A flag determining whether or not the tenancy has been extended indefinitely */\nboolean) | null | undefined, typeId: /** The unique identifier of the type of tenancy */\nstring, negotiatorId: /** The unique identifier of the negotiator who is managing the tenancy */\nstring, propertyId: /** The unique identifier of the property that relates to the tenancy */\nstring, applicantId: /** The unique identifier of the applicant who has applied to be a tenant */\nstring, feeNotes?: (/** Financial notes set against the tenancy */\nstring) | null | undefined, lettingFee?: (CreateTenancyLettingFeeModel) | null | undefined, managementFee?: (CreateTenancyManagementFeeModel) | null | undefined, deposit?: (CreateTenancyDepositModel) | null | undefined, source?: (CreateTenancySourceModel) | null | undefined, metadata?: (/** App specific metadata to set against the tenancy */\nRecord<string, Record<string, never>>) | null | undefined};\nexport const createTenancyModel = /** Request body used to create a new tenancy */\nz.object({startDate: z.string().optional().nullable(), endDate: z.string().optional().nullable(), status: /** The current status of the tenancy (offerPending/offerWithdrawn/offerRejected/arranging) */\nz.string().optional().nullable(), agentRole: /** The role that the agent is performing for the tenancy (managed/rentCollection/collectFirstPayment/collectRentToDate/lettingOnly/introducingTenant) */\nz.string().min(1), rent: /** The amount of rent required, returned in relation to the collection frequency */\nz.number(), rentFrequency: /** The rent collection frequency (weekly/monthly/annually) */\nz.string().min(1), rentInstalmentsFrequency: /** The frequency of rental instalment payments (weekly/fortnightly/monthly/quarterly/halfYearly/yearly/every28Days/other) */\nz.string().optional().nullable(), rentInstalmentsAmount: /** The amount due for each rent instalment (where specified) */\nz.number().optional().nullable(), rentInstalmentsStart: /** The date that the first instalment is due */\nz.string().optional().nullable(), meterReadingGas: /** The recorded utility reading for the gas meter */\nz.string().optional().nullable(), meterReadingGasLastRead: /** Date of when the reading of gas utility was last recorded */\nz.string().optional().nullable(), meterReadingElectricity: /** The recorded utility reading for the electricity meter */\nz.string().optional().nullable(), meterReadingElectricityLastRead: /** Date of when the reading of electricity utility was last recorded */\nz.string().optional().nullable(), meterReadingWater: /** The recorded utility reading for the water meter */\nz.string().optional().nullable(), meterReadingWaterLastRead: /** Date of when the reading of water utility was last recorded */\nz.string().optional().nullable(), isPeriodic: /** A flag determining whether or not the tenancy has been extended indefinitely */\nz.boolean().optional().nullable(), typeId: /** The unique identifier of the type of tenancy */\nz.string().min(1), negotiatorId: /** The unique identifier of the negotiator who is managing the tenancy */\nz.string().min(1), propertyId: /** The unique identifier of the property that relates to the tenancy */\nz.string().min(1), applicantId: /** The unique identifier of the applicant who has applied to be a tenant */\nz.string().min(1), feeNotes: /** Financial notes set against the tenancy */\nz.string().optional().nullable(), lettingFee: createTenancyLettingFeeModel.optional().nullable(), managementFee: createTenancyManagementFeeModel.optional().nullable(), deposit: createTenancyDepositModel.optional().nullable(), source: createTenancySourceModel.optional().nullable(), metadata: /** App specific metadata to set against the tenancy */\nz.record(z.string(), z.object({})).optional().nullable()});",
  "src/schemas/createTenancyLettingFeeModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateTenancyLettingFeeModel = /** Request body used to set letting fees on a new tenancy */\n{type?: (/** The letting fee type (percentage/fixed) */\nstring) | null | undefined, amount?: (/** The fee amount */\nnumber) | null | undefined, frequency?: (/** The frequency of when the fee is to be collected (upfront/upfrontOver2Months/monthly/quarterly/halfYearly/yearly/28days/other/notApplicable) */\nstring) | null | undefined};\nexport const createTenancyLettingFeeModel = /** Request body used to set letting fees on a new tenancy */\nz.object({type: /** The letting fee type (percentage/fixed) */\nz.string().optional().nullable(), amount: /** The fee amount */\nz.number().optional().nullable(), frequency: /** The frequency of when the fee is to be collected (upfront/upfrontOver2Months/monthly/quarterly/halfYearly/yearly/28days/other/notApplicable) */\nz.string().optional().nullable()});",
  "src/schemas/createTenancyManagementFeeModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateTenancyManagementFeeModel = /** Request body used to set management fees on a new tenancy */\n{type?: (/** The management fee type (percentage/fixed) */\nstring) | null | undefined, amount?: (/** The fee amount */\nnumber) | null | undefined, frequency?: (/** The frequency of when the fee is to be collected (monthly/quarterly/halfYearly/yearly/28days/sameAsLettingFee) */\nstring) | null | undefined};\nexport const createTenancyManagementFeeModel = /** Request body used to set management fees on a new tenancy */\nz.object({type: /** The management fee type (percentage/fixed) */\nz.string().optional().nullable(), amount: /** The fee amount */\nz.number().optional().nullable(), frequency: /** The frequency of when the fee is to be collected (monthly/quarterly/halfYearly/yearly/28days/sameAsLettingFee) */\nz.string().optional().nullable()});",
  "src/schemas/createTenancyDepositModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateTenancyDepositModel = /** Request body used to set the deposit of a new tenancy */\n{heldBy?: (/** The deposit holder (depositProtectionScheme/stakeholder/landlordsAgent/landlord/notApplicable) */\nstring) | null | undefined, period?: (/** The number of weeks or months rent collected as the deposit on the tenancy */\nnumber) | null | undefined, type?: (/** The type of deposit (weeksRent/monthsRent/fixedSum/guarantee) */\nstring) | null | undefined, sum?: (/** The amount of deposit held */\nnumber) | null | undefined};\nexport const createTenancyDepositModel = /** Request body used to set the deposit of a new tenancy */\nz.object({heldBy: /** The deposit holder (depositProtectionScheme/stakeholder/landlordsAgent/landlord/notApplicable) */\nz.string().optional().nullable(), period: /** The number of weeks or months rent collected as the deposit on the tenancy */\nz.number().int().optional().nullable(), type: /** The type of deposit (weeksRent/monthsRent/fixedSum/guarantee) */\nz.string().optional().nullable(), sum: /** The amount of deposit held */\nz.number().optional().nullable()});",
  "src/schemas/createTenancySourceModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateTenancySourceModel = /** Request body used to set the source of a new tenancy */\n{id?: (/** The unique identifier of the source for the tenancy */\nstring) | null | undefined, type?: (/** The source type (office/source) */\nstring) | null | undefined};\nexport const createTenancySourceModel = /** Request body used to set the source of a new tenancy */\nz.object({id: /** The unique identifier of the source for the tenancy */\nz.string().optional().nullable(), type: /** The source type (office/source) */\nz.string().optional().nullable()});",
  "src/sections/Tenancies/config/createTenanciesConfig.example.tsx": "import { CreateApiTenanciesBody } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { DateInput } from '@/inputs/DateInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { NumberInput } from '@/inputs/NumberInput.tsx'\nimport { Switch } from '@/inputs/Switch.tsx'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createTenanciesConfig: ModelConfig<CreateApiTenanciesBody> = {startDate: {\n      key: 'startDate',\n      label: 'startDate',\n      defaultValue: null,\n      placeholder: 'startDate',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><DateInput {...props} /></InputWrap>\n    }, endDate: {\n      key: 'endDate',\n      label: 'endDate',\n      defaultValue: null,\n      placeholder: 'endDate',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><DateInput {...props} /></InputWrap>\n    }, status: {\n      key: 'status',\n      label: 'status',\n      defaultValue: '',\n      placeholder: 'status',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, agentRole: {\n      key: 'agentRole',\n      label: 'agentRole',\n      defaultValue: '',\n      placeholder: 'agentRole',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, rent: {\n      key: 'rent',\n      label: 'rent',\n      defaultValue: null,\n      placeholder: 'rent',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><NumberInput {...props} /></InputWrap>\n    }, rentFrequency: {\n      key: 'rentFrequency',\n      label: 'rentFrequency',\n      defaultValue: '',\n      placeholder: 'rentFrequency',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, rentInstalmentsFrequency: {\n      key: 'rentInstalmentsFrequency',\n      label: 'rentInstalmentsFrequency',\n      defaultValue: '',\n      placeholder: 'rentInstalmentsFrequency',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, rentInstalmentsAmount: {\n      key: 'rentInstalmentsAmount',\n      label: 'rentInstalmentsAmount',\n      defaultValue: null,\n      placeholder: 'rentInstalmentsAmount',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><NumberInput {...props} /></InputWrap>\n    }, rentInstalmentsStart: {\n      key: 'rentInstalmentsStart',\n      label: 'rentInstalmentsStart',\n      defaultValue: null,\n      placeholder: 'rentInstalmentsStart',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><DateInput {...props} /></InputWrap>\n    }, meterReadingGas: {\n      key: 'meterReadingGas',\n      label: 'meterReadingGas',\n      defaultValue: '',\n      placeholder: 'meterReadingGas',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, meterReadingGasLastRead: {\n      key: 'meterReadingGasLastRead',\n      label: 'meterReadingGasLastRead',\n      defaultValue: null,\n      placeholder: 'meterReadingGasLastRead',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><DateInput {...props} /></InputWrap>\n    }, meterReadingElectricity: {\n      key: 'meterReadingElectricity',\n      label: 'meterReadingElectricity',\n      defaultValue: '',\n      placeholder: 'meterReadingElectricity',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, meterReadingElectricityLastRead: {\n      key: 'meterReadingElectricityLastRead',\n      label: 'meterReadingElectricityLastRead',\n      defaultValue: null,\n      placeholder: 'meterReadingElectricityLastRead',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><DateInput {...props} /></InputWrap>\n    }, meterReadingWater: {\n      key: 'meterReadingWater',\n      label: 'meterReadingWater',\n      defaultValue: '',\n      placeholder: 'meterReadingWater',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, meterReadingWaterLastRead: {\n      key: 'meterReadingWaterLastRead',\n      label: 'meterReadingWaterLastRead',\n      defaultValue: null,\n      placeholder: 'meterReadingWaterLastRead',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><DateInput {...props} /></InputWrap>\n    }, isPeriodic: {\n      key: 'isPeriodic',\n      label: 'isPeriodic',\n      defaultValue: false,\n      placeholder: 'isPeriodic',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><Switch {...props} /></InputWrap>\n    }, typeId: {\n      key: 'typeId',\n      label: 'typeId',\n      defaultValue: '',\n      placeholder: 'typeId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, negotiatorId: {\n      key: 'negotiatorId',\n      label: 'negotiatorId',\n      defaultValue: '',\n      placeholder: 'negotiatorId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, propertyId: {\n      key: 'propertyId',\n      label: 'propertyId',\n      defaultValue: '',\n      placeholder: 'propertyId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, applicantId: {\n      key: 'applicantId',\n      label: 'applicantId',\n      defaultValue: '',\n      placeholder: 'applicantId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, feeNotes: {\n      key: 'feeNotes',\n      label: 'feeNotes',\n      defaultValue: '',\n      placeholder: 'feeNotes',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, lettingFee: {\n      key: 'lettingFee',\n      label: 'lettingFee',\n      defaultValue: null,\n      placeholder: 'lettingFee',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, managementFee: {\n      key: 'managementFee',\n      label: 'managementFee',\n      defaultValue: null,\n      placeholder: 'managementFee',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, deposit: {\n      key: 'deposit',\n      label: 'deposit',\n      defaultValue: null,\n      placeholder: 'deposit',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, source: {\n      key: 'source',\n      label: 'source',\n      defaultValue: null,\n      placeholder: 'source',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, metadata: {\n      key: 'metadata',\n      label: 'metadata',\n      defaultValue: null,\n      placeholder: 'metadata',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/Tenancies/services/useCreateApiTenancies.generated.ts": "import { CreateTenancyModel } from '@/schemas/createTenancyModel.generated.tsx'\nimport { createApiTenanciesResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiTenanciesFnArgs = {body: CreateTenancyModel};\nexport const createApiTenanciesFn = async ({body}: CreateApiTenanciesFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiTenanciesResponse.parse(data)\n    };\nexport const useCreateApiTenancies = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiTenanciesFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Tenancies']})\n        }\n      })\n    };",
  "src/sections/Tenancies/tables/TenanciesIdRelationshipsTable.generated.tsx": "import { useGetApiTenanciesIdRelationships } from '@/sections/Tenancies/services/useGetApiTenanciesIdRelationships.generated.ts'\nimport { useState } from 'react'\nimport { useParams, useNavigate } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\n\nexport type UseTenanciesIdRelationshipsTableArgs = {id: string};\nexport const useTenanciesIdRelationshipsTable = (args: UseTenanciesIdRelationshipsTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiTenanciesIdRelationships({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const TenanciesIdRelationshipsTable = () => {\n  const {id} = useParams()\n    \n    invariant(id, 'Missing id param')\n    \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useTenanciesIdRelationshipsTable({id}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Tenancies',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New tenanciesIdRelationshipsTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/tenancies/${id}/relationships/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Tenancies/services/useGetApiTenanciesIdRelationships.generated.ts": "import { getApiTenanciesIdRelationshipsResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiTenanciesIdRelationshipsFnArgs = {id: string, pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined};\nexport const getApiTenanciesIdRelationshipsFn = async ({id, pageSize, pageNumber}: GetApiTenanciesIdRelationshipsFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${id}/relationships${querySerialiser({args:{pageSize, pageNumber}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiTenanciesIdRelationshipsResponse.parse(data)\n    };\nexport const useGetApiTenanciesIdRelationships = ({id, pageSize, pageNumber}: GetApiTenanciesIdRelationshipsFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Tenancies', id, pageSize, pageNumber],\n        queryFn: () => getApiTenanciesIdRelationshipsFn({id, pageSize, pageNumber}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/schemas/tenancyContactRelationshipModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { tenancyContactRelationshipModel, TenancyContactRelationshipModel } from '@/schemas/tenancyContactRelationshipModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const tenancyContactRelationshipModelPagedResult = z.object({_embedded: z.array(tenancyContactRelationshipModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type TenancyContactRelationshipModelPagedResult = {_embedded?: (Array<TenancyContactRelationshipModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/tenancyContactRelationshipModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\nimport { guarantorModel, GuarantorModel } from '@/schemas/guarantorModel.generated.tsx'\nimport { referenceModel, ReferenceModel } from '@/schemas/referenceModel.generated.tsx'\n\nexport const tenancyContactRelationshipModel = /** Representation of a relationship between a tenancy and a contact or company */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the tenancy relationship */\nz.string().optional().nullable(), created: /** The date and time when the relationship was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the relationship was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), tenancyId: /** The unique identifier of the tenancy */\nz.string().optional().nullable(), associatedType: /** The type of related entity (contact/company) */\nz.string().optional().nullable(), associatedId: /** The unique identifier of the related contact or company */\nz.string().optional().nullable(), isMain: /** A flag denoting whether or not this contact or company should be regarded as the main tenant */\nz.boolean().optional().nullable(), fromArchive: /** A flag denoting whether or not this relationship is archived */\nz.boolean().optional().nullable(), guarantors: /** Collection of guarantors recorded for this relationship */\nz.array(guarantorModel).optional().nullable(), references: /** Collection of references recorded for this relationship */\nz.array(referenceModel).optional().nullable()});\nexport type TenancyContactRelationshipModel = /** Representation of a relationship between a tenancy and a contact or company */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the tenancy relationship */\nstring) | null | undefined, created?: (/** The date and time when the relationship was created */\nDate) | null | undefined, modified?: (/** The date and time when the relationship was last modified */\nDate) | null | undefined, tenancyId?: (/** The unique identifier of the tenancy */\nstring) | null | undefined, associatedType?: (/** The type of related entity (contact/company) */\nstring) | null | undefined, associatedId?: (/** The unique identifier of the related contact or company */\nstring) | null | undefined, isMain?: (/** A flag denoting whether or not this contact or company should be regarded as the main tenant */\nboolean) | null | undefined, fromArchive?: (/** A flag denoting whether or not this relationship is archived */\nboolean) | null | undefined, guarantors?: (/** Collection of guarantors recorded for this relationship */\nArray<GuarantorModel>) | null | undefined, references?: (/** Collection of references recorded for this relationship */\nArray<ReferenceModel>) | null | undefined};",
  "src/schemas/guarantorModel.generated.tsx": "import { z } from 'zod'\n\nexport const guarantorModel = /** Read model representing a Guarantor */\nz.object({id: /** The identifier for the guarantor record */\nz.string().optional().nullable(), guarantorAssociatedId: /** The identifier for the contact record associated with the guarantor */\nz.string().optional().nullable(), type: /** Value indicating whether a the referenced guarantor is a person or a company */\nz.string().optional().nullable(), referenceStatus: /** The status of the reference requested from the guarantor (notSet/requested/received) */\nz.string().optional().nullable()});\nexport type GuarantorModel = /** Read model representing a Guarantor */\n{id?: (/** The identifier for the guarantor record */\nstring) | null | undefined, guarantorAssociatedId?: (/** The identifier for the contact record associated with the guarantor */\nstring) | null | undefined, type?: (/** Value indicating whether a the referenced guarantor is a person or a company */\nstring) | null | undefined, referenceStatus?: (/** The status of the reference requested from the guarantor (notSet/requested/received) */\nstring) | null | undefined};",
  "src/schemas/referenceModel.generated.tsx": "import { z } from 'zod'\n\nexport const referenceModel = /** Read model representing a tenant/applicant reference */\nz.object({id: /** The identifier for the reference record */\nz.string().optional().nullable(), referenceAssociatedId: /** The identifier for the contact/company record associated with the reference */\nz.string().optional().nullable(), type: /** Value indicating whether a referenced contact is a person or a company */\nz.string().optional().nullable(), referenceStatus: /** The status of the reference (notSet/requested/received) */\nz.string().optional().nullable(), referenceType: /** The type of reference (notSet/accountant/characterReference/employer/previousLandlord) */\nz.string().optional().nullable()});\nexport type ReferenceModel = /** Read model representing a tenant/applicant reference */\n{id?: (/** The identifier for the reference record */\nstring) | null | undefined, referenceAssociatedId?: (/** The identifier for the contact/company record associated with the reference */\nstring) | null | undefined, type?: (/** Value indicating whether a referenced contact is a person or a company */\nstring) | null | undefined, referenceStatus?: (/** The status of the reference (notSet/requested/received) */\nstring) | null | undefined, referenceType?: (/** The type of reference (notSet/accountant/characterReference/employer/previousLandlord) */\nstring) | null | undefined};",
  "src/sections/Tenancies/tables/TenanciesIdChecksTable.generated.tsx": "import { useGetApiTenanciesIdChecks } from '@/sections/Tenancies/services/useGetApiTenanciesIdChecks.generated.ts'\nimport { useState } from 'react'\nimport { useParams, useNavigate } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\n\nexport type UseTenanciesIdChecksTableArgs = {id: string, type?: (string) | null | undefined, status?: (Array<'needed' | 'notNeeded' | 'arranged' | 'completed'>) | null | undefined};\nexport const useTenanciesIdChecksTable = (args: UseTenanciesIdChecksTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiTenanciesIdChecks({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const TenanciesIdChecksTable = () => {\n  const {id} = useParams()\n    \n    invariant(id, 'Missing id param')\n    \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useTenanciesIdChecksTable({id}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Tenancies',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New tenanciesIdChecksTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/tenancies/${id}/checks/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Tenancies/services/useGetApiTenanciesIdChecks.generated.ts": "import { getApiTenanciesIdChecksResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiTenanciesIdChecksFnArgs = {id: string, pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, type?: (string) | null | undefined, status?: (Array<'needed' | 'notNeeded' | 'arranged' | 'completed'>) | null | undefined};\nexport const getApiTenanciesIdChecksFn = async ({id, pageSize, pageNumber, type, status}: GetApiTenanciesIdChecksFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${id}/checks${querySerialiser({args:{pageSize, pageNumber, type, status}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiTenanciesIdChecksResponse.parse(data)\n    };\nexport const useGetApiTenanciesIdChecks = ({id, pageSize, pageNumber, type, status}: GetApiTenanciesIdChecksFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Tenancies', id, pageSize, pageNumber, type, status],\n        queryFn: () => getApiTenanciesIdChecksFn({id, pageSize, pageNumber, type, status}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/schemas/tenancyCheckModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { tenancyCheckModel, TenancyCheckModel } from '@/schemas/tenancyCheckModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const tenancyCheckModelPagedResult = z.object({_embedded: z.array(tenancyCheckModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type TenancyCheckModelPagedResult = {_embedded?: (Array<TenancyCheckModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/tenancyCheckModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\n\nexport const tenancyCheckModel = /** Representation of a tenancy check - a process that needs to happen before a tenancy can commence or ends */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the tenancy check */\nz.string().optional().nullable(), created: /** The date and time when the tenancy check was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the tenancy check was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), description: /** Textual description of what the tenancy check relates to */\nz.string().optional().nullable(), status: /** The status of the tenancy check (needed/notNeeded/arranging/completed) */\nz.string().optional().nullable(), type: /** The type of the tenancy check (preTenancy/postTenancy) */\nz.string().optional().nullable(), checkTypeId: /** The identifier of the pre-configured tenancy check. This will only be populated\r\nfor pre-configured tenancy checks, and not for custom/ad-hoc checks added to individual tenancies */\nz.string().optional().nullable(), tenancyId: /** The unique identifier of the tenancy that this check relates to */\nz.string().optional().nullable(), metadata: /** App specific metadata that has been set against the tenancy check */\nz.record(z.string(), z.object({})).optional().nullable(), _eTag: /** The ETag for the current version of the teanncy check. Used for managing update concurrency */\nz.string().optional().nullable()});\nexport type TenancyCheckModel = /** Representation of a tenancy check - a process that needs to happen before a tenancy can commence or ends */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the tenancy check */\nstring) | null | undefined, created?: (/** The date and time when the tenancy check was created */\nDate) | null | undefined, modified?: (/** The date and time when the tenancy check was last modified */\nDate) | null | undefined, description?: (/** Textual description of what the tenancy check relates to */\nstring) | null | undefined, status?: (/** The status of the tenancy check (needed/notNeeded/arranging/completed) */\nstring) | null | undefined, type?: (/** The type of the tenancy check (preTenancy/postTenancy) */\nstring) | null | undefined, checkTypeId?: (/** The identifier of the pre-configured tenancy check. This will only be populated\r\nfor pre-configured tenancy checks, and not for custom/ad-hoc checks added to individual tenancies */\nstring) | null | undefined, tenancyId?: (/** The unique identifier of the tenancy that this check relates to */\nstring) | null | undefined, metadata?: (/** App specific metadata that has been set against the tenancy check */\nRecord<string, Record<string, never>>) | null | undefined, _eTag?: (/** The ETag for the current version of the teanncy check. Used for managing update concurrency */\nstring) | null | undefined};",
  "src/sections/Tenancies/forms/CreateTenanciesIdChecks.example.tsx": "import { CreateTenanciesIdChecksForm, fieldNames, CreateTenanciesIdChecksFormFields } from '@/sections/Tenancies/forms/CreateTenanciesIdChecksForm.generated.tsx'\nimport { useParams } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateTenanciesIdChecks = () => {\n      const { id } = useParams()\n\n      invariant(id, 'Expected id to be defined')\n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateTenanciesIdChecksForm id={id}>\n              <FormLayout>\n                <CreateTenanciesIdChecksFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateTenanciesIdChecksForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Tenancies/forms/CreateTenanciesIdChecksForm.generated.tsx": "import { CreateApiTenanciesIdChecksBody, createApiTenanciesIdChecksBody } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { createTenanciesIdChecksConfig } from '@/sections/Tenancies/config/createTenanciesIdChecksConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiTenanciesIdChecks } from '@/sections/Tenancies/services/useCreateApiTenanciesIdChecks.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateTenanciesIdChecksFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiTenanciesIdChecksBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createTenanciesIdChecksConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateTenanciesIdChecksFormProps = {id: string, children: ReactNode, defaultValues?: CreateApiTenanciesIdChecksBody, onSuccess?: () => void};\nexport const CreateTenanciesIdChecksForm = (props: CreateTenanciesIdChecksFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiTenanciesIdChecksBody>({\n        resolver: zodResolver(createApiTenanciesIdChecksBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiTenanciesIdChecks()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiTenanciesIdChecksBody>({description: true, type: true, status: true, checkTypeId: true, metadata: true});",
  "src/schemas/createTenancyCheckModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateTenancyCheckModel = /** Request body used to create a new tenancy check */\n{description?: (/** Short, descriptive text describing the purpose of the check. This should be populated\r\nwhen creating a custom tenancy check that does not match any of the existing pre-configured\r\ntenancy check options.\r\nDescription and CheckTypeId must not be supplied in the same payload, but at least one must be provided */\nstring) | null | undefined, type: /** The type of the tenancy check (preTenancy/postTenancy) */\nstring, status: /** The status of the tenancy check (needed/notNeeded/arranging/completed) */\nstring, checkTypeId?: (/** The identifier of the pre-configured tenancy check. This should be populated\r\nwhen an existing tenancy check configuration is desired, rather than a custom one\r\nCheckTypeId and Description must not be supplied in the same payload, but at least one must be provided */\nstring) | null | undefined, metadata?: (/** App specific metadata to set against the tenancy check */\nRecord<string, Record<string, never>>) | null | undefined};\nexport const createTenancyCheckModel = /** Request body used to create a new tenancy check */\nz.object({description: /** Short, descriptive text describing the purpose of the check. This should be populated\r\nwhen creating a custom tenancy check that does not match any of the existing pre-configured\r\ntenancy check options.\r\nDescription and CheckTypeId must not be supplied in the same payload, but at least one must be provided */\nz.string().optional().nullable(), type: /** The type of the tenancy check (preTenancy/postTenancy) */\nz.string().min(1), status: /** The status of the tenancy check (needed/notNeeded/arranging/completed) */\nz.string().min(1), checkTypeId: /** The identifier of the pre-configured tenancy check. This should be populated\r\nwhen an existing tenancy check configuration is desired, rather than a custom one\r\nCheckTypeId and Description must not be supplied in the same payload, but at least one must be provided */\nz.string().optional().nullable(), metadata: /** App specific metadata to set against the tenancy check */\nz.record(z.string(), z.object({})).optional().nullable()});",
  "src/sections/Tenancies/config/createTenanciesIdChecksConfig.example.tsx": "import { CreateApiTenanciesIdChecksBody } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createTenanciesIdChecksConfig: ModelConfig<CreateApiTenanciesIdChecksBody> = {description: {\n      key: 'description',\n      label: 'description',\n      defaultValue: '',\n      placeholder: 'description',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, type: {\n      key: 'type',\n      label: 'type',\n      defaultValue: '',\n      placeholder: 'type',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, status: {\n      key: 'status',\n      label: 'status',\n      defaultValue: '',\n      placeholder: 'status',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, checkTypeId: {\n      key: 'checkTypeId',\n      label: 'checkTypeId',\n      defaultValue: '',\n      placeholder: 'checkTypeId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, metadata: {\n      key: 'metadata',\n      label: 'metadata',\n      defaultValue: null,\n      placeholder: 'metadata',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/Tenancies/services/useCreateApiTenanciesIdChecks.generated.ts": "import { CreateTenancyCheckModel } from '@/schemas/createTenancyCheckModel.generated.tsx'\nimport { createApiTenanciesIdChecksResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiTenanciesIdChecksFnArgs = {id: string, body: CreateTenancyCheckModel};\nexport const createApiTenanciesIdChecksFn = async ({id, body}: CreateApiTenanciesIdChecksFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${id}/checks${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiTenanciesIdChecksResponse.parse(data)\n    };\nexport const useCreateApiTenanciesIdChecks = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiTenanciesIdChecksFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Tenancies']})\n        }\n      })\n    };",
  "src/sections/Tenancies/tables/TenanciesIdBreakClausesTable.generated.tsx": "import { useGetApiTenanciesIdBreakClauses } from '@/sections/Tenancies/services/useGetApiTenanciesIdBreakClauses.generated.ts'\nimport { useState } from 'react'\nimport { useParams, useNavigate } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\n\nexport type UseTenanciesIdBreakClausesTableArgs = {id: string};\nexport const useTenanciesIdBreakClausesTable = (args: UseTenanciesIdBreakClausesTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiTenanciesIdBreakClauses({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const TenanciesIdBreakClausesTable = () => {\n  const {id} = useParams()\n    \n    invariant(id, 'Missing id param')\n    \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useTenanciesIdBreakClausesTable({id}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Tenancies',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New tenanciesIdBreakClausesTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/tenancies/${id}/breakClauses/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Tenancies/services/useGetApiTenanciesIdBreakClauses.generated.ts": "import { getApiTenanciesIdBreakClausesResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiTenanciesIdBreakClausesFnArgs = {id: string, pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined};\nexport const getApiTenanciesIdBreakClausesFn = async ({id, pageSize, pageNumber}: GetApiTenanciesIdBreakClausesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${id}/breakClauses${querySerialiser({args:{pageSize, pageNumber}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiTenanciesIdBreakClausesResponse.parse(data)\n    };\nexport const useGetApiTenanciesIdBreakClauses = ({id, pageSize, pageNumber}: GetApiTenanciesIdBreakClausesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Tenancies', id, pageSize, pageNumber],\n        queryFn: () => getApiTenanciesIdBreakClausesFn({id, pageSize, pageNumber}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/schemas/tenancyBreakClauseModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { tenancyBreakClauseModel, TenancyBreakClauseModel } from '@/schemas/tenancyBreakClauseModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const tenancyBreakClauseModelPagedResult = z.object({_embedded: z.array(tenancyBreakClauseModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type TenancyBreakClauseModelPagedResult = {_embedded?: (Array<TenancyBreakClauseModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/tenancyBreakClauseModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\nimport { tenancyBreakClauseBreakFromModel, TenancyBreakClauseBreakFromModel } from '@/schemas/tenancyBreakClauseBreakFromModel.generated.tsx'\nimport { tenancyBreakClauseNoticeRequiredModel, TenancyBreakClauseNoticeRequiredModel } from '@/schemas/tenancyBreakClauseNoticeRequiredModel.generated.tsx'\nimport { tenancyAgreementModel, TenancyAgreementModel } from '@/schemas/tenancyAgreementModel.generated.tsx'\n\nexport const tenancyBreakClauseModel = /** Representation of a tenancy break clause */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the break clause */\nz.string().optional().nullable(), created: /** The date and time when the break clause was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the break clause last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), clauseTypeId: /** The identifier of the associated break clause */\nz.string().optional().nullable(), description: /** The break clauses description */\nz.string().optional().nullable(), active: /** The date the break clause became (or becomes) active */\nz.string().optional().nullable(), appliesTo: /** The parties that the break clause applies to (landlord/tenant/mutual) */\nz.string().optional().nullable(), letterText: /** Tenancy agreement text relating to the break clause */\nz.string().optional().nullable(), breakFrom: tenancyBreakClauseBreakFromModel.optional().nullable(), noticeRequired: tenancyBreakClauseNoticeRequiredModel.optional().nullable(), agreements: tenancyAgreementModel.optional().nullable(), tenancyId: /** The unique identifier of the associated tenancy */\nz.string().optional().nullable(), _eTag: /** The ETag for the current version of the break clause. Used for managing update concurrency */\nz.string().optional().nullable()});\nexport type TenancyBreakClauseModel = /** Representation of a tenancy break clause */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the break clause */\nstring) | null | undefined, created?: (/** The date and time when the break clause was created */\nDate) | null | undefined, modified?: (/** The date and time when the break clause last modified */\nDate) | null | undefined, clauseTypeId?: (/** The identifier of the associated break clause */\nstring) | null | undefined, description?: (/** The break clauses description */\nstring) | null | undefined, active?: (/** The date the break clause became (or becomes) active */\nstring) | null | undefined, appliesTo?: (/** The parties that the break clause applies to (landlord/tenant/mutual) */\nstring) | null | undefined, letterText?: (/** Tenancy agreement text relating to the break clause */\nstring) | null | undefined, breakFrom?: (TenancyBreakClauseBreakFromModel) | null | undefined, noticeRequired?: (TenancyBreakClauseNoticeRequiredModel) | null | undefined, agreements?: (TenancyAgreementModel) | null | undefined, tenancyId?: (/** The unique identifier of the associated tenancy */\nstring) | null | undefined, _eTag?: (/** The ETag for the current version of the break clause. Used for managing update concurrency */\nstring) | null | undefined};",
  "src/schemas/tenancyBreakClauseBreakFromModel.generated.tsx": "import { z } from 'zod'\n\nexport const tenancyBreakClauseBreakFromModel = /** Representation of a tenancy break clauses break from details */\nz.object({date: /** The earliest date at which the tenant/landlord can end the tenancy agreement */\nz.string().pipe( z.coerce.date() ).optional().nullable(), minTermMonths: /** The minimum number of months from the break clause agreement becoming active at which the tenant/landlord can end the tenancy agreement */\nz.number().int().optional().nullable()});\nexport type TenancyBreakClauseBreakFromModel = /** Representation of a tenancy break clauses break from details */\n{date?: (/** The earliest date at which the tenant/landlord can end the tenancy agreement */\nDate) | null | undefined, minTermMonths?: (/** The minimum number of months from the break clause agreement becoming active at which the tenant/landlord can end the tenancy agreement */\nnumber) | null | undefined};",
  "src/schemas/tenancyBreakClauseNoticeRequiredModel.generated.tsx": "import { z } from 'zod'\n\nexport const tenancyBreakClauseNoticeRequiredModel = /** Representation of a tenancy break clauses notice requirements */\nz.object({date: /** The latest date at which the tenant/landlord must give notice of their decision to end the agreement */\nz.string().pipe( z.coerce.date() ).optional().nullable(), beforeBreakMonths: /** The minimum number of months before the break clause can be invoked at which the tenant/landlord must give notice of their decision to end the tenancy agreement */\nz.number().int().optional().nullable()});\nexport type TenancyBreakClauseNoticeRequiredModel = /** Representation of a tenancy break clauses notice requirements */\n{date?: (/** The latest date at which the tenant/landlord must give notice of their decision to end the agreement */\nDate) | null | undefined, beforeBreakMonths?: (/** The minimum number of months before the break clause can be invoked at which the tenant/landlord must give notice of their decision to end the tenancy agreement */\nnumber) | null | undefined};",
  "src/schemas/tenancyAgreementModel.generated.tsx": "import { z } from 'zod'\n\nexport const tenancyAgreementModel = /** Representation of party agreements to a specific clause in a tenancy agreement */\nz.object({landlord: /** A flag to determine if the landlord has agreed */\nz.boolean().optional().nullable(), tenant: /** A flag to determine if the tenant has agreed */\nz.boolean().optional().nullable()});\nexport type TenancyAgreementModel = /** Representation of party agreements to a specific clause in a tenancy agreement */\n{landlord?: (/** A flag to determine if the landlord has agreed */\nboolean) | null | undefined, tenant?: (/** A flag to determine if the tenant has agreed */\nboolean) | null | undefined};",
  "src/sections/Tenancies/forms/CreateTenanciesIdBreakClauses.example.tsx": "import { CreateTenanciesIdBreakClausesForm, fieldNames, CreateTenanciesIdBreakClausesFormFields } from '@/sections/Tenancies/forms/CreateTenanciesIdBreakClausesForm.generated.tsx'\nimport { useParams } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateTenanciesIdBreakClauses = () => {\n      const { id } = useParams()\n\n      invariant(id, 'Expected id to be defined')\n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateTenanciesIdBreakClausesForm id={id}>\n              <FormLayout>\n                <CreateTenanciesIdBreakClausesFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateTenanciesIdBreakClausesForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Tenancies/forms/CreateTenanciesIdBreakClausesForm.generated.tsx": "import { CreateApiTenanciesIdBreakClausesBody, createApiTenanciesIdBreakClausesBody } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { createTenanciesIdBreakClausesConfig } from '@/sections/Tenancies/config/createTenanciesIdBreakClausesConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiTenanciesIdBreakClauses } from '@/sections/Tenancies/services/useCreateApiTenanciesIdBreakClauses.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateTenanciesIdBreakClausesFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiTenanciesIdBreakClausesBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createTenanciesIdBreakClausesConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateTenanciesIdBreakClausesFormProps = {id: string, children: ReactNode, defaultValues?: CreateApiTenanciesIdBreakClausesBody, onSuccess?: () => void};\nexport const CreateTenanciesIdBreakClausesForm = (props: CreateTenanciesIdBreakClausesFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiTenanciesIdBreakClausesBody>({\n        resolver: zodResolver(createApiTenanciesIdBreakClausesBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiTenanciesIdBreakClauses()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiTenanciesIdBreakClausesBody>({typeId: true, active: true, appliesTo: true, agreements: true, breakFrom: true, noticeRequired: true});",
  "src/schemas/createTenancyBreakClauseModel.generated.tsx": "import { CreateTenancyAgreementModel, createTenancyAgreementModel } from '@/schemas/createTenancyAgreementModel.generated.tsx'\nimport { CreateTenancyBreakFromModel, createTenancyBreakFromModel } from '@/schemas/createTenancyBreakFromModel.generated.tsx'\nimport { CreateTenancyNoticeRequiredModel, createTenancyNoticeRequiredModel } from '@/schemas/createTenancyNoticeRequiredModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type CreateTenancyBreakClauseModel = /** Request body used to update tenancy break clause */\n{typeId?: (/** The identifier of the associated to the break clause */\nstring) | null | undefined, active?: (/** The date the break clause becomes/became active */\nstring) | null | undefined, appliesTo?: (/** The responsible party (landlord/tenant/mutual) */\nstring) | null | undefined, agreements?: (CreateTenancyAgreementModel) | null | undefined, breakFrom?: (CreateTenancyBreakFromModel) | null | undefined, noticeRequired?: (CreateTenancyNoticeRequiredModel) | null | undefined};\nexport const createTenancyBreakClauseModel = /** Request body used to update tenancy break clause */\nz.object({typeId: /** The identifier of the associated to the break clause */\nz.string().optional().nullable(), active: /** The date the break clause becomes/became active */\nz.string().optional().nullable(), appliesTo: /** The responsible party (landlord/tenant/mutual) */\nz.string().optional().nullable(), agreements: createTenancyAgreementModel.optional().nullable(), breakFrom: createTenancyBreakFromModel.optional().nullable(), noticeRequired: createTenancyNoticeRequiredModel.optional().nullable()});",
  "src/schemas/createTenancyAgreementModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateTenancyAgreementModel = /** Request body used to set party agreements to a specific clause in a tenancy agreement */\n{landlord?: (/** A flag to determine if the landlord has agreed */\nboolean) | null | undefined, tenant?: (/** A flag to determine if the tenant has agreed */\nboolean) | null | undefined};\nexport const createTenancyAgreementModel = /** Request body used to set party agreements to a specific clause in a tenancy agreement */\nz.object({landlord: /** A flag to determine if the landlord has agreed */\nz.boolean().optional().nullable(), tenant: /** A flag to determine if the tenant has agreed */\nz.boolean().optional().nullable()});",
  "src/schemas/createTenancyBreakFromModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateTenancyBreakFromModel = /** Request body used to set a break clauses break from details */\n{date?: (/** The date the break from clause can be used */\nstring) | null | undefined, minTermMonths?: (/** The minimum number of months until the break clause can be used */\nnumber) | null | undefined};\nexport const createTenancyBreakFromModel = /** Request body used to set a break clauses break from details */\nz.object({date: /** The date the break from clause can be used */\nz.string().optional().nullable(), minTermMonths: /** The minimum number of months until the break clause can be used */\nz.number().int().optional().nullable()});",
  "src/schemas/createTenancyNoticeRequiredModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateTenancyNoticeRequiredModel = /** Request body used to set a break clauses notice required details */\n{date?: (/** The date a break clauses notice is required by */\nstring) | null | undefined, beforeBreakMonths?: (/** The number of months the notice is required before the break clause */\nnumber) | null | undefined};\nexport const createTenancyNoticeRequiredModel = /** Request body used to set a break clauses notice required details */\nz.object({date: /** The date a break clauses notice is required by */\nz.string().optional().nullable(), beforeBreakMonths: /** The number of months the notice is required before the break clause */\nz.number().int().optional().nullable()});",
  "src/sections/Tenancies/config/createTenanciesIdBreakClausesConfig.example.tsx": "import { CreateApiTenanciesIdBreakClausesBody } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { DateInput } from '@/inputs/DateInput.tsx'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createTenanciesIdBreakClausesConfig: ModelConfig<CreateApiTenanciesIdBreakClausesBody> = {typeId: {\n      key: 'typeId',\n      label: 'typeId',\n      defaultValue: '',\n      placeholder: 'typeId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, active: {\n      key: 'active',\n      label: 'active',\n      defaultValue: null,\n      placeholder: 'active',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><DateInput {...props} /></InputWrap>\n    }, appliesTo: {\n      key: 'appliesTo',\n      label: 'appliesTo',\n      defaultValue: '',\n      placeholder: 'appliesTo',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, agreements: {\n      key: 'agreements',\n      label: 'agreements',\n      defaultValue: null,\n      placeholder: 'agreements',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, breakFrom: {\n      key: 'breakFrom',\n      label: 'breakFrom',\n      defaultValue: null,\n      placeholder: 'breakFrom',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, noticeRequired: {\n      key: 'noticeRequired',\n      label: 'noticeRequired',\n      defaultValue: null,\n      placeholder: 'noticeRequired',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/Tenancies/services/useCreateApiTenanciesIdBreakClauses.generated.ts": "import { CreateTenancyBreakClauseModel } from '@/schemas/createTenancyBreakClauseModel.generated.tsx'\nimport { createApiTenanciesIdBreakClausesResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiTenanciesIdBreakClausesFnArgs = {id: string, body: CreateTenancyBreakClauseModel};\nexport const createApiTenanciesIdBreakClausesFn = async ({id, body}: CreateApiTenanciesIdBreakClausesFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${id}/breakClauses${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiTenanciesIdBreakClausesResponse.parse(data)\n    };\nexport const useCreateApiTenanciesIdBreakClauses = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiTenanciesIdBreakClausesFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Tenancies']})\n        }\n      })\n    };",
  "src/sections/Tenancies/tables/TenanciesIdAllowancesTable.generated.tsx": "import { useGetApiTenanciesIdAllowances } from '@/sections/Tenancies/services/useGetApiTenanciesIdAllowances.generated.ts'\nimport { useState } from 'react'\nimport { useParams, useNavigate } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\n\nexport type UseTenanciesIdAllowancesTableArgs = {id: string};\nexport const useTenanciesIdAllowancesTable = (args: UseTenanciesIdAllowancesTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiTenanciesIdAllowances({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const TenanciesIdAllowancesTable = () => {\n  const {id} = useParams()\n    \n    invariant(id, 'Missing id param')\n    \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useTenanciesIdAllowancesTable({id}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Tenancies',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New tenanciesIdAllowancesTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/tenancies/${id}/allowances/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Tenancies/services/useGetApiTenanciesIdAllowances.generated.ts": "import { getApiTenanciesIdAllowancesResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiTenanciesIdAllowancesFnArgs = {id: string, pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined};\nexport const getApiTenanciesIdAllowancesFn = async ({id, pageSize, pageNumber}: GetApiTenanciesIdAllowancesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${id}/allowances${querySerialiser({args:{pageSize, pageNumber}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiTenanciesIdAllowancesResponse.parse(data)\n    };\nexport const useGetApiTenanciesIdAllowances = ({id, pageSize, pageNumber}: GetApiTenanciesIdAllowancesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Tenancies', id, pageSize, pageNumber],\n        queryFn: () => getApiTenanciesIdAllowancesFn({id, pageSize, pageNumber}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/schemas/tenancyAllowanceModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { tenancyAllowanceModel, TenancyAllowanceModel } from '@/schemas/tenancyAllowanceModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const tenancyAllowanceModelPagedResult = z.object({_embedded: z.array(tenancyAllowanceModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type TenancyAllowanceModelPagedResult = {_embedded?: (Array<TenancyAllowanceModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/tenancyAllowanceModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\nimport { tenancyAgreementModel, TenancyAgreementModel } from '@/schemas/tenancyAgreementModel.generated.tsx'\n\nexport const tenancyAllowanceModel = /** Representation of a tenancy allowance */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the allowance */\nz.string().optional().nullable(), created: /** The date and time when the allowance was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the allowance last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), typeId: /** The identifier of the associated allowance */\nz.string().optional().nullable(), description: /** The break clauses description */\nz.string().optional().nullable(), state: /** The state of the allowance (allowed/notAllowed) */\nz.string().optional().nullable(), agreements: tenancyAgreementModel.optional().nullable(), letterText: /** Tenancy agreement text that relates to the allowance */\nz.string().optional().nullable(), tenancyId: /** The unique identifier of the associated tenancy */\nz.string().optional().nullable(), _eTag: /** The ETag for the current version of the allowance. Used for managing update concurrency */\nz.string().optional().nullable()});\nexport type TenancyAllowanceModel = /** Representation of a tenancy allowance */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the allowance */\nstring) | null | undefined, created?: (/** The date and time when the allowance was created */\nDate) | null | undefined, modified?: (/** The date and time when the allowance last modified */\nDate) | null | undefined, typeId?: (/** The identifier of the associated allowance */\nstring) | null | undefined, description?: (/** The break clauses description */\nstring) | null | undefined, state?: (/** The state of the allowance (allowed/notAllowed) */\nstring) | null | undefined, agreements?: (TenancyAgreementModel) | null | undefined, letterText?: (/** Tenancy agreement text that relates to the allowance */\nstring) | null | undefined, tenancyId?: (/** The unique identifier of the associated tenancy */\nstring) | null | undefined, _eTag?: (/** The ETag for the current version of the allowance. Used for managing update concurrency */\nstring) | null | undefined};",
  "src/sections/Tenancies/forms/CreateTenanciesIdAllowances.example.tsx": "import { CreateTenanciesIdAllowancesForm, fieldNames, CreateTenanciesIdAllowancesFormFields } from '@/sections/Tenancies/forms/CreateTenanciesIdAllowancesForm.generated.tsx'\nimport { useParams } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateTenanciesIdAllowances = () => {\n      const { id } = useParams()\n\n      invariant(id, 'Expected id to be defined')\n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateTenanciesIdAllowancesForm id={id}>\n              <FormLayout>\n                <CreateTenanciesIdAllowancesFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateTenanciesIdAllowancesForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Tenancies/forms/CreateTenanciesIdAllowancesForm.generated.tsx": "import { CreateApiTenanciesIdAllowancesBody, createApiTenanciesIdAllowancesBody } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { createTenanciesIdAllowancesConfig } from '@/sections/Tenancies/config/createTenanciesIdAllowancesConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiTenanciesIdAllowances } from '@/sections/Tenancies/services/useCreateApiTenanciesIdAllowances.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateTenanciesIdAllowancesFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiTenanciesIdAllowancesBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createTenanciesIdAllowancesConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateTenanciesIdAllowancesFormProps = {id: string, children: ReactNode, defaultValues?: CreateApiTenanciesIdAllowancesBody, onSuccess?: () => void};\nexport const CreateTenanciesIdAllowancesForm = (props: CreateTenanciesIdAllowancesFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiTenanciesIdAllowancesBody>({\n        resolver: zodResolver(createApiTenanciesIdAllowancesBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiTenanciesIdAllowances()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiTenanciesIdAllowancesBody>({typeId: true, state: true, agreements: true});",
  "src/schemas/createTenancyAllowanceModel.generated.tsx": "import { CreateTenancyAgreementModel, createTenancyAgreementModel } from '@/schemas/createTenancyAgreementModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type CreateTenancyAllowanceModel = /** Request body used to set a tenancy allowance */\n{typeId?: (/** The identifier of the associated to the allowance */\nstring) | null | undefined, state?: (/** The state of the allowance (allowed/notAllowed) */\nstring) | null | undefined, agreements?: (CreateTenancyAgreementModel) | null | undefined};\nexport const createTenancyAllowanceModel = /** Request body used to set a tenancy allowance */\nz.object({typeId: /** The identifier of the associated to the allowance */\nz.string().optional().nullable(), state: /** The state of the allowance (allowed/notAllowed) */\nz.string().optional().nullable(), agreements: createTenancyAgreementModel.optional().nullable()});",
  "src/sections/Tenancies/config/createTenanciesIdAllowancesConfig.example.tsx": "import { CreateApiTenanciesIdAllowancesBody } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createTenanciesIdAllowancesConfig: ModelConfig<CreateApiTenanciesIdAllowancesBody> = {typeId: {\n      key: 'typeId',\n      label: 'typeId',\n      defaultValue: '',\n      placeholder: 'typeId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, state: {\n      key: 'state',\n      label: 'state',\n      defaultValue: '',\n      placeholder: 'state',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, agreements: {\n      key: 'agreements',\n      label: 'agreements',\n      defaultValue: null,\n      placeholder: 'agreements',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/Tenancies/services/useCreateApiTenanciesIdAllowances.generated.ts": "import { CreateTenancyAllowanceModel } from '@/schemas/createTenancyAllowanceModel.generated.tsx'\nimport { createApiTenanciesIdAllowancesResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiTenanciesIdAllowancesFnArgs = {id: string, body: CreateTenancyAllowanceModel};\nexport const createApiTenanciesIdAllowancesFn = async ({id, body}: CreateApiTenanciesIdAllowancesFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${id}/allowances${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiTenanciesIdAllowancesResponse.parse(data)\n    };\nexport const useCreateApiTenanciesIdAllowances = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiTenanciesIdAllowancesFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Tenancies']})\n        }\n      })\n    };",
  "src/sections/Tenancies/tables/TenanciesIdResponsibilitiesTable.generated.tsx": "import { useGetApiTenanciesIdResponsibilities } from '@/sections/Tenancies/services/useGetApiTenanciesIdResponsibilities.generated.ts'\nimport { useState } from 'react'\nimport { useParams, useNavigate } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\n\nexport type UseTenanciesIdResponsibilitiesTableArgs = {id: string};\nexport const useTenanciesIdResponsibilitiesTable = (args: UseTenanciesIdResponsibilitiesTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiTenanciesIdResponsibilities({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const TenanciesIdResponsibilitiesTable = () => {\n  const {id} = useParams()\n    \n    invariant(id, 'Missing id param')\n    \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useTenanciesIdResponsibilitiesTable({id}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Tenancies',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New tenanciesIdResponsibilitiesTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/tenancies/${id}/responsibilities/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Tenancies/services/useGetApiTenanciesIdResponsibilities.generated.ts": "import { getApiTenanciesIdResponsibilitiesResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiTenanciesIdResponsibilitiesFnArgs = {id: string, pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined};\nexport const getApiTenanciesIdResponsibilitiesFn = async ({id, pageSize, pageNumber}: GetApiTenanciesIdResponsibilitiesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${id}/responsibilities${querySerialiser({args:{pageSize, pageNumber}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiTenanciesIdResponsibilitiesResponse.parse(data)\n    };\nexport const useGetApiTenanciesIdResponsibilities = ({id, pageSize, pageNumber}: GetApiTenanciesIdResponsibilitiesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Tenancies', id, pageSize, pageNumber],\n        queryFn: () => getApiTenanciesIdResponsibilitiesFn({id, pageSize, pageNumber}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/schemas/tenancyResponsibilityModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { tenancyResponsibilityModel, TenancyResponsibilityModel } from '@/schemas/tenancyResponsibilityModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const tenancyResponsibilityModelPagedResult = z.object({_embedded: z.array(tenancyResponsibilityModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type TenancyResponsibilityModelPagedResult = {_embedded?: (Array<TenancyResponsibilityModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/tenancyResponsibilityModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\nimport { tenancyAgreementModel, TenancyAgreementModel } from '@/schemas/tenancyAgreementModel.generated.tsx'\n\nexport const tenancyResponsibilityModel = /** Representation of a tenancies responsibility */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the responsibility */\nz.string().optional().nullable(), created: /** The date and time when the responsibility was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the responsibility last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), typeId: /** The identifier of the associated to the responsibility */\nz.string().optional().nullable(), description: /** The responsibilities description */\nz.string().optional().nullable(), appliesTo: /** The responsible party (landlord/tenant) */\nz.string().optional().nullable(), agreements: tenancyAgreementModel.optional().nullable(), letterText: /** Tenancy agreement text that relates to the responsibility */\nz.string().optional().nullable(), tenancyId: /** The unique identifier of the associated tenancy */\nz.string().optional().nullable(), _eTag: /** The ETag for the current version of the responsibility. Used for managing update concurrency */\nz.string().optional().nullable()});\nexport type TenancyResponsibilityModel = /** Representation of a tenancies responsibility */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the responsibility */\nstring) | null | undefined, created?: (/** The date and time when the responsibility was created */\nDate) | null | undefined, modified?: (/** The date and time when the responsibility last modified */\nDate) | null | undefined, typeId?: (/** The identifier of the associated to the responsibility */\nstring) | null | undefined, description?: (/** The responsibilities description */\nstring) | null | undefined, appliesTo?: (/** The responsible party (landlord/tenant) */\nstring) | null | undefined, agreements?: (TenancyAgreementModel) | null | undefined, letterText?: (/** Tenancy agreement text that relates to the responsibility */\nstring) | null | undefined, tenancyId?: (/** The unique identifier of the associated tenancy */\nstring) | null | undefined, _eTag?: (/** The ETag for the current version of the responsibility. Used for managing update concurrency */\nstring) | null | undefined};",
  "src/sections/Tenancies/forms/CreateTenanciesIdResponsibilities.example.tsx": "import { CreateTenanciesIdResponsibilitiesForm, fieldNames, CreateTenanciesIdResponsibilitiesFormFields } from '@/sections/Tenancies/forms/CreateTenanciesIdResponsibilitiesForm.generated.tsx'\nimport { useParams } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateTenanciesIdResponsibilities = () => {\n      const { id } = useParams()\n\n      invariant(id, 'Expected id to be defined')\n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateTenanciesIdResponsibilitiesForm id={id}>\n              <FormLayout>\n                <CreateTenanciesIdResponsibilitiesFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateTenanciesIdResponsibilitiesForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Tenancies/forms/CreateTenanciesIdResponsibilitiesForm.generated.tsx": "import { CreateApiTenanciesIdResponsibilitiesBody, createApiTenanciesIdResponsibilitiesBody } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { createTenanciesIdResponsibilitiesConfig } from '@/sections/Tenancies/config/createTenanciesIdResponsibilitiesConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiTenanciesIdResponsibilities } from '@/sections/Tenancies/services/useCreateApiTenanciesIdResponsibilities.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateTenanciesIdResponsibilitiesFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiTenanciesIdResponsibilitiesBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createTenanciesIdResponsibilitiesConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateTenanciesIdResponsibilitiesFormProps = {id: string, children: ReactNode, defaultValues?: CreateApiTenanciesIdResponsibilitiesBody, onSuccess?: () => void};\nexport const CreateTenanciesIdResponsibilitiesForm = (props: CreateTenanciesIdResponsibilitiesFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiTenanciesIdResponsibilitiesBody>({\n        resolver: zodResolver(createApiTenanciesIdResponsibilitiesBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiTenanciesIdResponsibilities()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiTenanciesIdResponsibilitiesBody>({typeId: true, appliesTo: true, agreements: true});",
  "src/schemas/createTenancyResponsibilityModel.generated.tsx": "import { CreateTenancyAgreementModel, createTenancyAgreementModel } from '@/schemas/createTenancyAgreementModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type CreateTenancyResponsibilityModel = /** Request body used to set a tenancy responsibility */\n{typeId?: (/** The identifier of the associated to the responsibility */\nstring) | null | undefined, appliesTo?: (/** The responsible party (landlord/tenant) */\nstring) | null | undefined, agreements?: (CreateTenancyAgreementModel) | null | undefined};\nexport const createTenancyResponsibilityModel = /** Request body used to set a tenancy responsibility */\nz.object({typeId: /** The identifier of the associated to the responsibility */\nz.string().optional().nullable(), appliesTo: /** The responsible party (landlord/tenant) */\nz.string().optional().nullable(), agreements: createTenancyAgreementModel.optional().nullable()});",
  "src/sections/Tenancies/config/createTenanciesIdResponsibilitiesConfig.example.tsx": "import { CreateApiTenanciesIdResponsibilitiesBody } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createTenanciesIdResponsibilitiesConfig: ModelConfig<CreateApiTenanciesIdResponsibilitiesBody> = {typeId: {\n      key: 'typeId',\n      label: 'typeId',\n      defaultValue: '',\n      placeholder: 'typeId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, appliesTo: {\n      key: 'appliesTo',\n      label: 'appliesTo',\n      defaultValue: '',\n      placeholder: 'appliesTo',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, agreements: {\n      key: 'agreements',\n      label: 'agreements',\n      defaultValue: null,\n      placeholder: 'agreements',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/Tenancies/services/useCreateApiTenanciesIdResponsibilities.generated.ts": "import { CreateTenancyResponsibilityModel } from '@/schemas/createTenancyResponsibilityModel.generated.tsx'\nimport { createApiTenanciesIdResponsibilitiesResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiTenanciesIdResponsibilitiesFnArgs = {id: string, body: CreateTenancyResponsibilityModel};\nexport const createApiTenanciesIdResponsibilitiesFn = async ({id, body}: CreateApiTenanciesIdResponsibilitiesFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${id}/responsibilities${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiTenanciesIdResponsibilitiesResponse.parse(data)\n    };\nexport const useCreateApiTenanciesIdResponsibilities = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiTenanciesIdResponsibilitiesFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Tenancies']})\n        }\n      })\n    };",
  "src/sections/Tenancies/tables/TenanciesIdRenewalNegotiationsTable.generated.tsx": "import { useGetApiTenanciesIdRenewalNegotiations } from '@/sections/Tenancies/services/useGetApiTenanciesIdRenewalNegotiations.generated.ts'\nimport { useState } from 'react'\nimport { useParams, useNavigate } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\n\nexport type UseTenanciesIdRenewalNegotiationsTableArgs = {id: string};\nexport const useTenanciesIdRenewalNegotiationsTable = (args: UseTenanciesIdRenewalNegotiationsTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiTenanciesIdRenewalNegotiations({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const TenanciesIdRenewalNegotiationsTable = () => {\n  const {id} = useParams()\n    \n    invariant(id, 'Missing id param')\n    \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useTenanciesIdRenewalNegotiationsTable({id}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Tenancies',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New tenanciesIdRenewalNegotiationsTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/tenancies/${id}/renewalNegotiations/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Tenancies/services/useGetApiTenanciesIdRenewalNegotiations.generated.ts": "import { getApiTenanciesIdRenewalNegotiationsResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiTenanciesIdRenewalNegotiationsFnArgs = {id: string, pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined};\nexport const getApiTenanciesIdRenewalNegotiationsFn = async ({id, pageSize, pageNumber}: GetApiTenanciesIdRenewalNegotiationsFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${id}/renewalNegotiations${querySerialiser({args:{pageSize, pageNumber}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiTenanciesIdRenewalNegotiationsResponse.parse(data)\n    };\nexport const useGetApiTenanciesIdRenewalNegotiations = ({id, pageSize, pageNumber}: GetApiTenanciesIdRenewalNegotiationsFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Tenancies', id, pageSize, pageNumber],\n        queryFn: () => getApiTenanciesIdRenewalNegotiationsFn({id, pageSize, pageNumber}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/schemas/tenancyRenewalModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { tenancyRenewalModel, TenancyRenewalModel } from '@/schemas/tenancyRenewalModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const tenancyRenewalModelPagedResult = z.object({_embedded: z.array(tenancyRenewalModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type TenancyRenewalModelPagedResult = {_embedded?: (Array<TenancyRenewalModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/tenancyRenewalModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\nimport { tenancyRentChangeModel, TenancyRentChangeModel } from '@/schemas/tenancyRentChangeModel.generated.tsx'\nimport { tenancyLettingFeeModel, TenancyLettingFeeModel } from '@/schemas/tenancyLettingFeeModel.generated.tsx'\nimport { tenancyManagementFeeModel, TenancyManagementFeeModel } from '@/schemas/tenancyManagementFeeModel.generated.tsx'\n\nexport const tenancyRenewalModel = /** Represents a tenancies renewal negotiation */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the renewal negotiation */\nz.string().optional().nullable(), created: /** The date and time when the renewal was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the renewal was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), startDate: z.string().optional().nullable(), endDate: z.string().optional().nullable(), status: /** The status of the renewal (notStarted/started/negotiating/renewed/tenantTerminated/landlordTerminated/periodic) */\nz.string().optional().nullable(), negotiatorId: /** The unique identifier of the negotiator associated to the renewal */\nz.string().optional().nullable(), rent: /** The tenancies rent amount */\nz.number().optional().nullable(), rentFrequency: /** The rent collection frequency (weekly/monthly/4weeks/annually) */\nz.string().optional().nullable(), rentChange: tenancyRentChangeModel.optional().nullable(), tenancyId: /** The unique identifier of the tenancy associated to the renewal */\nz.string().optional().nullable(), lettingFee: tenancyLettingFeeModel.optional().nullable(), managementFee: tenancyManagementFeeModel.optional().nullable(), _eTag: /** The ETag for the current version of the tenancy renewal. Used for managing update concurrency */\nz.string().optional().nullable()});\nexport type TenancyRenewalModel = /** Represents a tenancies renewal negotiation */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the renewal negotiation */\nstring) | null | undefined, created?: (/** The date and time when the renewal was created */\nDate) | null | undefined, modified?: (/** The date and time when the renewal was last modified */\nDate) | null | undefined, startDate?: (string) | null | undefined, endDate?: (string) | null | undefined, status?: (/** The status of the renewal (notStarted/started/negotiating/renewed/tenantTerminated/landlordTerminated/periodic) */\nstring) | null | undefined, negotiatorId?: (/** The unique identifier of the negotiator associated to the renewal */\nstring) | null | undefined, rent?: (/** The tenancies rent amount */\nnumber) | null | undefined, rentFrequency?: (/** The rent collection frequency (weekly/monthly/4weeks/annually) */\nstring) | null | undefined, rentChange?: (TenancyRentChangeModel) | null | undefined, tenancyId?: (/** The unique identifier of the tenancy associated to the renewal */\nstring) | null | undefined, lettingFee?: (TenancyLettingFeeModel) | null | undefined, managementFee?: (TenancyManagementFeeModel) | null | undefined, _eTag?: (/** The ETag for the current version of the tenancy renewal. Used for managing update concurrency */\nstring) | null | undefined};",
  "src/schemas/tenancyRentChangeModel.generated.tsx": "import { z } from 'zod'\n\nexport const tenancyRentChangeModel = /** Represents rent changes in a tenancies renewal */\nz.object({amount: /** The amount the rent has changed in the renewal */\nz.number().optional().nullable(), percentage: /** The percentage the rent has changed in the renewal */\nz.number().optional().nullable()});\nexport type TenancyRentChangeModel = /** Represents rent changes in a tenancies renewal */\n{amount?: (/** The amount the rent has changed in the renewal */\nnumber) | null | undefined, percentage?: (/** The percentage the rent has changed in the renewal */\nnumber) | null | undefined};",
  "src/sections/Tenancies/forms/CreateTenanciesIdRenewalNegotiations.example.tsx": "import { CreateTenanciesIdRenewalNegotiationsForm, fieldNames, CreateTenanciesIdRenewalNegotiationsFormFields } from '@/sections/Tenancies/forms/CreateTenanciesIdRenewalNegotiationsForm.generated.tsx'\nimport { useParams } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateTenanciesIdRenewalNegotiations = () => {\n      const { id } = useParams()\n\n      invariant(id, 'Expected id to be defined')\n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateTenanciesIdRenewalNegotiationsForm id={id}>\n              <FormLayout>\n                <CreateTenanciesIdRenewalNegotiationsFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateTenanciesIdRenewalNegotiationsForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Tenancies/forms/CreateTenanciesIdRenewalNegotiationsForm.generated.tsx": "import { CreateApiTenanciesIdRenewalNegotiationsBody, createApiTenanciesIdRenewalNegotiationsBody } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { createTenanciesIdRenewalNegotiationsConfig } from '@/sections/Tenancies/config/createTenanciesIdRenewalNegotiationsConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiTenanciesIdRenewalNegotiations } from '@/sections/Tenancies/services/useCreateApiTenanciesIdRenewalNegotiations.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateTenanciesIdRenewalNegotiationsFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiTenanciesIdRenewalNegotiationsBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createTenanciesIdRenewalNegotiationsConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateTenanciesIdRenewalNegotiationsFormProps = {id: string, children: ReactNode, defaultValues?: CreateApiTenanciesIdRenewalNegotiationsBody, onSuccess?: () => void};\nexport const CreateTenanciesIdRenewalNegotiationsForm = (props: CreateTenanciesIdRenewalNegotiationsFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiTenanciesIdRenewalNegotiationsBody>({\n        resolver: zodResolver(createApiTenanciesIdRenewalNegotiationsBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiTenanciesIdRenewalNegotiations()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiTenanciesIdRenewalNegotiationsBody>({startDate: true, endDate: true, negotiatorId: true, rent: true, rentFrequency: true, lettingFee: true, managementFee: true});",
  "src/schemas/createTenancyRenewalModel.generated.tsx": "import { CreateLettingFeeRenewalModel, createLettingFeeRenewalModel } from '@/schemas/createLettingFeeRenewalModel.generated.tsx'\nimport { CreateManagementFeeRenewalModel, createManagementFeeRenewalModel } from '@/schemas/createManagementFeeRenewalModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type CreateTenancyRenewalModel = /** Request body used to create a tenancy renewal negotiation */\n{startDate?: (/** The proposed start date of the tenancy renewal */\nDate) | null | undefined, endDate?: (/** The proposed end date of the tenancy renewal */\nDate) | null | undefined, negotiatorId?: (/** The unique identifier of the negotiator who is managing this tenancy renewal */\nstring) | null | undefined, rent?: (/** The amount of rent required, returned in relation to the collection frequency */\nnumber) | null | undefined, rentFrequency?: (/** The rent collection frequency (weekly/monthly/annually) */\nstring) | null | undefined, lettingFee?: (CreateLettingFeeRenewalModel) | null | undefined, managementFee?: (CreateManagementFeeRenewalModel) | null | undefined};\nexport const createTenancyRenewalModel = /** Request body used to create a tenancy renewal negotiation */\nz.object({startDate: /** The proposed start date of the tenancy renewal */\nz.string().pipe( z.coerce.date() ).optional().nullable(), endDate: /** The proposed end date of the tenancy renewal */\nz.string().pipe( z.coerce.date() ).optional().nullable(), negotiatorId: /** The unique identifier of the negotiator who is managing this tenancy renewal */\nz.string().optional().nullable(), rent: /** The amount of rent required, returned in relation to the collection frequency */\nz.number().optional().nullable(), rentFrequency: /** The rent collection frequency (weekly/monthly/annually) */\nz.string().optional().nullable(), lettingFee: createLettingFeeRenewalModel.optional().nullable(), managementFee: createManagementFeeRenewalModel.optional().nullable()});",
  "src/schemas/createLettingFeeRenewalModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateLettingFeeRenewalModel = /** Request body used to create a tenancy renewals letting fee */\n{type?: (/** The letting fee type (fixed/perentage) */\nstring) | null | undefined, amount?: (/** The letting fee amount as a fixed price or percentage based on the `type` */\nnumber) | null | undefined, frequency?: (/** The frequency at which the letting fee is required (monthly/quarterly/halfYearly/yearly/28days/upfront/upfrontOver2Months/other/notApplicable) */\nstring) | null | undefined};\nexport const createLettingFeeRenewalModel = /** Request body used to create a tenancy renewals letting fee */\nz.object({type: /** The letting fee type (fixed/perentage) */\nz.string().optional().nullable(), amount: /** The letting fee amount as a fixed price or percentage based on the `type` */\nz.number().optional().nullable(), frequency: /** The frequency at which the letting fee is required (monthly/quarterly/halfYearly/yearly/28days/upfront/upfrontOver2Months/other/notApplicable) */\nz.string().optional().nullable()});",
  "src/schemas/createManagementFeeRenewalModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateManagementFeeRenewalModel = /** Request body used to create a tenancy renewals management fee */\n{type?: (/** The mangement fee type (fixed/perentage) */\nstring) | null | undefined, amount?: (/** The mangement fee amount as a fixed price or percentage based on the `type` */\nnumber) | null | undefined, frequency?: (/** The frequency at which the mangement fee is required (monthly/quarterly/halfYearly/yearly/28days/sameAsLettingFee) */\nstring) | null | undefined};\nexport const createManagementFeeRenewalModel = /** Request body used to create a tenancy renewals management fee */\nz.object({type: /** The mangement fee type (fixed/perentage) */\nz.string().optional().nullable(), amount: /** The mangement fee amount as a fixed price or percentage based on the `type` */\nz.number().optional().nullable(), frequency: /** The frequency at which the mangement fee is required (monthly/quarterly/halfYearly/yearly/28days/sameAsLettingFee) */\nz.string().optional().nullable()});",
  "src/sections/Tenancies/config/createTenanciesIdRenewalNegotiationsConfig.example.tsx": "import { CreateApiTenanciesIdRenewalNegotiationsBody } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { NumberInput } from '@/inputs/NumberInput.tsx'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createTenanciesIdRenewalNegotiationsConfig: ModelConfig<CreateApiTenanciesIdRenewalNegotiationsBody> = {startDate: {\n      key: 'startDate',\n      label: 'startDate',\n      defaultValue: null,\n      placeholder: 'startDate',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, endDate: {\n      key: 'endDate',\n      label: 'endDate',\n      defaultValue: null,\n      placeholder: 'endDate',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, negotiatorId: {\n      key: 'negotiatorId',\n      label: 'negotiatorId',\n      defaultValue: '',\n      placeholder: 'negotiatorId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, rent: {\n      key: 'rent',\n      label: 'rent',\n      defaultValue: null,\n      placeholder: 'rent',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><NumberInput {...props} /></InputWrap>\n    }, rentFrequency: {\n      key: 'rentFrequency',\n      label: 'rentFrequency',\n      defaultValue: '',\n      placeholder: 'rentFrequency',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, lettingFee: {\n      key: 'lettingFee',\n      label: 'lettingFee',\n      defaultValue: null,\n      placeholder: 'lettingFee',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, managementFee: {\n      key: 'managementFee',\n      label: 'managementFee',\n      defaultValue: null,\n      placeholder: 'managementFee',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/Tenancies/services/useCreateApiTenanciesIdRenewalNegotiations.generated.ts": "import { CreateTenancyRenewalModel } from '@/schemas/createTenancyRenewalModel.generated.tsx'\nimport { createApiTenanciesIdRenewalNegotiationsResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiTenanciesIdRenewalNegotiationsFnArgs = {id: string, body: CreateTenancyRenewalModel};\nexport const createApiTenanciesIdRenewalNegotiationsFn = async ({id, body}: CreateApiTenanciesIdRenewalNegotiationsFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${id}/renewalNegotiations${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiTenanciesIdRenewalNegotiationsResponse.parse(data)\n    };\nexport const useCreateApiTenanciesIdRenewalNegotiations = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiTenanciesIdRenewalNegotiationsFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Tenancies']})\n        }\n      })\n    };",
  "src/sections/Tenancies/tables/TenanciesIdExtensionsTable.generated.tsx": "import { useGetApiTenanciesIdExtensions } from '@/sections/Tenancies/services/useGetApiTenanciesIdExtensions.generated.ts'\nimport { useState } from 'react'\nimport { useParams, useNavigate } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\n\nexport type UseTenanciesIdExtensionsTableArgs = {id: string};\nexport const useTenanciesIdExtensionsTable = (args: UseTenanciesIdExtensionsTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiTenanciesIdExtensions({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const TenanciesIdExtensionsTable = () => {\n  const {id} = useParams()\n    \n    invariant(id, 'Missing id param')\n    \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useTenanciesIdExtensionsTable({id}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Tenancies',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New tenanciesIdExtensionsTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/tenancies/${id}/extensions/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Tenancies/services/useGetApiTenanciesIdExtensions.generated.ts": "import { getApiTenanciesIdExtensionsResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiTenanciesIdExtensionsFnArgs = {id: string, pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined};\nexport const getApiTenanciesIdExtensionsFn = async ({id, pageSize, pageNumber}: GetApiTenanciesIdExtensionsFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${id}/extensions${querySerialiser({args:{pageSize, pageNumber}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiTenanciesIdExtensionsResponse.parse(data)\n    };\nexport const useGetApiTenanciesIdExtensions = ({id, pageSize, pageNumber}: GetApiTenanciesIdExtensionsFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Tenancies', id, pageSize, pageNumber],\n        queryFn: () => getApiTenanciesIdExtensionsFn({id, pageSize, pageNumber}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/schemas/tenancyExtensionAlterationModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { tenancyExtensionAlterationModel, TenancyExtensionAlterationModel } from '@/schemas/tenancyExtensionAlterationModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const tenancyExtensionAlterationModelPagedResult = z.object({_embedded: z.array(tenancyExtensionAlterationModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type TenancyExtensionAlterationModelPagedResult = {_embedded?: (Array<TenancyExtensionAlterationModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/tenancyExtensionAlterationModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\nimport { tenancyExtensionAlterationFeeModel, TenancyExtensionAlterationFeeModel } from '@/schemas/tenancyExtensionAlterationFeeModel.generated.tsx'\n\nexport const tenancyExtensionAlterationModel = /** Represents a tenancy extension or alteration */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the extension or alteration */\nz.string().optional().nullable(), created: /** The date and time when the extension or alteration was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the extension or alteration was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), startDate: /** The start date of the extension or alteration */\nz.string().optional().nullable(), endDate: /** The end date of the extension (alterations do not have an end date) */\nz.string().optional().nullable(), type: /** The type of entry (extension|alteration) */\nz.string().optional().nullable(), negotiatorId: /** The unique identifier of the negotiator associated to the extension or alteration */\nz.string().optional().nullable(), rent: /** The extension or alteration rent amount */\nz.number().optional().nullable(), rentFrequency: /** The rent frequency (weekly/monthly/4weeks/annually) */\nz.string().optional().nullable(), tenancyId: /** The unique identifier of the tenancy associated to the extension or alteration */\nz.string().optional().nullable(), fee: tenancyExtensionAlterationFeeModel.optional().nullable(), _eTag: /** The ETag for the current version of the tenancy extension or alteration. Used for managing update concurrency */\nz.string().optional().nullable()});\nexport type TenancyExtensionAlterationModel = /** Represents a tenancy extension or alteration */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the extension or alteration */\nstring) | null | undefined, created?: (/** The date and time when the extension or alteration was created */\nDate) | null | undefined, modified?: (/** The date and time when the extension or alteration was last modified */\nDate) | null | undefined, startDate?: (/** The start date of the extension or alteration */\nstring) | null | undefined, endDate?: (/** The end date of the extension (alterations do not have an end date) */\nstring) | null | undefined, type?: (/** The type of entry (extension|alteration) */\nstring) | null | undefined, negotiatorId?: (/** The unique identifier of the negotiator associated to the extension or alteration */\nstring) | null | undefined, rent?: (/** The extension or alteration rent amount */\nnumber) | null | undefined, rentFrequency?: (/** The rent frequency (weekly/monthly/4weeks/annually) */\nstring) | null | undefined, tenancyId?: (/** The unique identifier of the tenancy associated to the extension or alteration */\nstring) | null | undefined, fee?: (TenancyExtensionAlterationFeeModel) | null | undefined, _eTag?: (/** The ETag for the current version of the tenancy extension or alteration. Used for managing update concurrency */\nstring) | null | undefined};",
  "src/schemas/tenancyExtensionAlterationFeeModel.generated.tsx": "import { z } from 'zod'\n\nexport const tenancyExtensionAlterationFeeModel = /** Represents a one off fee associated with tenancy extension or alteration */\nz.object({amount: /** The one fee amount */\nz.number().optional().nullable(), summary: /** The one of fee summary text */\nz.string().optional().nullable(), type: /** The fee type */\nz.string().optional().nullable()});\nexport type TenancyExtensionAlterationFeeModel = /** Represents a one off fee associated with tenancy extension or alteration */\n{amount?: (/** The one fee amount */\nnumber) | null | undefined, summary?: (/** The one of fee summary text */\nstring) | null | undefined, type?: (/** The fee type */\nstring) | null | undefined};",
  "src/sections/Tenancies/tables/TenanciesIdRenewalNegotiationsRenewalIdChecksTable.generated.tsx": "import { useGetApiTenanciesIdRenewalNegotiationsRenewalIdChecks } from '@/sections/Tenancies/services/useGetApiTenanciesIdRenewalNegotiationsRenewalIdChecks.generated.ts'\nimport { useState } from 'react'\nimport { useParams, useNavigate } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\n\nexport type UseTenanciesIdRenewalNegotiationsRenewalIdChecksTableArgs = {id: string, renewalId: string};\nexport const useTenanciesIdRenewalNegotiationsRenewalIdChecksTable = (args: UseTenanciesIdRenewalNegotiationsRenewalIdChecksTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiTenanciesIdRenewalNegotiationsRenewalIdChecks({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const TenanciesIdRenewalNegotiationsRenewalIdChecksTable = () => {\n  const {id, renewalId} = useParams()\n    \n    invariant(id, 'Missing id param')\ninvariant(renewalId, 'Missing renewalId param')\n    \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useTenanciesIdRenewalNegotiationsRenewalIdChecksTable({id, renewalId}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Tenancies',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New tenanciesIdRenewalNegotiationsRenewalIdChecksTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/tenancies/${id}/renewalNegotiations/${renewalId}/checks/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Tenancies/services/useGetApiTenanciesIdRenewalNegotiationsRenewalIdChecks.generated.ts": "import { getApiTenanciesIdRenewalNegotiationsRenewalIdChecksResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiTenanciesIdRenewalNegotiationsRenewalIdChecksFnArgs = {id: string, renewalId: string, pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined};\nexport const getApiTenanciesIdRenewalNegotiationsRenewalIdChecksFn = async ({id, renewalId, pageSize, pageNumber}: GetApiTenanciesIdRenewalNegotiationsRenewalIdChecksFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${id}/renewalNegotiations/${renewalId}/checks${querySerialiser({args:{pageSize, pageNumber}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiTenanciesIdRenewalNegotiationsRenewalIdChecksResponse.parse(data)\n    };\nexport const useGetApiTenanciesIdRenewalNegotiationsRenewalIdChecks = ({id, renewalId, pageSize, pageNumber}: GetApiTenanciesIdRenewalNegotiationsRenewalIdChecksFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Tenancies', id, renewalId, pageSize, pageNumber],\n        queryFn: () => getApiTenanciesIdRenewalNegotiationsRenewalIdChecksFn({id, renewalId, pageSize, pageNumber}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/schemas/tenancyRenewalCheckModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { tenancyRenewalCheckModel, TenancyRenewalCheckModel } from '@/schemas/tenancyRenewalCheckModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const tenancyRenewalCheckModelPagedResult = z.object({_embedded: z.array(tenancyRenewalCheckModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type TenancyRenewalCheckModelPagedResult = {_embedded?: (Array<TenancyRenewalCheckModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/tenancyRenewalCheckModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\n\nexport const tenancyRenewalCheckModel = /** Representation of a tenancy renewal check */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the tenancy renewal check */\nz.string().optional().nullable(), created: /** The date and time when the tenancy renewal check was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the tenancy renewal check was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), status: /** The status of the tenancy renewal check (needed/notNeeded/arranging/completed) */\nz.string().optional().nullable(), description: /** Textual description of what the tenancy renewal check relates to */\nz.string().optional().nullable(), checkTypeId: /** The identifier of the pre-configured tenancy check. This will only be populated\r\nfor pre-configured tenancy checks, and not for custom/ad-hoc checks added to individual tenancies */\nz.string().optional().nullable(), tenancyId: /** The unique identifier of the tenancy that this check relates to */\nz.string().optional().nullable(), renewalId: /** The unique identifier of the renewal that this check relates to */\nz.string().optional().nullable(), metadata: /** App specific metadata that has been set against the tenancy renewal check */\nz.record(z.string(), z.object({})).optional().nullable(), _eTag: /** The ETag for the current version of the teanncy check. Used for managing update concurrency */\nz.string().optional().nullable()});\nexport type TenancyRenewalCheckModel = /** Representation of a tenancy renewal check */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the tenancy renewal check */\nstring) | null | undefined, created?: (/** The date and time when the tenancy renewal check was created */\nDate) | null | undefined, modified?: (/** The date and time when the tenancy renewal check was last modified */\nDate) | null | undefined, status?: (/** The status of the tenancy renewal check (needed/notNeeded/arranging/completed) */\nstring) | null | undefined, description?: (/** Textual description of what the tenancy renewal check relates to */\nstring) | null | undefined, checkTypeId?: (/** The identifier of the pre-configured tenancy check. This will only be populated\r\nfor pre-configured tenancy checks, and not for custom/ad-hoc checks added to individual tenancies */\nstring) | null | undefined, tenancyId?: (/** The unique identifier of the tenancy that this check relates to */\nstring) | null | undefined, renewalId?: (/** The unique identifier of the renewal that this check relates to */\nstring) | null | undefined, metadata?: (/** App specific metadata that has been set against the tenancy renewal check */\nRecord<string, Record<string, never>>) | null | undefined, _eTag?: (/** The ETag for the current version of the teanncy check. Used for managing update concurrency */\nstring) | null | undefined};",
  "src/sections/Tenancies/forms/CreateTenanciesIdRenewalNegotiationsRenewalIdChecks.example.tsx": "import { CreateTenanciesIdRenewalNegotiationsRenewalIdChecksForm, fieldNames, CreateTenanciesIdRenewalNegotiationsRenewalIdChecksFormFields } from '@/sections/Tenancies/forms/CreateTenanciesIdRenewalNegotiationsRenewalIdChecksForm.generated.tsx'\nimport { useParams } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateTenanciesIdRenewalNegotiationsRenewalIdChecks = () => {\n      const { id, renewalId } = useParams()\n\n      invariant(id, 'Expected id to be defined')\ninvariant(renewalId, 'Expected renewalId to be defined')\n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateTenanciesIdRenewalNegotiationsRenewalIdChecksForm id={id} renewalId={renewalId}>\n              <FormLayout>\n                <CreateTenanciesIdRenewalNegotiationsRenewalIdChecksFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateTenanciesIdRenewalNegotiationsRenewalIdChecksForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Tenancies/forms/CreateTenanciesIdRenewalNegotiationsRenewalIdChecksForm.generated.tsx": "import { CreateApiTenanciesIdRenewalNegotiationsRenewalIdChecksBody, createApiTenanciesIdRenewalNegotiationsRenewalIdChecksBody } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { createTenanciesIdRenewalNegotiationsRenewalIdChecksConfig } from '@/sections/Tenancies/config/createTenanciesIdRenewalNegotiationsRenewalIdChecksConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiTenanciesIdRenewalNegotiationsRenewalIdChecks } from '@/sections/Tenancies/services/useCreateApiTenanciesIdRenewalNegotiationsRenewalIdChecks.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateTenanciesIdRenewalNegotiationsRenewalIdChecksFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiTenanciesIdRenewalNegotiationsRenewalIdChecksBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createTenanciesIdRenewalNegotiationsRenewalIdChecksConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateTenanciesIdRenewalNegotiationsRenewalIdChecksFormProps = {id: string, renewalId: string, children: ReactNode, defaultValues?: CreateApiTenanciesIdRenewalNegotiationsRenewalIdChecksBody, onSuccess?: () => void};\nexport const CreateTenanciesIdRenewalNegotiationsRenewalIdChecksForm = (props: CreateTenanciesIdRenewalNegotiationsRenewalIdChecksFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiTenanciesIdRenewalNegotiationsRenewalIdChecksBody>({\n        resolver: zodResolver(createApiTenanciesIdRenewalNegotiationsRenewalIdChecksBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiTenanciesIdRenewalNegotiationsRenewalIdChecks()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiTenanciesIdRenewalNegotiationsRenewalIdChecksBody>({status: true, checkTypeId: true, description: true, metadata: true});",
  "src/schemas/createTenancyRenewalCheckModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateTenancyRenewalCheckModel = /** Request body used to create a new tenancy renewal check */\n{status: /** The status of the tenancy check (needed/notNeeded/arranging/completed) */\nstring, checkTypeId?: (/** The identifier of the pre-configured tenancy check. This will only be populated\r\nfor pre-configured tenancy checks, and not for custom/ad-hoc checks added to individual tenancies */\nstring) | null | undefined, description?: (/** The name of this tenancy check */\nstring) | null | undefined, metadata?: (/** App specific metadata to set against the tenancy renewal check */\nRecord<string, Record<string, never>>) | null | undefined};\nexport const createTenancyRenewalCheckModel = /** Request body used to create a new tenancy renewal check */\nz.object({status: /** The status of the tenancy check (needed/notNeeded/arranging/completed) */\nz.string().min(1), checkTypeId: /** The identifier of the pre-configured tenancy check. This will only be populated\r\nfor pre-configured tenancy checks, and not for custom/ad-hoc checks added to individual tenancies */\nz.string().optional().nullable(), description: /** The name of this tenancy check */\nz.string().optional().nullable(), metadata: /** App specific metadata to set against the tenancy renewal check */\nz.record(z.string(), z.object({})).optional().nullable()});",
  "src/sections/Tenancies/config/createTenanciesIdRenewalNegotiationsRenewalIdChecksConfig.example.tsx": "import { CreateApiTenanciesIdRenewalNegotiationsRenewalIdChecksBody } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createTenanciesIdRenewalNegotiationsRenewalIdChecksConfig: ModelConfig<CreateApiTenanciesIdRenewalNegotiationsRenewalIdChecksBody> = {status: {\n      key: 'status',\n      label: 'status',\n      defaultValue: '',\n      placeholder: 'status',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, checkTypeId: {\n      key: 'checkTypeId',\n      label: 'checkTypeId',\n      defaultValue: '',\n      placeholder: 'checkTypeId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, description: {\n      key: 'description',\n      label: 'description',\n      defaultValue: '',\n      placeholder: 'description',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, metadata: {\n      key: 'metadata',\n      label: 'metadata',\n      defaultValue: null,\n      placeholder: 'metadata',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/Tenancies/services/useCreateApiTenanciesIdRenewalNegotiationsRenewalIdChecks.generated.ts": "import { CreateTenancyRenewalCheckModel } from '@/schemas/createTenancyRenewalCheckModel.generated.tsx'\nimport { createApiTenanciesIdRenewalNegotiationsRenewalIdChecksResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiTenanciesIdRenewalNegotiationsRenewalIdChecksFnArgs = {id: string, renewalId: string, body: CreateTenancyRenewalCheckModel};\nexport const createApiTenanciesIdRenewalNegotiationsRenewalIdChecksFn = async ({id, renewalId, body}: CreateApiTenanciesIdRenewalNegotiationsRenewalIdChecksFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${id}/renewalNegotiations/${renewalId}/checks${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiTenanciesIdRenewalNegotiationsRenewalIdChecksResponse.parse(data)\n    };\nexport const useCreateApiTenanciesIdRenewalNegotiationsRenewalIdChecks = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiTenanciesIdRenewalNegotiationsRenewalIdChecksFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Tenancies']})\n        }\n      })\n    };",
  "src/sections/Transactions/tables/TransactionsTable.generated.tsx": "import { useGetApiTransactions } from '@/sections/Transactions/services/useGetApiTransactions.generated.ts'\nimport { useState } from 'react'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\nimport { useNavigate } from 'react-router-dom'\n\nexport type UseTransactionsTableArgs = {sortBy?: (string) | null | undefined, id?: (Array<string>) | null | undefined, propertyId?: (Array<string>) | null | undefined, landlordId?: (Array<string>) | null | undefined, tenancyId?: (Array<string>) | null | undefined, status?: (Array<'awaitingAuthorisation' | 'awaitingPosting' | 'posted' | 'rejected'>) | null | undefined, type?: (Array<'creditAdjustment' | 'creditNoteCorrection' | 'creditNoteGoodwillPayment' | 'creditNoteRefund' | 'creditNoteRepayment' | 'creditNoteWriteOff' | 'debitAdjustment' | 'deposit' | 'float' | 'invoice' | 'journal' | 'openingBalanceDr' | 'openingBalancingCr' | 'payment' | 'reserveFunds' | 'transfer'>) | null | undefined, ledger?: (Array<'landlord' | 'tenant' | 'vendor'>) | null | undefined, category?: (Array<'advertisingCharge' | 'accountTransfer' | 'bankCharges' | 'buyerAdminFee' | 'buyerDeposit' | 'buyerPayment' | 'deposit' | 'depositDeduction' | 'depositRefund' | 'depositTransfer' | 'depositTransferToAgent' | 'depositTransferToLandlord' | 'depositTransferToScheme' | 'estateServiceCharge' | 'estateWorksOrder' | 'estateUnitWorksOrder' | 'externalCredit' | 'externalAgentFee' | 'freeholderPayment' | 'float' | 'groundRent' | 'goodwillPayment' | 'holdingDeposit' | 'introducingTenantFee' | 'landlordAdminFee' | 'landlordTax' | 'landlordPayment' | 'landlordToSupplierPayment' | 'landlordWorksOrder' | 'leaseholderAdminFee' | 'leaseholderPayment' | 'leaseholderRepayment' | 'leaseholderWorksOrder' | 'lettingFee' | 'managementFee' | 'paymentSurcharge' | 'receipt' | 'rent' | 'rentGuarantee' | 'rentInsurance' | 'recoveryPayment' | 'reserveFund' | 'tenantAdminFee' | 'tenantPayment' | 'tenantToLandlordPayment' | 'tenantToSupplierPayment' | 'trustAccountingInvoice' | 'tenantWorksOrder' | 'vacantManagementFee' | 'vendorAdminFee' | 'vendorCommission' | 'vendorPayment' | 'vendorToSupplierPayment' | 'worksOrderPayment'>) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, outstandingFrom?: (number) | null | undefined, outstandingTo?: (number) | null | undefined};\nexport const useTransactionsTable = (args: UseTransactionsTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiTransactions({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const TransactionsTable = () => {\n  \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useTransactionsTable({}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Transactions',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New transactionsTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/transactions/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Transactions/services/useGetApiTransactions.generated.ts": "import { getApiTransactionsResponse } from '@/sections/Transactions/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiTransactionsFnArgs = {pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, sortBy?: (string) | null | undefined, id?: (Array<string>) | null | undefined, propertyId?: (Array<string>) | null | undefined, landlordId?: (Array<string>) | null | undefined, tenancyId?: (Array<string>) | null | undefined, status?: (Array<'awaitingAuthorisation' | 'awaitingPosting' | 'posted' | 'rejected'>) | null | undefined, type?: (Array<'creditAdjustment' | 'creditNoteCorrection' | 'creditNoteGoodwillPayment' | 'creditNoteRefund' | 'creditNoteRepayment' | 'creditNoteWriteOff' | 'debitAdjustment' | 'deposit' | 'float' | 'invoice' | 'journal' | 'openingBalanceDr' | 'openingBalancingCr' | 'payment' | 'reserveFunds' | 'transfer'>) | null | undefined, ledger?: (Array<'landlord' | 'tenant' | 'vendor'>) | null | undefined, category?: (Array<'advertisingCharge' | 'accountTransfer' | 'bankCharges' | 'buyerAdminFee' | 'buyerDeposit' | 'buyerPayment' | 'deposit' | 'depositDeduction' | 'depositRefund' | 'depositTransfer' | 'depositTransferToAgent' | 'depositTransferToLandlord' | 'depositTransferToScheme' | 'estateServiceCharge' | 'estateWorksOrder' | 'estateUnitWorksOrder' | 'externalCredit' | 'externalAgentFee' | 'freeholderPayment' | 'float' | 'groundRent' | 'goodwillPayment' | 'holdingDeposit' | 'introducingTenantFee' | 'landlordAdminFee' | 'landlordTax' | 'landlordPayment' | 'landlordToSupplierPayment' | 'landlordWorksOrder' | 'leaseholderAdminFee' | 'leaseholderPayment' | 'leaseholderRepayment' | 'leaseholderWorksOrder' | 'lettingFee' | 'managementFee' | 'paymentSurcharge' | 'receipt' | 'rent' | 'rentGuarantee' | 'rentInsurance' | 'recoveryPayment' | 'reserveFund' | 'tenantAdminFee' | 'tenantPayment' | 'tenantToLandlordPayment' | 'tenantToSupplierPayment' | 'trustAccountingInvoice' | 'tenantWorksOrder' | 'vacantManagementFee' | 'vendorAdminFee' | 'vendorCommission' | 'vendorPayment' | 'vendorToSupplierPayment' | 'worksOrderPayment'>) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, outstandingFrom?: (number) | null | undefined, outstandingTo?: (number) | null | undefined};\nexport const getApiTransactionsFn = async ({pageSize, pageNumber, sortBy, id, propertyId, landlordId, tenancyId, status, type, ledger, category, createdFrom, createdTo, modifiedFrom, modifiedTo, outstandingFrom, outstandingTo}: GetApiTransactionsFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/transactions/${querySerialiser({args:{pageSize, pageNumber, sortBy, id, propertyId, landlordId, tenancyId, status, type, ledger, category, createdFrom, createdTo, modifiedFrom, modifiedTo, outstandingFrom, outstandingTo}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiTransactionsResponse.parse(data)\n    };\nexport const useGetApiTransactions = ({pageSize, pageNumber, sortBy, id, propertyId, landlordId, tenancyId, status, type, ledger, category, createdFrom, createdTo, modifiedFrom, modifiedTo, outstandingFrom, outstandingTo}: GetApiTransactionsFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Transactions', pageSize, pageNumber, sortBy, id, propertyId, landlordId, tenancyId, status, type, ledger, category, createdFrom, createdTo, modifiedFrom, modifiedTo, outstandingFrom, outstandingTo],\n        queryFn: () => getApiTransactionsFn({pageSize, pageNumber, sortBy, id, propertyId, landlordId, tenancyId, status, type, ledger, category, createdFrom, createdTo, modifiedFrom, modifiedTo, outstandingFrom, outstandingTo}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Transactions/services/apiTypes.generated.ts": "import { transactionModelPagedResult } from '@/schemas/transactionModelPagedResult.generated.tsx'\nimport { nominalAccountModelPagedResult } from '@/schemas/nominalAccountModelPagedResult.generated.tsx'\nimport { CreateSupplierInvoiceModel, createSupplierInvoiceModel } from '@/schemas/createSupplierInvoiceModel.generated.tsx'\nimport { z } from 'zod'\nimport { transactionModel } from '@/schemas/transactionModel.generated.tsx'\nimport { nominalAccountModel } from '@/schemas/nominalAccountModel.generated.tsx'\n\nexport const getApiTransactionsResponse = transactionModelPagedResult;\nexport const getApiTransactionsNominalAccountsResponse = nominalAccountModelPagedResult;\nexport type CreateApiTransactionsSupplierInvoicesBody = CreateSupplierInvoiceModel;\nexport const createApiTransactionsSupplierInvoicesBody = createSupplierInvoiceModel;\nexport const createApiTransactionsSupplierInvoicesResponse = z.void();\nexport const getApiTransactionsIdResponse = transactionModel;\nexport const getApiTransactionsNominalAccountsIdResponse = nominalAccountModel;",
  "src/schemas/transactionModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { transactionModel, TransactionModel } from '@/schemas/transactionModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const transactionModelPagedResult = z.object({_embedded: z.array(transactionModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type TransactionModelPagedResult = {_embedded?: (Array<TransactionModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/transactionModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\n\nexport const transactionModel = /** Model representing a transaction */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the transaction */\nz.string().optional().nullable(), created: /** The date and time when the transaction was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the transaction was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), category: /** The transaction category (advertisingCharge,accountTransfer,bankCharges,buyerAdminFee,buyerDeposit,buyerPayment,deposit,depositDeduction,depositRefund,depositTransfer,depositTransferToAgent,depositTransferToLandlord,depositTransferToScheme,estateServiceCharge,estateWorksOrder,estateUnitWorksOrder,externalCredit,externalAgentFee,freeholderPayment,float,groundRent,goodwillPayment,holdingDeposit,introducingTenantFee,landlordAdminFee,landlordTax,landlordPayment,landlordToSupplierPayment,landlordWorksOrder,leaseholderAdminFee,leaseholderPayment,leaseholderRepayment,leaseholderWorksOrder,lettingFee,managementFee,paymentSurcharge,receipt,rent,rentGuarantee,recoveryPayment,reserveFund,tenantAdminFee,tenantPayment,tenantToLandlordPayment,tenantToSupplierPayment,trustAccountingInvoice,tenantWorksOrder,vacantManagementFee,vendorAdminFee,vendorCommission,vendorPayment,vendorToSupplierPayment,worksOrderPayment) */\nz.string().optional().nullable(), type: /** The transaction type (bankersDraft,bankTransfer,cash,cheque,creditCard,debitCard,directDebit,housingBenefit,paymentRequest,standingOrder) */\nz.string().optional().nullable(), transactionType: /** The type of transaction (credit/debit) */\nz.string().optional().nullable(), description: /** The transaction description */\nz.string().optional().nullable(), status: /** The status of the transaction (awaitingAuthorisation/awaitingPosting/posted/rejected) */\nz.string().optional().nullable(), ledger: /** The ledger the transaction is recorded in */\nz.string().optional().nullable(), netAmount: /** The transaction net amount */\nz.number().optional().nullable(), taxAmount: /** The transaction tax amount */\nz.number().optional().nullable(), grossAmount: /** The transaction gross amount */\nz.number().optional().nullable(), outstanding: /** The amount outstanding that remains to be paid */\nz.number().optional().nullable(), companyId: /** The unique identifier of the company the transaction is associated with, where applicable */\nz.string().optional().nullable(), landlordId: /** The unique identifier of the landlord the transaction is associated with, where applicable */\nz.string().optional().nullable(), propertyId: /** The unique identifier of the property the transaction is associated with, where applicable */\nz.string().optional().nullable(), tenancyId: /** The unique identifier of the tenancy the transaction is associated with, where applicable */\nz.string().optional().nullable(), _eTag: /** The ETag for the current version of the transaction. Used for managing update concurrency */\nz.string().optional().nullable()});\nexport type TransactionModel = /** Model representing a transaction */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the transaction */\nstring) | null | undefined, created?: (/** The date and time when the transaction was created */\nDate) | null | undefined, modified?: (/** The date and time when the transaction was last modified */\nDate) | null | undefined, category?: (/** The transaction category (advertisingCharge,accountTransfer,bankCharges,buyerAdminFee,buyerDeposit,buyerPayment,deposit,depositDeduction,depositRefund,depositTransfer,depositTransferToAgent,depositTransferToLandlord,depositTransferToScheme,estateServiceCharge,estateWorksOrder,estateUnitWorksOrder,externalCredit,externalAgentFee,freeholderPayment,float,groundRent,goodwillPayment,holdingDeposit,introducingTenantFee,landlordAdminFee,landlordTax,landlordPayment,landlordToSupplierPayment,landlordWorksOrder,leaseholderAdminFee,leaseholderPayment,leaseholderRepayment,leaseholderWorksOrder,lettingFee,managementFee,paymentSurcharge,receipt,rent,rentGuarantee,recoveryPayment,reserveFund,tenantAdminFee,tenantPayment,tenantToLandlordPayment,tenantToSupplierPayment,trustAccountingInvoice,tenantWorksOrder,vacantManagementFee,vendorAdminFee,vendorCommission,vendorPayment,vendorToSupplierPayment,worksOrderPayment) */\nstring) | null | undefined, type?: (/** The transaction type (bankersDraft,bankTransfer,cash,cheque,creditCard,debitCard,directDebit,housingBenefit,paymentRequest,standingOrder) */\nstring) | null | undefined, transactionType?: (/** The type of transaction (credit/debit) */\nstring) | null | undefined, description?: (/** The transaction description */\nstring) | null | undefined, status?: (/** The status of the transaction (awaitingAuthorisation/awaitingPosting/posted/rejected) */\nstring) | null | undefined, ledger?: (/** The ledger the transaction is recorded in */\nstring) | null | undefined, netAmount?: (/** The transaction net amount */\nnumber) | null | undefined, taxAmount?: (/** The transaction tax amount */\nnumber) | null | undefined, grossAmount?: (/** The transaction gross amount */\nnumber) | null | undefined, outstanding?: (/** The amount outstanding that remains to be paid */\nnumber) | null | undefined, companyId?: (/** The unique identifier of the company the transaction is associated with, where applicable */\nstring) | null | undefined, landlordId?: (/** The unique identifier of the landlord the transaction is associated with, where applicable */\nstring) | null | undefined, propertyId?: (/** The unique identifier of the property the transaction is associated with, where applicable */\nstring) | null | undefined, tenancyId?: (/** The unique identifier of the tenancy the transaction is associated with, where applicable */\nstring) | null | undefined, _eTag?: (/** The ETag for the current version of the transaction. Used for managing update concurrency */\nstring) | null | undefined};",
  "src/sections/Transactions/tables/TransactionsNominalAccountsTable.generated.tsx": "import { useGetApiTransactionsNominalAccounts } from '@/sections/Transactions/services/useGetApiTransactionsNominalAccounts.generated.ts'\nimport { useState } from 'react'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\nimport { useNavigate } from 'react-router-dom'\n\nexport type UseTransactionsNominalAccountsTableArgs = {sortBy?: (string) | null | undefined, id?: (Array<string>) | null | undefined, appliesToWorksOrders?: (boolean) | null | undefined};\nexport const useTransactionsNominalAccountsTable = (args: UseTransactionsNominalAccountsTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiTransactionsNominalAccounts({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const TransactionsNominalAccountsTable = () => {\n  \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useTransactionsNominalAccountsTable({}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Transactions',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New transactionsNominalAccountsTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/transactions/nominalAccounts/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Transactions/services/useGetApiTransactionsNominalAccounts.generated.ts": "import { getApiTransactionsNominalAccountsResponse } from '@/sections/Transactions/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiTransactionsNominalAccountsFnArgs = {pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, sortBy?: (string) | null | undefined, id?: (Array<string>) | null | undefined, appliesToWorksOrders?: (boolean) | null | undefined};\nexport const getApiTransactionsNominalAccountsFn = async ({pageSize, pageNumber, sortBy, id, appliesToWorksOrders}: GetApiTransactionsNominalAccountsFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/transactions/nominalAccounts${querySerialiser({args:{pageSize, pageNumber, sortBy, id, appliesToWorksOrders}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiTransactionsNominalAccountsResponse.parse(data)\n    };\nexport const useGetApiTransactionsNominalAccounts = ({pageSize, pageNumber, sortBy, id, appliesToWorksOrders}: GetApiTransactionsNominalAccountsFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Transactions', pageSize, pageNumber, sortBy, id, appliesToWorksOrders],\n        queryFn: () => getApiTransactionsNominalAccountsFn({pageSize, pageNumber, sortBy, id, appliesToWorksOrders}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/schemas/nominalAccountModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { nominalAccountModel, NominalAccountModel } from '@/schemas/nominalAccountModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const nominalAccountModelPagedResult = z.object({_embedded: z.array(nominalAccountModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type NominalAccountModelPagedResult = {_embedded?: (Array<NominalAccountModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/nominalAccountModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\n\nexport const nominalAccountModel = /** Model representing a nominal account */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the nominal account */\nz.string().optional().nullable(), created: /** The date and time when the nominal account was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the nominal account was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), name: /** The nominal account name */\nz.string().optional().nullable(), appliesToWorksOrders: /** Flag indicating whether or not the nominal account can be associated with works orders */\nz.boolean().optional().nullable()});\nexport type NominalAccountModel = /** Model representing a nominal account */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the nominal account */\nstring) | null | undefined, created?: (/** The date and time when the nominal account was created */\nDate) | null | undefined, modified?: (/** The date and time when the nominal account was last modified */\nDate) | null | undefined, name?: (/** The nominal account name */\nstring) | null | undefined, appliesToWorksOrders?: (/** Flag indicating whether or not the nominal account can be associated with works orders */\nboolean) | null | undefined};",
  "src/sections/Transactions/forms/CreateTransactionsSupplierInvoices.example.tsx": "import { CreateTransactionsSupplierInvoicesForm, fieldNames, CreateTransactionsSupplierInvoicesFormFields } from '@/sections/Transactions/forms/CreateTransactionsSupplierInvoicesForm.generated.tsx'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateTransactionsSupplierInvoices = () => {\n      \n\n      \n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateTransactionsSupplierInvoicesForm >\n              <FormLayout>\n                <CreateTransactionsSupplierInvoicesFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateTransactionsSupplierInvoicesForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Transactions/forms/CreateTransactionsSupplierInvoicesForm.generated.tsx": "import { CreateApiTransactionsSupplierInvoicesBody, createApiTransactionsSupplierInvoicesBody } from '@/sections/Transactions/services/apiTypes.generated.ts'\nimport { createTransactionsSupplierInvoicesConfig } from '@/sections/Transactions/config/createTransactionsSupplierInvoicesConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiTransactionsSupplierInvoices } from '@/sections/Transactions/services/useCreateApiTransactionsSupplierInvoices.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateTransactionsSupplierInvoicesFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiTransactionsSupplierInvoicesBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createTransactionsSupplierInvoicesConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateTransactionsSupplierInvoicesFormProps = {children: ReactNode, defaultValues?: CreateApiTransactionsSupplierInvoicesBody, onSuccess?: () => void};\nexport const CreateTransactionsSupplierInvoicesForm = (props: CreateTransactionsSupplierInvoicesFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiTransactionsSupplierInvoicesBody>({\n        resolver: zodResolver(createApiTransactionsSupplierInvoicesBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiTransactionsSupplierInvoices()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiTransactionsSupplierInvoicesBody>({worksOrderId: true, propertyId: true, companyId: true, tenancyId: true, description: true, accountId: true, invoiceRef: true, negotiatorId: true, invoiceDate: true, dueDate: true, netAmount: true, taxAmount: true});",
  "src/schemas/createSupplierInvoiceModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateSupplierInvoiceModel = /** Request body used to create a new supplier invoice */\n{worksOrderId?: (/** The unique identifier of the works order the supplier invoice is associated with, where applicable\r\nMust be provided if propertyId/companyId/tenancyId are not present */\nstring) | null | undefined, propertyId?: (/** The unique identifier of the property the supplier invoice is associated with, where applicable\r\nWhen providing a propertyId along with a worksOrderId, the id will be validated against the works order to check they match */\nstring) | null | undefined, companyId?: (/** The unique identifier of the contractor (company) the supplier invoice is associated with, where applicable\r\nWhen providing a companyId along with a worksOrderId, the id will be validated against the works order to check they match */\nstring) | null | undefined, tenancyId?: (/** The unique identifier of the tenancy the supplier invoice is associated with, where applicable\r\nWhen providing a tenancyId along with a worksOrderId, the id will be validated against the works order to check they match */\nstring) | null | undefined, description: /** The supplier invoice work description */\nstring, accountId: /** The identifier of the nominal account the supplier invoice should be attributed to */\nstring, invoiceRef: /** The invoice reference */\nstring, negotiatorId: /** The unique identifier of the negotiator the invoice should be attributed to (normally the person creating it on the system) */\nstring, invoiceDate: /** The invoice date */\nstring, dueDate?: (/** The date the invoice should be paid by */\nstring) | null | undefined, netAmount: /** The invoice net amount */\nnumber, taxAmount: /** The invoice tax amount */\nnumber};\nexport const createSupplierInvoiceModel = /** Request body used to create a new supplier invoice */\nz.object({worksOrderId: /** The unique identifier of the works order the supplier invoice is associated with, where applicable\r\nMust be provided if propertyId/companyId/tenancyId are not present */\nz.string().optional().nullable(), propertyId: /** The unique identifier of the property the supplier invoice is associated with, where applicable\r\nWhen providing a propertyId along with a worksOrderId, the id will be validated against the works order to check they match */\nz.string().optional().nullable(), companyId: /** The unique identifier of the contractor (company) the supplier invoice is associated with, where applicable\r\nWhen providing a companyId along with a worksOrderId, the id will be validated against the works order to check they match */\nz.string().optional().nullable(), tenancyId: /** The unique identifier of the tenancy the supplier invoice is associated with, where applicable\r\nWhen providing a tenancyId along with a worksOrderId, the id will be validated against the works order to check they match */\nz.string().optional().nullable(), description: /** The supplier invoice work description */\nz.string().min(1), accountId: /** The identifier of the nominal account the supplier invoice should be attributed to */\nz.string().min(1), invoiceRef: /** The invoice reference */\nz.string().min(1), negotiatorId: /** The unique identifier of the negotiator the invoice should be attributed to (normally the person creating it on the system) */\nz.string().min(1), invoiceDate: /** The invoice date */\nz.string().min(1), dueDate: /** The date the invoice should be paid by */\nz.string().optional().nullable(), netAmount: /** The invoice net amount */\nz.number(), taxAmount: /** The invoice tax amount */\nz.number()});",
  "src/sections/Transactions/config/createTransactionsSupplierInvoicesConfig.example.tsx": "import { CreateApiTransactionsSupplierInvoicesBody } from '@/sections/Transactions/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { DateInput } from '@/inputs/DateInput.tsx'\nimport { NumberInput } from '@/inputs/NumberInput.tsx'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createTransactionsSupplierInvoicesConfig: ModelConfig<CreateApiTransactionsSupplierInvoicesBody> = {worksOrderId: {\n      key: 'worksOrderId',\n      label: 'worksOrderId',\n      defaultValue: '',\n      placeholder: 'worksOrderId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, propertyId: {\n      key: 'propertyId',\n      label: 'propertyId',\n      defaultValue: '',\n      placeholder: 'propertyId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, companyId: {\n      key: 'companyId',\n      label: 'companyId',\n      defaultValue: '',\n      placeholder: 'companyId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, tenancyId: {\n      key: 'tenancyId',\n      label: 'tenancyId',\n      defaultValue: '',\n      placeholder: 'tenancyId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, description: {\n      key: 'description',\n      label: 'description',\n      defaultValue: '',\n      placeholder: 'description',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, accountId: {\n      key: 'accountId',\n      label: 'accountId',\n      defaultValue: '',\n      placeholder: 'accountId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, invoiceRef: {\n      key: 'invoiceRef',\n      label: 'invoiceRef',\n      defaultValue: '',\n      placeholder: 'invoiceRef',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, negotiatorId: {\n      key: 'negotiatorId',\n      label: 'negotiatorId',\n      defaultValue: '',\n      placeholder: 'negotiatorId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, invoiceDate: {\n      key: 'invoiceDate',\n      label: 'invoiceDate',\n      defaultValue: null,\n      placeholder: 'invoiceDate',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><DateInput {...props} /></InputWrap>\n    }, dueDate: {\n      key: 'dueDate',\n      label: 'dueDate',\n      defaultValue: null,\n      placeholder: 'dueDate',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><DateInput {...props} /></InputWrap>\n    }, netAmount: {\n      key: 'netAmount',\n      label: 'netAmount',\n      defaultValue: null,\n      placeholder: 'netAmount',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><NumberInput {...props} /></InputWrap>\n    }, taxAmount: {\n      key: 'taxAmount',\n      label: 'taxAmount',\n      defaultValue: null,\n      placeholder: 'taxAmount',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><NumberInput {...props} /></InputWrap>\n    }};",
  "src/sections/Transactions/services/useCreateApiTransactionsSupplierInvoices.generated.ts": "import { CreateSupplierInvoiceModel } from '@/schemas/createSupplierInvoiceModel.generated.tsx'\nimport { createApiTransactionsSupplierInvoicesResponse } from '@/sections/Transactions/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiTransactionsSupplierInvoicesFnArgs = {body: CreateSupplierInvoiceModel};\nexport const createApiTransactionsSupplierInvoicesFn = async ({body}: CreateApiTransactionsSupplierInvoicesFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/transactions/supplierInvoices${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiTransactionsSupplierInvoicesResponse.parse(data)\n    };\nexport const useCreateApiTransactionsSupplierInvoices = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiTransactionsSupplierInvoicesFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Transactions']})\n        }\n      })\n    };",
  "src/sections/Vendors/tables/VendorsTable.generated.tsx": "import { useGetApiVendors } from '@/sections/Vendors/services/useGetApiVendors.generated.ts'\nimport { useState } from 'react'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\nimport { useNavigate } from 'react-router-dom'\n\nexport type UseVendorsTableArgs = {sortBy?: (string) | null | undefined, embed?: (Array<'negotiator' | 'offices' | 'property' | 'sellingReason' | 'solicitor' | 'source' | 'type'>) | null | undefined, id?: (Array<string>) | null | undefined, negotiatorId?: (Array<string>) | null | undefined, officeId?: (Array<string>) | null | undefined, email?: (Array<string>) | null | undefined, fromArchive?: (boolean) | null | undefined, address?: (string) | null | undefined, name?: (string) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, lastCallFrom?: (Date) | null | undefined, lastCallTo?: (Date) | null | undefined, nextCallFrom?: (Date) | null | undefined, nextCallTo?: (Date) | null | undefined, metadata?: (Array<string>) | null | undefined};\nexport const useVendorsTable = (args: UseVendorsTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiVendors({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const VendorsTable = () => {\n  \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useVendorsTable({}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Vendors',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New vendorsTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/vendors/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Vendors/services/useGetApiVendors.generated.ts": "import { getApiVendorsResponse } from '@/sections/Vendors/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiVendorsFnArgs = {pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, sortBy?: (string) | null | undefined, embed?: (Array<'negotiator' | 'offices' | 'property' | 'sellingReason' | 'solicitor' | 'source' | 'type'>) | null | undefined, id?: (Array<string>) | null | undefined, negotiatorId?: (Array<string>) | null | undefined, officeId?: (Array<string>) | null | undefined, email?: (Array<string>) | null | undefined, fromArchive?: (boolean) | null | undefined, address?: (string) | null | undefined, name?: (string) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, lastCallFrom?: (Date) | null | undefined, lastCallTo?: (Date) | null | undefined, nextCallFrom?: (Date) | null | undefined, nextCallTo?: (Date) | null | undefined, metadata?: (Array<string>) | null | undefined};\nexport const getApiVendorsFn = async ({pageSize, pageNumber, sortBy, embed, id, negotiatorId, officeId, email, fromArchive, address, name, createdFrom, createdTo, modifiedFrom, modifiedTo, lastCallFrom, lastCallTo, nextCallFrom, nextCallTo, metadata}: GetApiVendorsFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/vendors/${querySerialiser({args:{pageSize, pageNumber, sortBy, embed, id, negotiatorId, officeId, email, fromArchive, address, name, createdFrom, createdTo, modifiedFrom, modifiedTo, lastCallFrom, lastCallTo, nextCallFrom, nextCallTo, metadata}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiVendorsResponse.parse(data)\n    };\nexport const useGetApiVendors = ({pageSize, pageNumber, sortBy, embed, id, negotiatorId, officeId, email, fromArchive, address, name, createdFrom, createdTo, modifiedFrom, modifiedTo, lastCallFrom, lastCallTo, nextCallFrom, nextCallTo, metadata}: GetApiVendorsFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Vendors', pageSize, pageNumber, sortBy, embed, id, negotiatorId, officeId, email, fromArchive, address, name, createdFrom, createdTo, modifiedFrom, modifiedTo, lastCallFrom, lastCallTo, nextCallFrom, nextCallTo, metadata],\n        queryFn: () => getApiVendorsFn({pageSize, pageNumber, sortBy, embed, id, negotiatorId, officeId, email, fromArchive, address, name, createdFrom, createdTo, modifiedFrom, modifiedTo, lastCallFrom, lastCallTo, nextCallFrom, nextCallTo, metadata}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Vendors/services/apiTypes.generated.ts": "import { vendorModelPagedResult } from '@/schemas/vendorModelPagedResult.generated.tsx'\nimport { vendorContactRelationshipModelPagedResult } from '@/schemas/vendorContactRelationshipModelPagedResult.generated.tsx'\nimport { InsertVendorContactRelationshipModel, insertVendorContactRelationshipModel } from '@/schemas/insertVendorContactRelationshipModel.generated.tsx'\nimport { z } from 'zod'\nimport { vendorModel } from '@/schemas/vendorModel.generated.tsx'\nimport { vendorContactRelationshipModel } from '@/schemas/vendorContactRelationshipModel.generated.tsx'\n\nexport const getApiVendorsResponse = vendorModelPagedResult;\nexport const getApiVendorsIdRelationshipsResponse = vendorContactRelationshipModelPagedResult;\nexport type CreateApiVendorsIdRelationshipsBody = InsertVendorContactRelationshipModel;\nexport const createApiVendorsIdRelationshipsBody = insertVendorContactRelationshipModel;\nexport const createApiVendorsIdRelationshipsResponse = z.void();\nexport const getApiVendorsIdResponse = vendorModel;\nexport const patchApiVendorsIdResponse = z.void();\nexport const getApiVendorsIdRelationshipsRelationshipIdResponse = vendorContactRelationshipModel;\nexport const deleteApiVendorsIdRelationshipsRelationshipIdResponse = z.void();",
  "src/schemas/vendorModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { vendorModel, VendorModel } from '@/schemas/vendorModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const vendorModelPagedResult = z.object({_embedded: z.array(vendorModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type VendorModelPagedResult = {_embedded?: (Array<VendorModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/vendorModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\nimport { vendorSourceModel, VendorSourceModel } from '@/schemas/vendorSourceModel.generated.tsx'\nimport { vendorContactModel, VendorContactModel } from '@/schemas/vendorContactModel.generated.tsx'\n\nexport const vendorModel = /** Representation of a vendor */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the vendor */\nz.string().optional().nullable(), created: /** The date and time when the vendor was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the vendor was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), lastCall: /** The date the vendor was last called */\nz.string().optional().nullable(), nextCall: /** The date the vendor is next due to be called */\nz.string().optional().nullable(), typeId: /** The unique identifier of the type of vendor */\nz.string().optional().nullable(), sellingReasonId: /** The unique identifier of the reason the vendor is selling */\nz.string().optional().nullable(), solicitorId: /** The unique identifier of the solicitor associated to the vendor */\nz.string().optional().nullable(), propertyId: /** The unique identifier of the property associated to the vendor */\nz.string().optional().nullable(), source: vendorSourceModel.optional().nullable(), related: /** A collection of contacts and/or companies associated to the vendor. The first item in the collection is considered the primary relationship */\nz.array(vendorContactModel).optional().nullable(), correspondenceAddressType: /** Value indicating where hard copies of correspondence should be sent for the primary contact (property/contact).\r\nWhen set to contact, any correspondence should be sent to the related contact's address, rather than the property address */\nz.string().optional().nullable(), negotiatorId: /** The unique identifier of the negotiator attached to the vendor. The first item in the collection is considered the primary negotiator */\nz.string().optional().nullable(), officeIds: /** A collection of unique identifiers of offices attached to the vendor. The first item in the collection is considered the primary office */\nz.array(z.string().min(1)).optional().nullable(), archivedOn: /** The date and time the vendor was archived */\nz.string().pipe( z.coerce.date() ).optional().nullable(), fromArchive: /** A flag determining whether or not the vendor is archived */\nz.boolean().optional().nullable(), metadata: /** App specific metadata that has been set against the vendor */\nz.record(z.string(), z.object({})).optional().nullable(), _eTag: /** The ETag for the current version of the vendor. Used for managing update concurrency */\nz.string().optional().nullable()});\nexport type VendorModel = /** Representation of a vendor */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the vendor */\nstring) | null | undefined, created?: (/** The date and time when the vendor was created */\nDate) | null | undefined, modified?: (/** The date and time when the vendor was last modified */\nDate) | null | undefined, lastCall?: (/** The date the vendor was last called */\nstring) | null | undefined, nextCall?: (/** The date the vendor is next due to be called */\nstring) | null | undefined, typeId?: (/** The unique identifier of the type of vendor */\nstring) | null | undefined, sellingReasonId?: (/** The unique identifier of the reason the vendor is selling */\nstring) | null | undefined, solicitorId?: (/** The unique identifier of the solicitor associated to the vendor */\nstring) | null | undefined, propertyId?: (/** The unique identifier of the property associated to the vendor */\nstring) | null | undefined, source?: (VendorSourceModel) | null | undefined, related?: (/** A collection of contacts and/or companies associated to the vendor. The first item in the collection is considered the primary relationship */\nArray<VendorContactModel>) | null | undefined, correspondenceAddressType?: (/** Value indicating where hard copies of correspondence should be sent for the primary contact (property/contact).\r\nWhen set to contact, any correspondence should be sent to the related contact's address, rather than the property address */\nstring) | null | undefined, negotiatorId?: (/** The unique identifier of the negotiator attached to the vendor. The first item in the collection is considered the primary negotiator */\nstring) | null | undefined, officeIds?: (/** A collection of unique identifiers of offices attached to the vendor. The first item in the collection is considered the primary office */\nArray<string>) | null | undefined, archivedOn?: (/** The date and time the vendor was archived */\nDate) | null | undefined, fromArchive?: (/** A flag determining whether or not the vendor is archived */\nboolean) | null | undefined, metadata?: (/** App specific metadata that has been set against the vendor */\nRecord<string, Record<string, never>>) | null | undefined, _eTag?: (/** The ETag for the current version of the vendor. Used for managing update concurrency */\nstring) | null | undefined};",
  "src/schemas/vendorSourceModel.generated.tsx": "import { z } from 'zod'\n\nexport const vendorSourceModel = /** Representation of a vendor's source */\nz.object({id: /** The unique identifier of the source of the vendor */\nz.string().optional().nullable(), type: /** The source type (office/source) */\nz.string().optional().nullable()});\nexport type VendorSourceModel = /** Representation of a vendor's source */\n{id?: (/** The unique identifier of the source of the vendor */\nstring) | null | undefined, type?: (/** The source type (office/source) */\nstring) | null | undefined};",
  "src/schemas/vendorContactModel.generated.tsx": "import { z } from 'zod'\nimport { applicantContactAddressModel, ApplicantContactAddressModel } from '@/schemas/applicantContactAddressModel.generated.tsx'\nimport { additionalContactDetailModel, AdditionalContactDetailModel } from '@/schemas/additionalContactDetailModel.generated.tsx'\n\nexport const vendorContactModel = /** A summarised view of the details of a contact or company associated to a vendor */\nz.object({id: /** The unique identifier of the contact or company */\nz.string().optional().nullable(), name: /** The complete name of the contact or company */\nz.string().optional().nullable(), title: /** The title of the contact (Available when 'type' is 'contact') */\nz.string().optional().nullable(), forename: /** The forename of the contact (Available when 'type' is 'contact') */\nz.string().optional().nullable(), surname: /** The surname of the contact (Available when 'type' is 'contact') */\nz.string().optional().nullable(), dateOfBirth: /** The date of birth of the contact (Available when 'type' is 'contact') */\nz.string().optional().nullable(), type: /** The type of the contact (company/contact) */\nz.string().optional().nullable(), homePhone: /** The home phone number of the contact or company */\nz.string().optional().nullable(), workPhone: /** The work phone number of the contact or company */\nz.string().optional().nullable(), mobilePhone: /** The mobile phone number of the contact or company */\nz.string().optional().nullable(), email: /** The email address of the contact or company */\nz.string().optional().nullable(), marketingConsent: /** The marketing consent status of the contact (grant/deny/notAsked/unknown) */\nz.string().optional().nullable(), fromArchive: /** Flag to determine if this role on the system is now archived */\nz.boolean().optional().nullable(), primaryAddress: applicantContactAddressModel.optional().nullable(), additionalContactDetails: /** A collection of additional contact details */\nz.array(additionalContactDetailModel).optional().nullable()});\nexport type VendorContactModel = /** A summarised view of the details of a contact or company associated to a vendor */\n{id?: (/** The unique identifier of the contact or company */\nstring) | null | undefined, name?: (/** The complete name of the contact or company */\nstring) | null | undefined, title?: (/** The title of the contact (Available when 'type' is 'contact') */\nstring) | null | undefined, forename?: (/** The forename of the contact (Available when 'type' is 'contact') */\nstring) | null | undefined, surname?: (/** The surname of the contact (Available when 'type' is 'contact') */\nstring) | null | undefined, dateOfBirth?: (/** The date of birth of the contact (Available when 'type' is 'contact') */\nstring) | null | undefined, type?: (/** The type of the contact (company/contact) */\nstring) | null | undefined, homePhone?: (/** The home phone number of the contact or company */\nstring) | null | undefined, workPhone?: (/** The work phone number of the contact or company */\nstring) | null | undefined, mobilePhone?: (/** The mobile phone number of the contact or company */\nstring) | null | undefined, email?: (/** The email address of the contact or company */\nstring) | null | undefined, marketingConsent?: (/** The marketing consent status of the contact (grant/deny/notAsked/unknown) */\nstring) | null | undefined, fromArchive?: (/** Flag to determine if this role on the system is now archived */\nboolean) | null | undefined, primaryAddress?: (ApplicantContactAddressModel) | null | undefined, additionalContactDetails?: (/** A collection of additional contact details */\nArray<AdditionalContactDetailModel>) | null | undefined};",
  "src/sections/Vendors/tables/VendorsIdRelationshipsTable.generated.tsx": "import { useGetApiVendorsIdRelationships } from '@/sections/Vendors/services/useGetApiVendorsIdRelationships.generated.ts'\nimport { useState } from 'react'\nimport { useParams, useNavigate } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\n\nexport type UseVendorsIdRelationshipsTableArgs = {id: string};\nexport const useVendorsIdRelationshipsTable = (args: UseVendorsIdRelationshipsTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiVendorsIdRelationships({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const VendorsIdRelationshipsTable = () => {\n  const {id} = useParams()\n    \n    invariant(id, 'Missing id param')\n    \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useVendorsIdRelationshipsTable({id}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'Vendors',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New vendorsIdRelationshipsTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/vendors/${id}/relationships/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/Vendors/services/useGetApiVendorsIdRelationships.generated.ts": "import { getApiVendorsIdRelationshipsResponse } from '@/sections/Vendors/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiVendorsIdRelationshipsFnArgs = {id: string, pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined};\nexport const getApiVendorsIdRelationshipsFn = async ({id, pageSize, pageNumber}: GetApiVendorsIdRelationshipsFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/vendors/${id}/relationships${querySerialiser({args:{pageSize, pageNumber}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiVendorsIdRelationshipsResponse.parse(data)\n    };\nexport const useGetApiVendorsIdRelationships = ({id, pageSize, pageNumber}: GetApiVendorsIdRelationshipsFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['Vendors', id, pageSize, pageNumber],\n        queryFn: () => getApiVendorsIdRelationshipsFn({id, pageSize, pageNumber}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/schemas/vendorContactRelationshipModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { vendorContactRelationshipModel, VendorContactRelationshipModel } from '@/schemas/vendorContactRelationshipModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const vendorContactRelationshipModelPagedResult = z.object({_embedded: z.array(vendorContactRelationshipModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type VendorContactRelationshipModelPagedResult = {_embedded?: (Array<VendorContactRelationshipModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/vendorContactRelationshipModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\n\nexport const vendorContactRelationshipModel = /** Representation of a relationship between a vendor and a contact or company */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the vendor relationship */\nz.string().optional().nullable(), vendorId: /** The unique identifier of the vendor */\nz.string().optional().nullable(), created: /** The date and time when the relationship was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the relationship was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), associatedType: /** The type of related entity (contact/company) */\nz.string().optional().nullable(), associatedId: /** The unique identifier of the related contact or company */\nz.string().optional().nullable(), isMain: /** A flag denoting whether or not this relationship should be regarded as the main relationship for the parent vendor entity */\nz.boolean().optional().nullable()});\nexport type VendorContactRelationshipModel = /** Representation of a relationship between a vendor and a contact or company */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the vendor relationship */\nstring) | null | undefined, vendorId?: (/** The unique identifier of the vendor */\nstring) | null | undefined, created?: (/** The date and time when the relationship was created */\nDate) | null | undefined, modified?: (/** The date and time when the relationship was last modified */\nDate) | null | undefined, associatedType?: (/** The type of related entity (contact/company) */\nstring) | null | undefined, associatedId?: (/** The unique identifier of the related contact or company */\nstring) | null | undefined, isMain?: (/** A flag denoting whether or not this relationship should be regarded as the main relationship for the parent vendor entity */\nboolean) | null | undefined};",
  "src/sections/Vendors/forms/CreateVendorsIdRelationships.example.tsx": "import { CreateVendorsIdRelationshipsForm, fieldNames, CreateVendorsIdRelationshipsFormFields } from '@/sections/Vendors/forms/CreateVendorsIdRelationshipsForm.generated.tsx'\nimport { useParams } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateVendorsIdRelationships = () => {\n      const { id } = useParams()\n\n      invariant(id, 'Expected id to be defined')\n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateVendorsIdRelationshipsForm id={id}>\n              <FormLayout>\n                <CreateVendorsIdRelationshipsFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateVendorsIdRelationshipsForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/Vendors/forms/CreateVendorsIdRelationshipsForm.generated.tsx": "import { CreateApiVendorsIdRelationshipsBody, createApiVendorsIdRelationshipsBody } from '@/sections/Vendors/services/apiTypes.generated.ts'\nimport { createVendorsIdRelationshipsConfig } from '@/sections/Vendors/config/createVendorsIdRelationshipsConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiVendorsIdRelationships } from '@/sections/Vendors/services/useCreateApiVendorsIdRelationships.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateVendorsIdRelationshipsFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiVendorsIdRelationshipsBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createVendorsIdRelationshipsConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateVendorsIdRelationshipsFormProps = {id: string, children: ReactNode, defaultValues?: CreateApiVendorsIdRelationshipsBody, onSuccess?: () => void};\nexport const CreateVendorsIdRelationshipsForm = (props: CreateVendorsIdRelationshipsFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiVendorsIdRelationshipsBody>({\n        resolver: zodResolver(createApiVendorsIdRelationshipsBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiVendorsIdRelationships()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiVendorsIdRelationshipsBody>({associatedId: true, associatedType: true, isMain: true});",
  "src/schemas/insertVendorContactRelationshipModel.generated.tsx": "import { z } from 'zod'\n\nexport type InsertVendorContactRelationshipModel = /** Request body used to create or update a relationship between a vendor and a contact or company */\n{associatedId: /** The unique identifier of the contact or company to create a relationship with */\nstring, associatedType: /** The type of relationship to create (contact/company) */\nstring, isMain: /** Flag denoting whether or not this relationship should be considered to be the main/primary relationship. Setting to true will automatically demote the existing primary relationship */\nboolean};\nexport const insertVendorContactRelationshipModel = /** Request body used to create or update a relationship between a vendor and a contact or company */\nz.object({associatedId: /** The unique identifier of the contact or company to create a relationship with */\nz.string().min(1), associatedType: /** The type of relationship to create (contact/company) */\nz.string().min(1), isMain: /** Flag denoting whether or not this relationship should be considered to be the main/primary relationship. Setting to true will automatically demote the existing primary relationship */\nz.boolean()});",
  "src/sections/Vendors/config/createVendorsIdRelationshipsConfig.example.tsx": "import { CreateApiVendorsIdRelationshipsBody } from '@/sections/Vendors/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { Switch } from '@/inputs/Switch.tsx'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createVendorsIdRelationshipsConfig: ModelConfig<CreateApiVendorsIdRelationshipsBody> = {associatedId: {\n      key: 'associatedId',\n      label: 'associatedId',\n      defaultValue: '',\n      placeholder: 'associatedId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, associatedType: {\n      key: 'associatedType',\n      label: 'associatedType',\n      defaultValue: '',\n      placeholder: 'associatedType',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, isMain: {\n      key: 'isMain',\n      label: 'isMain',\n      defaultValue: false,\n      placeholder: 'isMain',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><Switch {...props} /></InputWrap>\n    }};",
  "src/sections/Vendors/services/useCreateApiVendorsIdRelationships.generated.ts": "import { InsertVendorContactRelationshipModel } from '@/schemas/insertVendorContactRelationshipModel.generated.tsx'\nimport { createApiVendorsIdRelationshipsResponse } from '@/sections/Vendors/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiVendorsIdRelationshipsFnArgs = {id: string, body: InsertVendorContactRelationshipModel};\nexport const createApiVendorsIdRelationshipsFn = async ({id, body}: CreateApiVendorsIdRelationshipsFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/vendors/${id}/relationships${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiVendorsIdRelationshipsResponse.parse(data)\n    };\nexport const useCreateApiVendorsIdRelationships = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiVendorsIdRelationshipsFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Vendors']})\n        }\n      })\n    };",
  "src/sections/WorksOrders/tables/WorksOrdersTable.generated.tsx": "import { useGetApiWorksOrders } from '@/sections/WorksOrders/services/useGetApiWorksOrders.generated.ts'\nimport { useState } from 'react'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\nimport { useNavigate } from 'react-router-dom'\n\nexport type UseWorksOrdersTableArgs = {sortBy?: (string) | null | undefined, embed?: (Array<'company' | 'documents' | 'negotiator' | 'property' | 'tenancy' | 'type'>) | null | undefined, id?: (Array<string>) | null | undefined, companyId?: (Array<string>) | null | undefined, negotiatorId?: (Array<string>) | null | undefined, propertyId?: (Array<string>) | null | undefined, status?: (Array<'pendingApproval' | 'pendingQuote' | 'raised' | 'raisedToChase' | 'landlordToComplete' | 'complete' | 'cancelled' | 'quoteAccepted'>) | null | undefined, tenancyId?: (Array<string>) | null | undefined, typeId?: (Array<string>) | null | undefined, extrasField?: (Array<string>) | null | undefined, completedFrom?: (Date) | null | undefined, completedTo?: (Date) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, requiredFrom?: (Date) | null | undefined, requiredTo?: (Date) | null | undefined, metadata?: (Array<string>) | null | undefined};\nexport const useWorksOrdersTable = (args: UseWorksOrdersTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiWorksOrders({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const WorksOrdersTable = () => {\n  \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useWorksOrdersTable({}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'WorksOrders',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New worksOrdersTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/worksOrders/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/WorksOrders/services/useGetApiWorksOrders.generated.ts": "import { getApiWorksOrdersResponse } from '@/sections/WorksOrders/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiWorksOrdersFnArgs = {pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, sortBy?: (string) | null | undefined, embed?: (Array<'company' | 'documents' | 'negotiator' | 'property' | 'tenancy' | 'type'>) | null | undefined, id?: (Array<string>) | null | undefined, companyId?: (Array<string>) | null | undefined, negotiatorId?: (Array<string>) | null | undefined, propertyId?: (Array<string>) | null | undefined, status?: (Array<'pendingApproval' | 'pendingQuote' | 'raised' | 'raisedToChase' | 'landlordToComplete' | 'complete' | 'cancelled' | 'quoteAccepted'>) | null | undefined, tenancyId?: (Array<string>) | null | undefined, typeId?: (Array<string>) | null | undefined, extrasField?: (Array<string>) | null | undefined, completedFrom?: (Date) | null | undefined, completedTo?: (Date) | null | undefined, createdFrom?: (Date) | null | undefined, createdTo?: (Date) | null | undefined, modifiedFrom?: (Date) | null | undefined, modifiedTo?: (Date) | null | undefined, requiredFrom?: (Date) | null | undefined, requiredTo?: (Date) | null | undefined, metadata?: (Array<string>) | null | undefined};\nexport const getApiWorksOrdersFn = async ({pageSize, pageNumber, sortBy, embed, id, companyId, negotiatorId, propertyId, status, tenancyId, typeId, extrasField, completedFrom, completedTo, createdFrom, createdTo, modifiedFrom, modifiedTo, requiredFrom, requiredTo, metadata}: GetApiWorksOrdersFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/worksOrders/${querySerialiser({args:{pageSize, pageNumber, sortBy, embed, id, companyId, negotiatorId, propertyId, status, tenancyId, typeId, extrasField, completedFrom, completedTo, createdFrom, createdTo, modifiedFrom, modifiedTo, requiredFrom, requiredTo, metadata}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiWorksOrdersResponse.parse(data)\n    };\nexport const useGetApiWorksOrders = ({pageSize, pageNumber, sortBy, embed, id, companyId, negotiatorId, propertyId, status, tenancyId, typeId, extrasField, completedFrom, completedTo, createdFrom, createdTo, modifiedFrom, modifiedTo, requiredFrom, requiredTo, metadata}: GetApiWorksOrdersFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['WorksOrders', pageSize, pageNumber, sortBy, embed, id, companyId, negotiatorId, propertyId, status, tenancyId, typeId, extrasField, completedFrom, completedTo, createdFrom, createdTo, modifiedFrom, modifiedTo, requiredFrom, requiredTo, metadata],\n        queryFn: () => getApiWorksOrdersFn({pageSize, pageNumber, sortBy, embed, id, companyId, negotiatorId, propertyId, status, tenancyId, typeId, extrasField, completedFrom, completedTo, createdFrom, createdTo, modifiedFrom, modifiedTo, requiredFrom, requiredTo, metadata}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/WorksOrders/services/apiTypes.generated.ts": "import { worksOrderModelPagedResult } from '@/schemas/worksOrderModelPagedResult.generated.tsx'\nimport { CreateWorksOrderModel, createWorksOrderModel } from '@/schemas/createWorksOrderModel.generated.tsx'\nimport { z } from 'zod'\nimport { worksOrderItemModelPagedResult } from '@/schemas/worksOrderItemModelPagedResult.generated.tsx'\nimport { CreateWorksOrderItemModel, createWorksOrderItemModel } from '@/schemas/createWorksOrderItemModel.generated.tsx'\nimport { worksOrderModel } from '@/schemas/worksOrderModel.generated.tsx'\nimport { worksOrderItemModel } from '@/schemas/worksOrderItemModel.generated.tsx'\n\nexport const getApiWorksOrdersResponse = worksOrderModelPagedResult;\nexport type CreateApiWorksOrdersBody = CreateWorksOrderModel;\nexport const createApiWorksOrdersBody = createWorksOrderModel;\nexport const createApiWorksOrdersResponse = z.void();\nexport const getApiWorksOrdersIdItemsResponse = worksOrderItemModelPagedResult;\nexport type CreateApiWorksOrdersIdItemsBody = CreateWorksOrderItemModel;\nexport const createApiWorksOrdersIdItemsBody = createWorksOrderItemModel;\nexport const createApiWorksOrdersIdItemsResponse = z.void();\nexport const getApiWorksOrdersIdResponse = worksOrderModel;\nexport const patchApiWorksOrdersIdResponse = z.void();\nexport const getApiWorksOrdersIdItemsItemIdResponse = worksOrderItemModel;\nexport const deleteApiWorksOrdersIdItemsItemIdResponse = z.void();\nexport const patchApiWorksOrdersIdItemsItemIdResponse = z.void();",
  "src/schemas/worksOrderModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { worksOrderModel, WorksOrderModel } from '@/schemas/worksOrderModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const worksOrderModelPagedResult = z.object({_embedded: z.array(worksOrderModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type WorksOrderModelPagedResult = {_embedded?: (Array<WorksOrderModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/worksOrderModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\nimport { worksOrderItemModel, WorksOrderItemModel } from '@/schemas/worksOrderItemModel.generated.tsx'\n\nexport const worksOrderModel = /** Representation of a works order */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the works order */\nz.string().optional().nullable(), created: /** The date and time when the works order was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the works order was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), companyId: /** The unique identifier of the company that has been selected to perform the work */\nz.string().optional().nullable(), propertyId: /** The unique identifier of the property where the work is to be carried out */\nz.string().optional().nullable(), tenancyId: /** The unique identifier of the tenancy that the works order originated from */\nz.string().optional().nullable(), negotiatorId: /** The unique identifier of the negotiator that booked the works order */\nz.string().optional().nullable(), typeId: /** The unique identifier of the type of work that needs to be carried out */\nz.string().optional().nullable(), status: /** The current status of the works order (pendingApproval/pendingQuote/raised/raisedToChase/landlordToComplete/complete/cancelled/quoteAccepted) */\nz.string().optional().nullable(), description: /** A free text description of the work required */\nz.string().optional().nullable(), reporter: /** The party requesting the work to be carried out (landlord/tenant/other) */\nz.string().optional().nullable(), priority: /** The priority level of the works order (low/medium/high) */\nz.string().optional().nullable(), booked: /** The date when the works order was booked */\nz.string().optional().nullable(), required: /** The date when the work is required to be completed by */\nz.string().optional().nullable(), completed: /** The date when the work was completed */\nz.string().optional().nullable(), totalNetAmount: /** The total net cost for all of the items of work to be carried out */\nz.number().optional().nullable(), totalVatAmount: /** The total additional vat cost for all of the items of work to be carried out */\nz.number().optional().nullable(), totalGrossAmount: /** The total gross cost for all of the items of work to be carried out */\nz.number().optional().nullable(), items: /** A collection of jobs/items of work that the works order should fulfill */\nz.array(worksOrderItemModel).optional().nullable(), metadata: /** App specific metadata that has been set against the works order */\nz.record(z.string(), z.object({})).optional().nullable(), extrasField: /** The requested extras fields */\nz.record(z.string(), z.object({})).optional().nullable(), _eTag: /** The ETag for the current version of the works order. Used for managing update concurrency */\nz.string().optional().nullable()});\nexport type WorksOrderModel = /** Representation of a works order */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the works order */\nstring) | null | undefined, created?: (/** The date and time when the works order was created */\nDate) | null | undefined, modified?: (/** The date and time when the works order was last modified */\nDate) | null | undefined, companyId?: (/** The unique identifier of the company that has been selected to perform the work */\nstring) | null | undefined, propertyId?: (/** The unique identifier of the property where the work is to be carried out */\nstring) | null | undefined, tenancyId?: (/** The unique identifier of the tenancy that the works order originated from */\nstring) | null | undefined, negotiatorId?: (/** The unique identifier of the negotiator that booked the works order */\nstring) | null | undefined, typeId?: (/** The unique identifier of the type of work that needs to be carried out */\nstring) | null | undefined, status?: (/** The current status of the works order (pendingApproval/pendingQuote/raised/raisedToChase/landlordToComplete/complete/cancelled/quoteAccepted) */\nstring) | null | undefined, description?: (/** A free text description of the work required */\nstring) | null | undefined, reporter?: (/** The party requesting the work to be carried out (landlord/tenant/other) */\nstring) | null | undefined, priority?: (/** The priority level of the works order (low/medium/high) */\nstring) | null | undefined, booked?: (/** The date when the works order was booked */\nstring) | null | undefined, required?: (/** The date when the work is required to be completed by */\nstring) | null | undefined, completed?: (/** The date when the work was completed */\nstring) | null | undefined, totalNetAmount?: (/** The total net cost for all of the items of work to be carried out */\nnumber) | null | undefined, totalVatAmount?: (/** The total additional vat cost for all of the items of work to be carried out */\nnumber) | null | undefined, totalGrossAmount?: (/** The total gross cost for all of the items of work to be carried out */\nnumber) | null | undefined, items?: (/** A collection of jobs/items of work that the works order should fulfill */\nArray<WorksOrderItemModel>) | null | undefined, metadata?: (/** App specific metadata that has been set against the works order */\nRecord<string, Record<string, never>>) | null | undefined, extrasField?: (/** The requested extras fields */\nRecord<string, Record<string, never>>) | null | undefined, _eTag?: (/** The ETag for the current version of the works order. Used for managing update concurrency */\nstring) | null | undefined};",
  "src/schemas/worksOrderItemModel.generated.tsx": "import { z } from 'zod'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\n\nexport const worksOrderItemModel = /** Representation of a works order item */\nz.object({_links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable(), id: /** The unique identifier of the works order item */\nz.string().optional().nullable(), worksOrderId: /** The unique identifier of the parent works order */\nz.string().optional().nullable(), created: /** The date and time when the works order item was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the works order item was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), notes: /** The notes attached to the works order item */\nz.string().optional().nullable(), chargeTo: /** The party to be charged for the work being carried out (landlord/tenant) */\nz.string().optional().nullable(), estimate: /** The estimate of any costs associated with the work being carried out given to the party to be charged for the work */\nz.number().optional().nullable(), estimateType: /** The type of estimate supplied (agent/verbal/written) */\nz.string().optional().nullable(), netAmount: /** The net cost of the work to be carried out */\nz.number().optional().nullable(), vatAmount: /** The additional vat cost for the work to be carried out */\nz.number().optional().nullable(), grossAmount: /** The gross cost of the work to be carried out */\nz.number().optional().nullable(), reserveAmount: /** The amount of funds to be held back by the agent in landlord payment runs to cover the cost of any works required by the works order item */\nz.number().optional().nullable(), nominalAccountId: /** The unique identifier of the nominal account the works order financial transactions are allocated to */\nz.string().optional().nullable(), _eTag: /** The ETag for the current version of the works order item. Used for managing update concurrency */\nz.string().optional().nullable()});\nexport type WorksOrderItemModel = /** Representation of a works order item */\n{_links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined, id?: (/** The unique identifier of the works order item */\nstring) | null | undefined, worksOrderId?: (/** The unique identifier of the parent works order */\nstring) | null | undefined, created?: (/** The date and time when the works order item was created */\nDate) | null | undefined, modified?: (/** The date and time when the works order item was last modified */\nDate) | null | undefined, notes?: (/** The notes attached to the works order item */\nstring) | null | undefined, chargeTo?: (/** The party to be charged for the work being carried out (landlord/tenant) */\nstring) | null | undefined, estimate?: (/** The estimate of any costs associated with the work being carried out given to the party to be charged for the work */\nnumber) | null | undefined, estimateType?: (/** The type of estimate supplied (agent/verbal/written) */\nstring) | null | undefined, netAmount?: (/** The net cost of the work to be carried out */\nnumber) | null | undefined, vatAmount?: (/** The additional vat cost for the work to be carried out */\nnumber) | null | undefined, grossAmount?: (/** The gross cost of the work to be carried out */\nnumber) | null | undefined, reserveAmount?: (/** The amount of funds to be held back by the agent in landlord payment runs to cover the cost of any works required by the works order item */\nnumber) | null | undefined, nominalAccountId?: (/** The unique identifier of the nominal account the works order financial transactions are allocated to */\nstring) | null | undefined, _eTag?: (/** The ETag for the current version of the works order item. Used for managing update concurrency */\nstring) | null | undefined};",
  "src/sections/WorksOrders/forms/CreateWorksOrders.example.tsx": "import { CreateWorksOrdersForm, fieldNames, CreateWorksOrdersFormFields } from '@/sections/WorksOrders/forms/CreateWorksOrdersForm.generated.tsx'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateWorksOrders = () => {\n      \n\n      \n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateWorksOrdersForm >\n              <FormLayout>\n                <CreateWorksOrdersFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateWorksOrdersForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/WorksOrders/forms/CreateWorksOrdersForm.generated.tsx": "import { CreateApiWorksOrdersBody, createApiWorksOrdersBody } from '@/sections/WorksOrders/services/apiTypes.generated.ts'\nimport { createWorksOrdersConfig } from '@/sections/WorksOrders/config/createWorksOrdersConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiWorksOrders } from '@/sections/WorksOrders/services/useCreateApiWorksOrders.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateWorksOrdersFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiWorksOrdersBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createWorksOrdersConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateWorksOrdersFormProps = {children: ReactNode, defaultValues?: CreateApiWorksOrdersBody, onSuccess?: () => void};\nexport const CreateWorksOrdersForm = (props: CreateWorksOrdersFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiWorksOrdersBody>({\n        resolver: zodResolver(createApiWorksOrdersBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiWorksOrders()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiWorksOrdersBody>({companyId: true, propertyId: true, tenancyId: true, negotiatorId: true, typeId: true, status: true, description: true, reporter: true, priority: true, booked: true, required: true, completed: true, items: true, metadata: true});",
  "src/schemas/createWorksOrderModel.generated.tsx": "import { CreateWorksOrderItemModel, createWorksOrderItemModel } from '@/schemas/createWorksOrderItemModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type CreateWorksOrderModel = /** Request body used to create a new works order */\n{companyId?: (/** The unique identifier of the company that has been selected to perform the work */\nstring) | null | undefined, propertyId: /** The unique identifier of the property where the work is to be carried out */\nstring, tenancyId?: (/** The unique identifier of the tenancy that the works order originated from */\nstring) | null | undefined, negotiatorId: /** The unique identifier of the negotiator that booked the works order */\nstring, typeId?: (/** The unique id of the type of work that needs to be carried out */\nstring) | null | undefined, status: /** The current status of the works order (pendingApproval/pendingQuote/raised/raisedToChase/landlordToComplete/complete/cancelled/quoteAccepted) */\nstring, description: /** A free text description of the work required */\nstring, reporter: /** The party requesting the work to be carried out (landlord/tenant/other) */\nstring, priority?: (/** The priority level of the works order (low/medium/high) */\nstring) | null | undefined, booked?: (/** The date when the works order was booked */\nstring) | null | undefined, required?: (/** The date when the work is required to be completed by */\nstring) | null | undefined, completed?: (/** The date when the work was completed */\nstring) | null | undefined, items: /** Individual work items to attach to the works order */\nArray<CreateWorksOrderItemModel>, metadata?: (/** App specific metadata to set against the works order */\nRecord<string, Record<string, never>>) | null | undefined};\nexport const createWorksOrderModel = /** Request body used to create a new works order */\nz.object({companyId: /** The unique identifier of the company that has been selected to perform the work */\nz.string().optional().nullable(), propertyId: /** The unique identifier of the property where the work is to be carried out */\nz.string().min(1), tenancyId: /** The unique identifier of the tenancy that the works order originated from */\nz.string().optional().nullable(), negotiatorId: /** The unique identifier of the negotiator that booked the works order */\nz.string().min(1), typeId: /** The unique id of the type of work that needs to be carried out */\nz.string().optional().nullable(), status: /** The current status of the works order (pendingApproval/pendingQuote/raised/raisedToChase/landlordToComplete/complete/cancelled/quoteAccepted) */\nz.string().min(1), description: /** A free text description of the work required */\nz.string().min(1), reporter: /** The party requesting the work to be carried out (landlord/tenant/other) */\nz.string().min(1), priority: /** The priority level of the works order (low/medium/high) */\nz.string().optional().nullable(), booked: /** The date when the works order was booked */\nz.string().optional().nullable(), required: /** The date when the work is required to be completed by */\nz.string().optional().nullable(), completed: /** The date when the work was completed */\nz.string().optional().nullable(), items: /** Individual work items to attach to the works order */\nz.array(createWorksOrderItemModel), metadata: /** App specific metadata to set against the works order */\nz.record(z.string(), z.object({})).optional().nullable()});",
  "src/schemas/createWorksOrderItemModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateWorksOrderItemModel = /** Representation of a works order item */\n{notes: /** The notes attached to the works order item */\nstring, chargeTo: /** The party to be charged for the work being carried out (landlord/tenant) */\nstring, estimate?: (/** The estimate of any costs associated with the work being carried out given to the party to be charged for the work */\nnumber) | null | undefined, estimateType?: (/** The type of estimate supplied (agent/verbal/written) */\nstring) | null | undefined, netAmount?: (/** The net cost of the work to be carried out */\nnumber) | null | undefined, vatAmount?: (/** The cost of the vat associated with the work */\nnumber) | null | undefined, reserveAmount?: (/** The amount of funds to be held back by the agent in landlord payment runs to cover the cost of any works required by the works order item */\nnumber) | null | undefined};\nexport const createWorksOrderItemModel = /** Representation of a works order item */\nz.object({notes: /** The notes attached to the works order item */\nz.string().min(1), chargeTo: /** The party to be charged for the work being carried out (landlord/tenant) */\nz.string().min(1), estimate: /** The estimate of any costs associated with the work being carried out given to the party to be charged for the work */\nz.number().optional().nullable(), estimateType: /** The type of estimate supplied (agent/verbal/written) */\nz.string().optional().nullable(), netAmount: /** The net cost of the work to be carried out */\nz.number().optional().nullable(), vatAmount: /** The cost of the vat associated with the work */\nz.number().optional().nullable(), reserveAmount: /** The amount of funds to be held back by the agent in landlord payment runs to cover the cost of any works required by the works order item */\nz.number().optional().nullable()});",
  "src/sections/WorksOrders/config/createWorksOrdersConfig.example.tsx": "import { CreateApiWorksOrdersBody } from '@/sections/WorksOrders/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { DateInput } from '@/inputs/DateInput.tsx'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createWorksOrdersConfig: ModelConfig<CreateApiWorksOrdersBody> = {companyId: {\n      key: 'companyId',\n      label: 'companyId',\n      defaultValue: '',\n      placeholder: 'companyId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, propertyId: {\n      key: 'propertyId',\n      label: 'propertyId',\n      defaultValue: '',\n      placeholder: 'propertyId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, tenancyId: {\n      key: 'tenancyId',\n      label: 'tenancyId',\n      defaultValue: '',\n      placeholder: 'tenancyId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, negotiatorId: {\n      key: 'negotiatorId',\n      label: 'negotiatorId',\n      defaultValue: '',\n      placeholder: 'negotiatorId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, typeId: {\n      key: 'typeId',\n      label: 'typeId',\n      defaultValue: '',\n      placeholder: 'typeId',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, status: {\n      key: 'status',\n      label: 'status',\n      defaultValue: '',\n      placeholder: 'status',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, description: {\n      key: 'description',\n      label: 'description',\n      defaultValue: '',\n      placeholder: 'description',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, reporter: {\n      key: 'reporter',\n      label: 'reporter',\n      defaultValue: '',\n      placeholder: 'reporter',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, priority: {\n      key: 'priority',\n      label: 'priority',\n      defaultValue: '',\n      placeholder: 'priority',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, booked: {\n      key: 'booked',\n      label: 'booked',\n      defaultValue: null,\n      placeholder: 'booked',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><DateInput {...props} /></InputWrap>\n    }, required: {\n      key: 'required',\n      label: 'required',\n      defaultValue: null,\n      placeholder: 'required',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><DateInput {...props} /></InputWrap>\n    }, completed: {\n      key: 'completed',\n      label: 'completed',\n      defaultValue: null,\n      placeholder: 'completed',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><DateInput {...props} /></InputWrap>\n    }, items: {\n      key: 'items',\n      label: 'items',\n      defaultValue: [],\n      placeholder: 'items',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, metadata: {\n      key: 'metadata',\n      label: 'metadata',\n      defaultValue: null,\n      placeholder: 'metadata',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }};",
  "src/sections/WorksOrders/services/useCreateApiWorksOrders.generated.ts": "import { CreateWorksOrderModel } from '@/schemas/createWorksOrderModel.generated.tsx'\nimport { createApiWorksOrdersResponse } from '@/sections/WorksOrders/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiWorksOrdersFnArgs = {body: CreateWorksOrderModel};\nexport const createApiWorksOrdersFn = async ({body}: CreateApiWorksOrdersFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/worksOrders/${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiWorksOrdersResponse.parse(data)\n    };\nexport const useCreateApiWorksOrders = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiWorksOrdersFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['WorksOrders']})\n        }\n      })\n    };",
  "src/sections/WorksOrders/tables/WorksOrdersIdItemsTable.generated.tsx": "import { useGetApiWorksOrdersIdItems } from '@/sections/WorksOrders/services/useGetApiWorksOrdersIdItems.generated.ts'\nimport { useState } from 'react'\nimport { useParams, useNavigate } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Table, PageHeader, elMb5, elMb8, Tile, FlexContainer, FormLayout, Pagination } from '@reapit/elements'\nimport { ErrorBoundary } from '@/components/ErrorBoundary'\nimport { navigateRoute } from '@/lib/navigate'\n\nexport type UseWorksOrdersIdItemsTableArgs = {id: string};\nexport const useWorksOrdersIdItemsTable = (args: UseWorksOrdersIdItemsTableArgs) => {\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 12,\n  })\n\n  const dataQuery = useGetApiWorksOrdersIdItems({\n    ...args,\n    pageNumber: pagination.pageIndex + 1,\n    pageSize: pagination.pageSize\n  })\n\n  const rows = dataQuery.data?._embedded ?? []\n\n  return { rows, dataQuery, pagination, setPagination }\n};\nexport const WorksOrdersIdItemsTable = () => {\n  const {id} = useParams()\n    \n    invariant(id, 'Missing id param')\n    \n\n  const navigate = useNavigate()\n\n  const { rows, dataQuery, pagination, setPagination } = useWorksOrdersIdItemsTable({id}) \n\n  return (\n    <ErrorBoundary>\n      <PageHeader\n        hasMaxWidth\n        pageTitle={{\n          children: 'WorksOrders',\n          hasBoldText: true,\n        }}\n        buttons={[\n          {\n            children: 'New worksOrdersIdItemsTable',\n            intent: 'primary',\n            className: elMb5,\n            onClick: navigateRoute(navigate, `/worksOrders/${id}/items/new`),\n          },\n        ]}\n      />\n      <FlexContainer hasMaxWidth isFlexColumn>\n        <Tile>\n          <form>\n            <FormLayout className={elMb8}></FormLayout>\n          </form>\n          <Table className={elMb8} rows={rows.map((row) => ({\n            cells: [],\n          }))} />\n           <div className={elMb8}>\n            <Pagination\n              callback={(nextPage) => setPagination({ ...pagination, pageIndex: nextPage - 1 })}\n              currentPage={pagination.pageIndex + 1}\n              numberPages={Math.ceil((dataQuery.data?.totalCount ?? 1) / pagination.pageSize)}\n            />\n          </div>\n        </Tile>\n      </FlexContainer>\n    </ErrorBoundary>\n  )\n}\n;",
  "src/sections/WorksOrders/services/useGetApiWorksOrdersIdItems.generated.ts": "import { getApiWorksOrdersIdItemsResponse } from '@/sections/WorksOrders/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery, keepPreviousData } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiWorksOrdersIdItemsFnArgs = {pageSize?: (number) | null | undefined, pageNumber?: (number) | null | undefined, id: string};\nexport const getApiWorksOrdersIdItemsFn = async ({pageSize, pageNumber, id}: GetApiWorksOrdersIdItemsFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/worksOrders/${id}/items${querySerialiser({args:{pageSize, pageNumber}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiWorksOrdersIdItemsResponse.parse(data)\n    };\nexport const useGetApiWorksOrdersIdItems = ({pageSize, pageNumber, id}: GetApiWorksOrdersIdItemsFnArgs) => {\n      const { error: errorSnack } = useSnack()\n      \n      const result = useQuery({\n        queryKey: ['WorksOrders', pageSize, pageNumber, id],\n        queryFn: () => getApiWorksOrdersIdItemsFn({pageSize, pageNumber, id}),\n        placeholderData: keepPreviousData\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/schemas/worksOrderItemModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { worksOrderItemModel, WorksOrderItemModel } from '@/schemas/worksOrderItemModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const worksOrderItemModelPagedResult = z.object({_embedded: z.array(worksOrderItemModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type WorksOrderItemModelPagedResult = {_embedded?: (Array<WorksOrderItemModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/sections/WorksOrders/forms/CreateWorksOrdersIdItems.example.tsx": "import { CreateWorksOrdersIdItemsForm, fieldNames, CreateWorksOrdersIdItemsFormFields } from '@/sections/WorksOrders/forms/CreateWorksOrdersIdItemsForm.generated.tsx'\nimport { useParams } from 'react-router-dom'\nimport { default as invariant } from 'tiny-invariant'\nimport { Tile, FlexContainer, Button, FormLayout } from '@reapit/elements'\n\nexport const CreateWorksOrdersIdItems = () => {\n      const { id } = useParams()\n\n      invariant(id, 'Expected id to be defined')\n    \n      return (\n        <FlexContainer hasMaxWidth isFlexColumn>\n          <Tile>\n            <CreateWorksOrdersIdItemsForm id={id}>\n              <FormLayout>\n                <CreateWorksOrdersIdItemsFormFields fieldNames={fieldNames} />\n                <Button type=\"submit\" intent=\"primary\">Submit</Button>\n              </FormLayout>\n            </CreateWorksOrdersIdItemsForm>\n          </Tile>\n        </FlexContainer>\n      )\n    };",
  "src/sections/WorksOrders/forms/CreateWorksOrdersIdItemsForm.generated.tsx": "import { CreateApiWorksOrdersIdItemsBody, createApiWorksOrdersIdItemsBody } from '@/sections/WorksOrders/services/apiTypes.generated.ts'\nimport { createWorksOrdersIdItemsConfig } from '@/sections/WorksOrders/config/createWorksOrdersIdItemsConfig.example.tsx'\nimport { FieldParent, fieldsConfig } from '@/components/ModelRuntimeConfig'\nimport { useCreateApiWorksOrdersIdItems } from '@/sections/WorksOrders/services/useCreateApiWorksOrdersIdItems.generated.ts'\nimport { useForm, FormProvider } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { useSnack } from '@reapit/elements'\nimport { useNavigate } from 'react-router-dom'\nimport { ReactNode, useEffect } from 'react'\n\nexport const CreateWorksOrdersIdItemsFormFields = ({fieldNames}: {fieldNames: (keyof CreateApiWorksOrdersIdItemsBody)[]}) => (\n      <>\n        {fieldNames.map((fieldName) => (\n          <FieldParent key={fieldName} fieldName={fieldName} fieldConfig={createWorksOrdersIdItemsConfig[fieldName]} />\n        ))}\n      </>\n    );\nexport type CreateWorksOrdersIdItemsFormProps = {id: string, children: ReactNode, defaultValues?: CreateApiWorksOrdersIdItemsBody, onSuccess?: () => void};\nexport const CreateWorksOrdersIdItemsForm = (props: CreateWorksOrdersIdItemsFormProps) => {\n      const navigate = useNavigate()\n      const { success: successSnack } = useSnack()\n      \n      const methods = useForm<CreateApiWorksOrdersIdItemsBody>({\n        resolver: zodResolver(createApiWorksOrdersIdItemsBody),\n        defaultValues: props.defaultValues\n      })\n\n      const mutator = useCreateApiWorksOrdersIdItems()\n\n      useEffect(() => {\n        if (mutator.isSuccess) {\n          if(props.onSuccess) {  \n            props.onSuccess()\n            return\n          }\n          successSnack('Success')\n          navigate('..', {relative: 'path'})\n        }\n      }, [mutator.isSuccess])\n\n      return (\n        <FormProvider {...methods}>\n          <form onSubmit={methods.handleSubmit(body => {\n              mutator.mutate({ ...props, body })\n            })}\n          >\n            {props.children}\n          </form>\n        </FormProvider>\n      )\n    };\nexport const fieldNames = fieldsConfig<CreateApiWorksOrdersIdItemsBody>({notes: true, chargeTo: true, estimate: true, estimateType: true, netAmount: true, vatAmount: true, reserveAmount: true});",
  "src/sections/WorksOrders/config/createWorksOrdersIdItemsConfig.example.tsx": "import { CreateApiWorksOrdersIdItemsBody } from '@/sections/WorksOrders/services/apiTypes.generated.ts'\nimport { StringInput } from '@/inputs/StringInput.tsx'\nimport { InputWrap } from '@reapit/elements'\nimport { NumberInput } from '@/inputs/NumberInput.tsx'\nimport { ModelConfig } from '@/components/ModelRuntimeConfig'\n\nexport const createWorksOrdersIdItemsConfig: ModelConfig<CreateApiWorksOrdersIdItemsBody> = {notes: {\n      key: 'notes',\n      label: 'notes',\n      defaultValue: '',\n      placeholder: 'notes',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, chargeTo: {\n      key: 'chargeTo',\n      label: 'chargeTo',\n      defaultValue: '',\n      placeholder: 'chargeTo',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, estimate: {\n      key: 'estimate',\n      label: 'estimate',\n      defaultValue: null,\n      placeholder: 'estimate',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><NumberInput {...props} /></InputWrap>\n    }, estimateType: {\n      key: 'estimateType',\n      label: 'estimateType',\n      defaultValue: '',\n      placeholder: 'estimateType',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><StringInput {...props} /></InputWrap>\n    }, netAmount: {\n      key: 'netAmount',\n      label: 'netAmount',\n      defaultValue: null,\n      placeholder: 'netAmount',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><NumberInput {...props} /></InputWrap>\n    }, vatAmount: {\n      key: 'vatAmount',\n      label: 'vatAmount',\n      defaultValue: null,\n      placeholder: 'vatAmount',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><NumberInput {...props} /></InputWrap>\n    }, reserveAmount: {\n      key: 'reserveAmount',\n      label: 'reserveAmount',\n      defaultValue: null,\n      placeholder: 'reserveAmount',\n      icon: undefined,\n      format: (value) => `${value}`,\n      Input: props => <InputWrap><NumberInput {...props} /></InputWrap>\n    }};",
  "src/sections/WorksOrders/services/useCreateApiWorksOrdersIdItems.generated.ts": "import { CreateWorksOrderItemModel } from '@/schemas/createWorksOrderItemModel.generated.tsx'\nimport { createApiWorksOrdersIdItemsResponse } from '@/sections/WorksOrders/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type CreateApiWorksOrdersIdItemsFnArgs = {id: string, body: CreateWorksOrderItemModel};\nexport const createApiWorksOrdersIdItemsFn = async ({id, body}: CreateApiWorksOrdersIdItemsFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/worksOrders/${id}/items${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return createApiWorksOrdersIdItemsResponse.parse(data)\n    };\nexport const useCreateApiWorksOrdersIdItems = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: createApiWorksOrdersIdItemsFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['WorksOrders']})\n        }\n      })\n    };",
  "src/sections/Applicants/inputs/ApplicantsInput.generated.tsx": "import { useGetApiApplicants } from '@/sections/Applicants/services/useGetApiApplicants.generated.ts'\nimport { FieldValues, useFormContext, Controller } from 'react-hook-form'\nimport { ContextInputProps, KeyPath, Option } from '@/components/ModelRuntimeConfig'\nimport { InputError, InputGroup, MultiSelectInput } from '@reapit/elements'\nimport { useState } from 'react'\n\nexport const ApplicantsInput = <Model extends FieldValues, Key extends KeyPath<Model>>({\n  fieldName,\n  fieldConfig,\n}: ContextInputProps<Model, Key>) => {\n  const { icon, label, placeholder } = fieldConfig\n\n  const [queryText, setQueryText] = useState('')\n\n  const response = useGetApiApplicants({ name: queryText })\n\n  const { control } = useFormContext<Model>()\n\n  return (\n    <>\n      <InputGroup\n        onChange={(event) => setQueryText(event.target.value)}\n        icon={icon}\n        placeholder={placeholder}\n        label={label}\n      />\n      <Controller\n        control={control}\n        name={fieldName}\n        render={({ field, fieldState }) => (\n          <>\n            <MultiSelectInput\n              id={fieldName}\n              {...field}\n              value={field.value?.join(',') ?? ''}\n              onChange={(event) => field.onChange(event.target.value.split(','))}\n              options={\n                response?.data?._embedded\n                  ?.filter((option): option is Option => Boolean(option.id))\n                  ?.map(({ id }) => ({ value: id, name: id })) ?? []\n              }\n            />\n            {fieldState.error?.message && <InputError message={fieldState.error.message} />}\n          </>\n        )}\n      />\n    </>\n  )\n};",
  "src/sections/Areas/inputs/AreasInput.generated.tsx": "import { useGetApiAreas } from '@/sections/Areas/services/useGetApiAreas.generated.ts'\nimport { FieldValues, useFormContext, Controller } from 'react-hook-form'\nimport { ContextInputProps, KeyPath, Option } from '@/components/ModelRuntimeConfig'\nimport { InputError, InputGroup, MultiSelectInput } from '@reapit/elements'\nimport { useState } from 'react'\n\nexport const AreasInput = <Model extends FieldValues, Key extends KeyPath<Model>>({\n  fieldName,\n  fieldConfig,\n}: ContextInputProps<Model, Key>) => {\n  const { icon, label, placeholder } = fieldConfig\n\n  const [queryText, setQueryText] = useState('')\n\n  const response = useGetApiAreas({ name: queryText })\n\n  const { control } = useFormContext<Model>()\n\n  return (\n    <>\n      <InputGroup\n        onChange={(event) => setQueryText(event.target.value)}\n        icon={icon}\n        placeholder={placeholder}\n        label={label}\n      />\n      <Controller\n        control={control}\n        name={fieldName}\n        render={({ field, fieldState }) => (\n          <>\n            <MultiSelectInput\n              id={fieldName}\n              {...field}\n              value={field.value?.join(',') ?? ''}\n              onChange={(event) => field.onChange(event.target.value.split(','))}\n              options={\n                response?.data?._embedded\n                  ?.filter((option): option is Option => Boolean(option.id))\n                  ?.map(({ id }) => ({ value: id, name: id })) ?? []\n              }\n            />\n            {fieldState.error?.message && <InputError message={fieldState.error.message} />}\n          </>\n        )}\n      />\n    </>\n  )\n};",
  "src/sections/Companies/inputs/CompaniesInput.generated.tsx": "import { useGetApiCompanies } from '@/sections/Companies/services/useGetApiCompanies.generated.ts'\nimport { FieldValues, useFormContext, Controller } from 'react-hook-form'\nimport { ContextInputProps, KeyPath, Option } from '@/components/ModelRuntimeConfig'\nimport { InputError, InputGroup, MultiSelectInput } from '@reapit/elements'\nimport { useState } from 'react'\n\nexport const CompaniesInput = <Model extends FieldValues, Key extends KeyPath<Model>>({\n  fieldName,\n  fieldConfig,\n}: ContextInputProps<Model, Key>) => {\n  const { icon, label, placeholder } = fieldConfig\n\n  const [queryText, setQueryText] = useState('')\n\n  const response = useGetApiCompanies({ name: queryText })\n\n  const { control } = useFormContext<Model>()\n\n  return (\n    <>\n      <InputGroup\n        onChange={(event) => setQueryText(event.target.value)}\n        icon={icon}\n        placeholder={placeholder}\n        label={label}\n      />\n      <Controller\n        control={control}\n        name={fieldName}\n        render={({ field, fieldState }) => (\n          <>\n            <MultiSelectInput\n              id={fieldName}\n              {...field}\n              value={field.value?.join(',') ?? ''}\n              onChange={(event) => field.onChange(event.target.value.split(','))}\n              options={\n                response?.data?._embedded\n                  ?.filter((option): option is Option => Boolean(option.id))\n                  ?.map(({ id }) => ({ value: id, name: id })) ?? []\n              }\n            />\n            {fieldState.error?.message && <InputError message={fieldState.error.message} />}\n          </>\n        )}\n      />\n    </>\n  )\n};",
  "src/sections/Contacts/inputs/ContactsInput.generated.tsx": "import { useGetApiContacts } from '@/sections/Contacts/services/useGetApiContacts.generated.ts'\nimport { FieldValues, useFormContext, Controller } from 'react-hook-form'\nimport { ContextInputProps, KeyPath, Option } from '@/components/ModelRuntimeConfig'\nimport { InputError, InputGroup, MultiSelectInput } from '@reapit/elements'\nimport { useState } from 'react'\n\nexport const ContactsInput = <Model extends FieldValues, Key extends KeyPath<Model>>({\n  fieldName,\n  fieldConfig,\n}: ContextInputProps<Model, Key>) => {\n  const { icon, label, placeholder } = fieldConfig\n\n  const [queryText, setQueryText] = useState('')\n\n  const response = useGetApiContacts({ name: queryText })\n\n  const { control } = useFormContext<Model>()\n\n  return (\n    <>\n      <InputGroup\n        onChange={(event) => setQueryText(event.target.value)}\n        icon={icon}\n        placeholder={placeholder}\n        label={label}\n      />\n      <Controller\n        control={control}\n        name={fieldName}\n        render={({ field, fieldState }) => (\n          <>\n            <MultiSelectInput\n              id={fieldName}\n              {...field}\n              value={field.value?.join(',') ?? ''}\n              onChange={(event) => field.onChange(event.target.value.split(','))}\n              options={\n                response?.data?._embedded\n                  ?.filter((option): option is Option => Boolean(option.id))\n                  ?.map(({ id }) => ({ value: id, name: id })) ?? []\n              }\n            />\n            {fieldState.error?.message && <InputError message={fieldState.error.message} />}\n          </>\n        )}\n      />\n    </>\n  )\n};",
  "src/sections/Departments/inputs/DepartmentsInput.generated.tsx": "import { useGetApiDepartments } from '@/sections/Departments/services/useGetApiDepartments.generated.ts'\nimport { FieldValues, useFormContext, Controller } from 'react-hook-form'\nimport { ContextInputProps, KeyPath, Option } from '@/components/ModelRuntimeConfig'\nimport { InputError, InputGroup, MultiSelectInput } from '@reapit/elements'\nimport { useState } from 'react'\n\nexport const DepartmentsInput = <Model extends FieldValues, Key extends KeyPath<Model>>({\n  fieldName,\n  fieldConfig,\n}: ContextInputProps<Model, Key>) => {\n  const { icon, label, placeholder } = fieldConfig\n\n  const [queryText, setQueryText] = useState('')\n\n  const response = useGetApiDepartments({ name: queryText })\n\n  const { control } = useFormContext<Model>()\n\n  return (\n    <>\n      <InputGroup\n        onChange={(event) => setQueryText(event.target.value)}\n        icon={icon}\n        placeholder={placeholder}\n        label={label}\n      />\n      <Controller\n        control={control}\n        name={fieldName}\n        render={({ field, fieldState }) => (\n          <>\n            <MultiSelectInput\n              id={fieldName}\n              {...field}\n              value={field.value?.join(',') ?? ''}\n              onChange={(event) => field.onChange(event.target.value.split(','))}\n              options={\n                response?.data?._embedded\n                  ?.filter((option): option is Option => Boolean(option.id))\n                  ?.map(({ id }) => ({ value: id, name: id })) ?? []\n              }\n            />\n            {fieldState.error?.message && <InputError message={fieldState.error.message} />}\n          </>\n        )}\n      />\n    </>\n  )\n};",
  "src/sections/Landlords/inputs/LandlordsInput.generated.tsx": "import { useGetApiLandlords } from '@/sections/Landlords/services/useGetApiLandlords.generated.ts'\nimport { FieldValues, useFormContext, Controller } from 'react-hook-form'\nimport { ContextInputProps, KeyPath, Option } from '@/components/ModelRuntimeConfig'\nimport { InputError, InputGroup, MultiSelectInput } from '@reapit/elements'\nimport { useState } from 'react'\n\nexport const LandlordsInput = <Model extends FieldValues, Key extends KeyPath<Model>>({\n  fieldName,\n  fieldConfig,\n}: ContextInputProps<Model, Key>) => {\n  const { icon, label, placeholder } = fieldConfig\n\n  const [queryText, setQueryText] = useState('')\n\n  const response = useGetApiLandlords({ name: queryText })\n\n  const { control } = useFormContext<Model>()\n\n  return (\n    <>\n      <InputGroup\n        onChange={(event) => setQueryText(event.target.value)}\n        icon={icon}\n        placeholder={placeholder}\n        label={label}\n      />\n      <Controller\n        control={control}\n        name={fieldName}\n        render={({ field, fieldState }) => (\n          <>\n            <MultiSelectInput\n              id={fieldName}\n              {...field}\n              value={field.value?.join(',') ?? ''}\n              onChange={(event) => field.onChange(event.target.value.split(','))}\n              options={\n                response?.data?._embedded\n                  ?.filter((option): option is Option => Boolean(option.id))\n                  ?.map(({ id }) => ({ value: id, name: id })) ?? []\n              }\n            />\n            {fieldState.error?.message && <InputError message={fieldState.error.message} />}\n          </>\n        )}\n      />\n    </>\n  )\n};",
  "src/sections/Offers/inputs/OffersInput.generated.tsx": "import { useGetApiOffers } from '@/sections/Offers/services/useGetApiOffers.generated.ts'\nimport { FieldValues, useFormContext, Controller } from 'react-hook-form'\nimport { ContextInputProps, KeyPath, Option } from '@/components/ModelRuntimeConfig'\nimport { InputError, InputGroup, MultiSelectInput } from '@reapit/elements'\nimport { useState } from 'react'\n\nexport const OffersInput = <Model extends FieldValues, Key extends KeyPath<Model>>({\n  fieldName,\n  fieldConfig,\n}: ContextInputProps<Model, Key>) => {\n  const { icon, label, placeholder } = fieldConfig\n\n  const [queryText, setQueryText] = useState('')\n\n  const response = useGetApiOffers({ name: queryText })\n\n  const { control } = useFormContext<Model>()\n\n  return (\n    <>\n      <InputGroup\n        onChange={(event) => setQueryText(event.target.value)}\n        icon={icon}\n        placeholder={placeholder}\n        label={label}\n      />\n      <Controller\n        control={control}\n        name={fieldName}\n        render={({ field, fieldState }) => (\n          <>\n            <MultiSelectInput\n              id={fieldName}\n              {...field}\n              value={field.value?.join(',') ?? ''}\n              onChange={(event) => field.onChange(event.target.value.split(','))}\n              options={\n                response?.data?._embedded\n                  ?.filter((option): option is Option => Boolean(option.id))\n                  ?.map(({ id }) => ({ value: id, name: id })) ?? []\n              }\n            />\n            {fieldState.error?.message && <InputError message={fieldState.error.message} />}\n          </>\n        )}\n      />\n    </>\n  )\n};",
  "src/sections/Sources/inputs/SourcesInput.generated.tsx": "import { useGetApiSources } from '@/sections/Sources/services/useGetApiSources.generated.ts'\nimport { FieldValues, useFormContext, Controller } from 'react-hook-form'\nimport { ContextInputProps, KeyPath, Option } from '@/components/ModelRuntimeConfig'\nimport { InputError, InputGroup, MultiSelectInput } from '@reapit/elements'\nimport { useState } from 'react'\n\nexport const SourcesInput = <Model extends FieldValues, Key extends KeyPath<Model>>({\n  fieldName,\n  fieldConfig,\n}: ContextInputProps<Model, Key>) => {\n  const { icon, label, placeholder } = fieldConfig\n\n  const [queryText, setQueryText] = useState('')\n\n  const response = useGetApiSources({ name: queryText })\n\n  const { control } = useFormContext<Model>()\n\n  return (\n    <>\n      <InputGroup\n        onChange={(event) => setQueryText(event.target.value)}\n        icon={icon}\n        placeholder={placeholder}\n        label={label}\n      />\n      <Controller\n        control={control}\n        name={fieldName}\n        render={({ field, fieldState }) => (\n          <>\n            <MultiSelectInput\n              id={fieldName}\n              {...field}\n              value={field.value?.join(',') ?? ''}\n              onChange={(event) => field.onChange(event.target.value.split(','))}\n              options={\n                response?.data?._embedded\n                  ?.filter((option): option is Option => Boolean(option.id))\n                  ?.map(({ id }) => ({ value: id, name: id })) ?? []\n              }\n            />\n            {fieldState.error?.message && <InputError message={fieldState.error.message} />}\n          </>\n        )}\n      />\n    </>\n  )\n};",
  "src/sections/Tenancies/inputs/TenanciesInput.generated.tsx": "import { useGetApiTenancies } from '@/sections/Tenancies/services/useGetApiTenancies.generated.ts'\nimport { FieldValues, useFormContext, Controller } from 'react-hook-form'\nimport { ContextInputProps, KeyPath, Option } from '@/components/ModelRuntimeConfig'\nimport { InputError, InputGroup, MultiSelectInput } from '@reapit/elements'\nimport { useState } from 'react'\n\nexport const TenanciesInput = <Model extends FieldValues, Key extends KeyPath<Model>>({\n  fieldName,\n  fieldConfig,\n}: ContextInputProps<Model, Key>) => {\n  const { icon, label, placeholder } = fieldConfig\n\n  const [queryText, setQueryText] = useState('')\n\n  const response = useGetApiTenancies({ name: queryText })\n\n  const { control } = useFormContext<Model>()\n\n  return (\n    <>\n      <InputGroup\n        onChange={(event) => setQueryText(event.target.value)}\n        icon={icon}\n        placeholder={placeholder}\n        label={label}\n      />\n      <Controller\n        control={control}\n        name={fieldName}\n        render={({ field, fieldState }) => (\n          <>\n            <MultiSelectInput\n              id={fieldName}\n              {...field}\n              value={field.value?.join(',') ?? ''}\n              onChange={(event) => field.onChange(event.target.value.split(','))}\n              options={\n                response?.data?._embedded\n                  ?.filter((option): option is Option => Boolean(option.id))\n                  ?.map(({ id }) => ({ value: id, name: id })) ?? []\n              }\n            />\n            {fieldState.error?.message && <InputError message={fieldState.error.message} />}\n          </>\n        )}\n      />\n    </>\n  )\n};",
  "src/sections/Vendors/inputs/VendorsInput.generated.tsx": "import { useGetApiVendors } from '@/sections/Vendors/services/useGetApiVendors.generated.ts'\nimport { FieldValues, useFormContext, Controller } from 'react-hook-form'\nimport { ContextInputProps, KeyPath, Option } from '@/components/ModelRuntimeConfig'\nimport { InputError, InputGroup, MultiSelectInput } from '@reapit/elements'\nimport { useState } from 'react'\n\nexport const VendorsInput = <Model extends FieldValues, Key extends KeyPath<Model>>({\n  fieldName,\n  fieldConfig,\n}: ContextInputProps<Model, Key>) => {\n  const { icon, label, placeholder } = fieldConfig\n\n  const [queryText, setQueryText] = useState('')\n\n  const response = useGetApiVendors({ name: queryText })\n\n  const { control } = useFormContext<Model>()\n\n  return (\n    <>\n      <InputGroup\n        onChange={(event) => setQueryText(event.target.value)}\n        icon={icon}\n        placeholder={placeholder}\n        label={label}\n      />\n      <Controller\n        control={control}\n        name={fieldName}\n        render={({ field, fieldState }) => (\n          <>\n            <MultiSelectInput\n              id={fieldName}\n              {...field}\n              value={field.value?.join(',') ?? ''}\n              onChange={(event) => field.onChange(event.target.value.split(','))}\n              options={\n                response?.data?._embedded\n                  ?.filter((option): option is Option => Boolean(option.id))\n                  ?.map(({ id }) => ({ value: id, name: id })) ?? []\n              }\n            />\n            {fieldState.error?.message && <InputError message={fieldState.error.message} />}\n          </>\n        )}\n      />\n    </>\n  )\n};",
  "src/sections/Applicants/services/useGetApiApplicantsId.generated.ts": "import { getApiApplicantsIdResponse } from '@/sections/Applicants/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiApplicantsIdFnArgs = {id: string, embed?: (Array<'appointments' | 'areas' | 'department' | 'documents' | 'negotiators' | 'offers' | 'offices' | 'solicitor' | 'source'>) | null | undefined};\nexport const getApiApplicantsIdFn = async ({id, embed}: GetApiApplicantsIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/applicants/${id}${querySerialiser({args:{embed}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiApplicantsIdResponse.parse(data)\n    };\nexport const useGetApiApplicantsId = ({id, embed}: GetApiApplicantsIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Applicants', id, embed],\n        queryFn: () => getApiApplicantsIdFn({id, embed})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Applicants/services/usePatchApiApplicantsId.generated.ts": "import { UpdateApplicantModel } from '@/schemas/updateApplicantModel.generated.tsx'\nimport { patchApiApplicantsIdResponse } from '@/sections/Applicants/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type PatchApiApplicantsIdFnArgs = {'If-Match'?: string, id: string, body: UpdateApplicantModel};\nexport const patchApiApplicantsIdFn = async ({'If-Match': ifMatch, id, body}: PatchApiApplicantsIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({'If-Match': ifMatch})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/applicants/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PATCH',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return patchApiApplicantsIdResponse.parse(data)\n    };\nexport const usePatchApiApplicantsId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: patchApiApplicantsIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Applicants']})\n        }\n      })\n    };",
  "src/schemas/updateApplicantModel.generated.tsx": "import { ApplicantBuyingModel, applicantBuyingModel } from '@/schemas/applicantBuyingModel.generated.tsx'\nimport { UpdateApplicantRentingModel, updateApplicantRentingModel } from '@/schemas/updateApplicantRentingModel.generated.tsx'\nimport { ApplicantExternalAreaModel, applicantExternalAreaModel } from '@/schemas/applicantExternalAreaModel.generated.tsx'\nimport { ApplicantInternalAreaModel, applicantInternalAreaModel } from '@/schemas/applicantInternalAreaModel.generated.tsx'\nimport { ApplicantSourceModel, applicantSourceModel } from '@/schemas/applicantSourceModel.generated.tsx'\nimport { ApplicantRegionalModel, applicantRegionalModel } from '@/schemas/applicantRegionalModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type UpdateApplicantModel = /** Request body used to update an existing applicant */\n{marketingMode?: (/** Indicates whether the applicant is look to buy or rent a property (buying/renting) */\nstring) | null | undefined, currency?: (/** The ISO-4217 currency code that relates to monetary amounts specified by the applicant\r\nWhere not specified this will default to the customer's base currency */\nstring) | null | undefined, active?: (/** A flag determining whether or not the applicant is actively looking for a property */\nboolean) | null | undefined, notes?: (/** A free text field describing any adhoc buying or renting requirements */\nstring) | null | undefined, statusId?: (/** The status id of the applicant */\nstring) | null | undefined, sellingStatus?: (/** The applicant's selling status (preAppraisal/valuation/paidValuation/forSale/forSaleUnavailable/underOffer/underOfferUnavailable/reserved/exchanged/completed/soldExternally/withdrawn) */\nstring) | null | undefined, sellingPosition?: (/** The applicant's selling position (nothingToSell/renting/sellingWithUs/sellingWithOtherAgent/sellingPrivately/notYetOnMarket) */\nstring) | null | undefined, lastCall?: (/** The date when the applicant was last contacted */\nstring) | null | undefined, nextCall?: (/** The date when the applicant is next due to be contacted */\nstring) | null | undefined, departmentId?: (/** The unique identifier of the department that the applicant requirements are associated with. The applicant will only match to properties with the same value */\nstring) | null | undefined, solicitorId?: (/** The unique identifier of the solicitor associated to the applicant */\nstring) | null | undefined, potentialClient?: (/** A flag determining whether or not the applicant is a potential client */\nboolean) | null | undefined, type?: (/** The applicant's property type requirements (eg house, bungalow, land), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<string>) | null | undefined, style?: (/** The applicant's property style requirements (eg detached, semiDetached), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<string>) | null | undefined, situation?: (/** The applicant's requirements for other aspects of prospective properties - such as outside space - as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<string>) | null | undefined, parking?: (/** The applicant's parking requirements (eg garage), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<string>) | null | undefined, age?: (/** The applicant's property age requirements (eg new, period), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<string>) | null | undefined, locality?: (/** The applicant's general property location requirements (eg rural, townCity), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<string>) | null | undefined, specialFeatures?: (/** The applicant's special feature property requirements (eg Swimming Pool, Tennis Court), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<string>) | null | undefined, bedroomsMin?: (/** The minimum number of bedrooms the applicant requires */\nnumber) | null | undefined, bedroomsMax?: (/** The maximum number of bedrooms the applicant requires */\nnumber) | null | undefined, receptionsMin?: (/** The minimum number of reception rooms the applicant requires */\nnumber) | null | undefined, receptionsMax?: (/** The maximum number of reception rooms the applicant requires */\nnumber) | null | undefined, bathroomsMin?: (/** The minimum number of bathrooms the applicant requires */\nnumber) | null | undefined, bathroomsMax?: (/** The maximum number of bathrooms the applicant requires */\nnumber) | null | undefined, parkingSpacesMin?: (/** The minimum number of parking spaces the applicant requires */\nnumber) | null | undefined, parkingSpacesMax?: (/** The maximum number of parking spaces the applicant requires */\nnumber) | null | undefined, locationType?: (/** The applicant's location type (areas/addresses/none) */\nstring) | null | undefined, locationOptions?: (/** The applicant's location options */\nArray<string>) | null | undefined, buying?: (ApplicantBuyingModel) | null | undefined, renting?: (UpdateApplicantRentingModel) | null | undefined, externalArea?: (ApplicantExternalAreaModel) | null | undefined, internalArea?: (ApplicantInternalAreaModel) | null | undefined, source?: (ApplicantSourceModel) | null | undefined, regional?: (ApplicantRegionalModel) | null | undefined, officeIds?: (/** A collection of unique identifiers of offices attached to the applicant. The first item in the collection is considered the primary office */\nArray<string>) | null | undefined, negotiatorIds?: (/** A collection of unique identifiers of negotiators attached to the applicant. The first item in the collection is considered the primary negotiator */\nArray<string>) | null | undefined, metadata?: (/** App specific metadata to set against the applicant */\nRecord<string, Record<string, never>>) | null | undefined};\nexport const updateApplicantModel = /** Request body used to update an existing applicant */\nz.object({marketingMode: /** Indicates whether the applicant is look to buy or rent a property (buying/renting) */\nz.string().optional().nullable(), currency: /** The ISO-4217 currency code that relates to monetary amounts specified by the applicant\r\nWhere not specified this will default to the customer's base currency */\nz.string().optional().nullable(), active: /** A flag determining whether or not the applicant is actively looking for a property */\nz.boolean().optional().nullable(), notes: /** A free text field describing any adhoc buying or renting requirements */\nz.string().optional().nullable(), statusId: /** The status id of the applicant */\nz.string().optional().nullable(), sellingStatus: /** The applicant's selling status (preAppraisal/valuation/paidValuation/forSale/forSaleUnavailable/underOffer/underOfferUnavailable/reserved/exchanged/completed/soldExternally/withdrawn) */\nz.string().optional().nullable(), sellingPosition: /** The applicant's selling position (nothingToSell/renting/sellingWithUs/sellingWithOtherAgent/sellingPrivately/notYetOnMarket) */\nz.string().optional().nullable(), lastCall: /** The date when the applicant was last contacted */\nz.string().optional().nullable(), nextCall: /** The date when the applicant is next due to be contacted */\nz.string().optional().nullable(), departmentId: /** The unique identifier of the department that the applicant requirements are associated with. The applicant will only match to properties with the same value */\nz.string().optional().nullable(), solicitorId: /** The unique identifier of the solicitor associated to the applicant */\nz.string().optional().nullable(), potentialClient: /** A flag determining whether or not the applicant is a potential client */\nz.boolean().optional().nullable(), type: /** The applicant's property type requirements (eg house, bungalow, land), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(z.string().min(1)).optional().nullable(), style: /** The applicant's property style requirements (eg detached, semiDetached), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(z.string().min(1)).optional().nullable(), situation: /** The applicant's requirements for other aspects of prospective properties - such as outside space - as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(z.string().min(1)).optional().nullable(), parking: /** The applicant's parking requirements (eg garage), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(z.string().min(1)).optional().nullable(), age: /** The applicant's property age requirements (eg new, period), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(z.string().min(1)).optional().nullable(), locality: /** The applicant's general property location requirements (eg rural, townCity), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(z.string().min(1)).optional().nullable(), specialFeatures: /** The applicant's special feature property requirements (eg Swimming Pool, Tennis Court), as defined by the applicant's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(z.string().min(1)).optional().nullable(), bedroomsMin: /** The minimum number of bedrooms the applicant requires */\nz.number().int().optional().nullable(), bedroomsMax: /** The maximum number of bedrooms the applicant requires */\nz.number().int().optional().nullable(), receptionsMin: /** The minimum number of reception rooms the applicant requires */\nz.number().int().optional().nullable(), receptionsMax: /** The maximum number of reception rooms the applicant requires */\nz.number().int().optional().nullable(), bathroomsMin: /** The minimum number of bathrooms the applicant requires */\nz.number().int().optional().nullable(), bathroomsMax: /** The maximum number of bathrooms the applicant requires */\nz.number().int().optional().nullable(), parkingSpacesMin: /** The minimum number of parking spaces the applicant requires */\nz.number().int().optional().nullable(), parkingSpacesMax: /** The maximum number of parking spaces the applicant requires */\nz.number().int().optional().nullable(), locationType: /** The applicant's location type (areas/addresses/none) */\nz.string().optional().nullable(), locationOptions: /** The applicant's location options */\nz.array(z.string().min(1)).optional().nullable(), buying: applicantBuyingModel.optional().nullable(), renting: updateApplicantRentingModel.optional().nullable(), externalArea: applicantExternalAreaModel.optional().nullable(), internalArea: applicantInternalAreaModel.optional().nullable(), source: applicantSourceModel.optional().nullable(), regional: applicantRegionalModel.optional().nullable(), officeIds: /** A collection of unique identifiers of offices attached to the applicant. The first item in the collection is considered the primary office */\nz.array(z.string().min(1)).optional().nullable(), negotiatorIds: /** A collection of unique identifiers of negotiators attached to the applicant. The first item in the collection is considered the primary negotiator */\nz.array(z.string().min(1)).optional().nullable(), metadata: /** App specific metadata to set against the applicant */\nz.record(z.string(), z.object({})).optional().nullable()});",
  "src/schemas/updateApplicantRentingModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateApplicantRentingModel = /** The details specific to applicants with a marketingMode of renting */\n{moveDate?: (/** The date the applicant is looking to move to a new property */\nstring) | null | undefined, term?: (/** The applicant's preferred letting term (long/short/any) */\nstring) | null | undefined, rentFrom?: (/** The lower bound of the applicant's budget */\nnumber) | null | undefined, rentTo?: (/** The upper bound of the applicant's budget */\nnumber) | null | undefined, rentFrequency?: (/** The desired rent collection frequency specified by the applicant's budget (weekly/monthly/annually) */\nstring) | null | undefined, furnishing?: (/** A list of property furnishing requirements taken from the full listing of the associated department */\nArray<string>) | null | undefined, positionId?: (/** The identifier of the applicant's renting position */\nstring) | null | undefined};\nexport const updateApplicantRentingModel = /** The details specific to applicants with a marketingMode of renting */\nz.object({moveDate: /** The date the applicant is looking to move to a new property */\nz.string().optional().nullable(), term: /** The applicant's preferred letting term (long/short/any) */\nz.string().optional().nullable(), rentFrom: /** The lower bound of the applicant's budget */\nz.number().optional().nullable(), rentTo: /** The upper bound of the applicant's budget */\nz.number().optional().nullable(), rentFrequency: /** The desired rent collection frequency specified by the applicant's budget (weekly/monthly/annually) */\nz.string().optional().nullable(), furnishing: /** A list of property furnishing requirements taken from the full listing of the associated department */\nz.array(z.string().min(1)).optional().nullable(), positionId: /** The identifier of the applicant's renting position */\nz.string().optional().nullable()});",
  "src/sections/Applicants/services/useGetApiApplicantsIdRelationshipsRelationshipId.generated.ts": "import { getApiApplicantsIdRelationshipsRelationshipIdResponse } from '@/sections/Applicants/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiApplicantsIdRelationshipsRelationshipIdFnArgs = {id: string, relationshipId: string};\nexport const getApiApplicantsIdRelationshipsRelationshipIdFn = async ({id, relationshipId}: GetApiApplicantsIdRelationshipsRelationshipIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/applicants/${id}/relationships/${relationshipId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiApplicantsIdRelationshipsRelationshipIdResponse.parse(data)\n    };\nexport const useGetApiApplicantsIdRelationshipsRelationshipId = ({id, relationshipId}: GetApiApplicantsIdRelationshipsRelationshipIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Applicants', id, relationshipId],\n        queryFn: () => getApiApplicantsIdRelationshipsRelationshipIdFn({id, relationshipId})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Applicants/services/useDeleteApiApplicantsIdRelationshipsRelationshipId.generated.ts": "import { deleteApiApplicantsIdRelationshipsRelationshipIdResponse } from '@/sections/Applicants/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type DeleteApiApplicantsIdRelationshipsRelationshipIdFnArgs = {id: string, relationshipId: string};\nexport const deleteApiApplicantsIdRelationshipsRelationshipIdFn = async ({id, relationshipId}: DeleteApiApplicantsIdRelationshipsRelationshipIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/applicants/${id}/relationships/${relationshipId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'DELETE',\n          \n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return deleteApiApplicantsIdRelationshipsRelationshipIdResponse.parse(data)\n    };\nexport const useDeleteApiApplicantsIdRelationshipsRelationshipId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: deleteApiApplicantsIdRelationshipsRelationshipIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Applicants']})\n        }\n      })\n    };",
  "src/sections/Areas/services/useGetApiAreasId.generated.ts": "import { getApiAreasIdResponse } from '@/sections/Areas/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiAreasIdFnArgs = {id: string};\nexport const getApiAreasIdFn = async ({id}: GetApiAreasIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/areas/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiAreasIdResponse.parse(data)\n    };\nexport const useGetApiAreasId = ({id}: GetApiAreasIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Areas', id],\n        queryFn: () => getApiAreasIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Areas/services/usePatchApiAreasId.generated.ts": "import { UpdateAreaModel } from '@/schemas/updateAreaModel.generated.tsx'\nimport { patchApiAreasIdResponse } from '@/sections/Areas/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type PatchApiAreasIdFnArgs = {'If-Match'?: string, id: string, body: UpdateAreaModel};\nexport const patchApiAreasIdFn = async ({'If-Match': ifMatch, id, body}: PatchApiAreasIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({'If-Match': ifMatch})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/areas/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PATCH',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return patchApiAreasIdResponse.parse(data)\n    };\nexport const usePatchApiAreasId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: patchApiAreasIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Areas']})\n        }\n      })\n    };",
  "src/schemas/updateAreaModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateAreaModel = /** Request body used to update an existing area */\n{name?: (/** The name of the area */\nstring) | null | undefined, area?: (/** The location details (comma delimited list of postcodes, group ids or lat/long coordinate groups) */\nArray<string>) | null | undefined, departmentIds?: (/** A collection of unique identifiers of departments associated to the area */\nArray<string>) | null | undefined, officeIds?: (/** A collection of unique identifiers of offices attached to the area. The first item in the collection is considered the primary office */\nArray<string>) | null | undefined};\nexport const updateAreaModel = /** Request body used to update an existing area */\nz.object({name: /** The name of the area */\nz.string().optional().nullable(), area: /** The location details (comma delimited list of postcodes, group ids or lat/long coordinate groups) */\nz.array(z.string().min(1)).optional().nullable(), departmentIds: /** A collection of unique identifiers of departments associated to the area */\nz.array(z.string().min(1)).optional().nullable(), officeIds: /** A collection of unique identifiers of offices attached to the area. The first item in the collection is considered the primary office */\nz.array(z.string().min(1)).optional().nullable()});",
  "src/sections/Appointments/services/useGetApiAppointmentsId.generated.ts": "import { getApiAppointmentsIdResponse } from '@/sections/Appointments/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiAppointmentsIdFnArgs = {id: string, embed?: (Array<'negotiators' | 'offices' | 'organiser' | 'property' | 'type'>) | null | undefined, extrasField?: (Array<string>) | null | undefined};\nexport const getApiAppointmentsIdFn = async ({id, embed, extrasField}: GetApiAppointmentsIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/appointments/${id}${querySerialiser({args:{embed, extrasField}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiAppointmentsIdResponse.parse(data)\n    };\nexport const useGetApiAppointmentsId = ({id, embed, extrasField}: GetApiAppointmentsIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Appointments', id, embed, extrasField],\n        queryFn: () => getApiAppointmentsIdFn({id, embed, extrasField})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Appointments/services/usePatchApiAppointmentsId.generated.ts": "import { UpdateAppointmentModel } from '@/schemas/updateAppointmentModel.generated.tsx'\nimport { patchApiAppointmentsIdResponse } from '@/sections/Appointments/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type PatchApiAppointmentsIdFnArgs = {'If-Match'?: string, id: string, body: UpdateAppointmentModel};\nexport const patchApiAppointmentsIdFn = async ({'If-Match': ifMatch, id, body}: PatchApiAppointmentsIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({'If-Match': ifMatch})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/appointments/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PATCH',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return patchApiAppointmentsIdResponse.parse(data)\n    };\nexport const usePatchApiAppointmentsId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: patchApiAppointmentsIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Appointments']})\n        }\n      })\n    };",
  "src/schemas/updateAppointmentModel.generated.tsx": "import { UpdateAppointmentAttendeeModel, updateAppointmentAttendeeModel } from '@/schemas/updateAppointmentAttendeeModel.generated.tsx'\nimport { UpdateAppointmentFollowUpModel, updateAppointmentFollowUpModel } from '@/schemas/updateAppointmentFollowUpModel.generated.tsx'\nimport { UpdateAppointmentRecurrenceModel, updateAppointmentRecurrenceModel } from '@/schemas/updateAppointmentRecurrenceModel.generated.tsx'\nimport { UpdateAppointmentDocumentModel, updateAppointmentDocumentModel } from '@/schemas/updateAppointmentDocumentModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type UpdateAppointmentModel = /** Request body used to update an existing calendar appointment */\n{start?: (/** The date and time when the appointment will start */\nDate) | null | undefined, end?: (/** The date and time when the appointment will end */\nDate) | null | undefined, followUpOn?: (/** The date when the appointment should be followed up */\nstring) | null | undefined, typeId?: (/** The unique identifier of the appointment type */\nstring) | null | undefined, description?: (/** A free text description about the appointment */\nstring) | null | undefined, propertyId?: (/** The unique identifier of the property related to the appointment */\nstring) | null | undefined, otherAgentId?: (/** The unique identifier of the external company either carrying out or attending the appointment with the agent */\nstring) | null | undefined, organiserId?: (/** The unique identifier of the negotiator that organised the appointment */\nstring) | null | undefined, cancelled?: (/** A flag denoting whether or not the appointment has been cancelled */\nboolean) | null | undefined, negotiatorIds?: (/** A collection of unique identifiers of negotiators attached to the appointment. The first item in the collection is considered the primary negotiator */\nArray<string>) | null | undefined, officeIds?: (/** A collection of unique identifiers of offices attached to the appointment. The first item in the collection is considered the primary office */\nArray<string>) | null | undefined, attendee?: (UpdateAppointmentAttendeeModel) | null | undefined, accompanied?: (/** A flag denoting whether or not the appointment will be accompanied by one or more negotiators */\nboolean) | null | undefined, virtual?: (/** A flag denoting whether or not the appointment is virtual */\nboolean) | null | undefined, isRepeat?: (/** A flag denoting whether or not the appointment is a subsequent appointment to a previous one (a repeat appointment for the same attendee) */\nboolean) | null | undefined, negotiatorConfirmed?: (/** A flag denoting whether or not the main negotiator has confirmed their attendance */\nboolean) | null | undefined, attendeeConfirmed?: (/** A flag denoting whether or not the attendee has confirmed their attendance */\nboolean) | null | undefined, propertyConfirmed?: (/** A flag denoting whether or not the property and/or property's vendor has confirmed their attendance */\nboolean) | null | undefined, attended?: (/** The attendance status of the appointment (notSet/noShow/attended) */\nstring) | null | undefined, followUp?: (UpdateAppointmentFollowUpModel) | null | undefined, recurrence?: (UpdateAppointmentRecurrenceModel) | null | undefined, documents?: (UpdateAppointmentDocumentModel) | null | undefined, metadata?: (/** App specific metadata to set against the appointment */\nRecord<string, Record<string, never>>) | null | undefined};\nexport const updateAppointmentModel = /** Request body used to update an existing calendar appointment */\nz.object({start: /** The date and time when the appointment will start */\nz.string().pipe( z.coerce.date() ).optional().nullable(), end: /** The date and time when the appointment will end */\nz.string().pipe( z.coerce.date() ).optional().nullable(), followUpOn: /** The date when the appointment should be followed up */\nz.string().optional().nullable(), typeId: /** The unique identifier of the appointment type */\nz.string().optional().nullable(), description: /** A free text description about the appointment */\nz.string().optional().nullable(), propertyId: /** The unique identifier of the property related to the appointment */\nz.string().optional().nullable(), otherAgentId: /** The unique identifier of the external company either carrying out or attending the appointment with the agent */\nz.string().optional().nullable(), organiserId: /** The unique identifier of the negotiator that organised the appointment */\nz.string().optional().nullable(), cancelled: /** A flag denoting whether or not the appointment has been cancelled */\nz.boolean().optional().nullable(), negotiatorIds: /** A collection of unique identifiers of negotiators attached to the appointment. The first item in the collection is considered the primary negotiator */\nz.array(z.string().min(1)).optional().nullable(), officeIds: /** A collection of unique identifiers of offices attached to the appointment. The first item in the collection is considered the primary office */\nz.array(z.string().min(1)).optional().nullable(), attendee: updateAppointmentAttendeeModel.optional().nullable(), accompanied: /** A flag denoting whether or not the appointment will be accompanied by one or more negotiators */\nz.boolean().optional().nullable(), virtual: /** A flag denoting whether or not the appointment is virtual */\nz.boolean().optional().nullable(), isRepeat: /** A flag denoting whether or not the appointment is a subsequent appointment to a previous one (a repeat appointment for the same attendee) */\nz.boolean().optional().nullable(), negotiatorConfirmed: /** A flag denoting whether or not the main negotiator has confirmed their attendance */\nz.boolean().optional().nullable(), attendeeConfirmed: /** A flag denoting whether or not the attendee has confirmed their attendance */\nz.boolean().optional().nullable(), propertyConfirmed: /** A flag denoting whether or not the property and/or property's vendor has confirmed their attendance */\nz.boolean().optional().nullable(), attended: /** The attendance status of the appointment (notSet/noShow/attended) */\nz.string().optional().nullable(), followUp: updateAppointmentFollowUpModel.optional().nullable(), recurrence: updateAppointmentRecurrenceModel.optional().nullable(), documents: updateAppointmentDocumentModel.optional().nullable(), metadata: /** App specific metadata to set against the appointment */\nz.record(z.string(), z.object({})).optional().nullable()});",
  "src/schemas/updateAppointmentAttendeeModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateAppointmentAttendeeModel = /** Represents an external attendee on an appointment */\n{id?: (/** The unique identifier of the attendee. To clear an attendee this can be passed as an empty string. */\nstring) | null | undefined, type?: (/** The type of attendee (applicant/contact/landlord/tenant) */\nstring) | null | undefined, confirmed?: (/** A flag denoting whether or not the attendee has confirmed their attendance */\nboolean) | null | undefined};\nexport const updateAppointmentAttendeeModel = /** Represents an external attendee on an appointment */\nz.object({id: /** The unique identifier of the attendee. To clear an attendee this can be passed as an empty string. */\nz.string().optional().nullable(), type: /** The type of attendee (applicant/contact/landlord/tenant) */\nz.string().optional().nullable(), confirmed: /** A flag denoting whether or not the attendee has confirmed their attendance */\nz.boolean().optional().nullable()});",
  "src/schemas/updateAppointmentFollowUpModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateAppointmentFollowUpModel = /** Represents the follow up information on a single appointment */\n{responseId?: (/** The unique identifier of a pre-defined follow up response type */\nstring) | null | undefined, notes?: (/** The internal follow up notes to be stored against the appointment */\nstring) | null | undefined};\nexport const updateAppointmentFollowUpModel = /** Represents the follow up information on a single appointment */\nz.object({responseId: /** The unique identifier of a pre-defined follow up response type */\nz.string().optional().nullable(), notes: /** The internal follow up notes to be stored against the appointment */\nz.string().optional().nullable()});",
  "src/schemas/updateAppointmentRecurrenceModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateAppointmentRecurrenceModel = /** Details of an appointment's recurrence pattern */\n{type?: (/** The type of unit that the `interval` applies to (daily/weekly/yearly/monthly) */\nstring) | null | undefined, interval?: (/** The numeric value denoting how often the appointment will recur */\nnumber) | null | undefined, until?: (/** The date and time of the last occurrence of the appointment */\nDate) | null | undefined};\nexport const updateAppointmentRecurrenceModel = /** Details of an appointment's recurrence pattern */\nz.object({type: /** The type of unit that the `interval` applies to (daily/weekly/yearly/monthly) */\nz.string().optional().nullable(), interval: /** The numeric value denoting how often the appointment will recur */\nz.number().int().optional().nullable(), until: /** The date and time of the last occurrence of the appointment */\nz.string().pipe( z.coerce.date() ).optional().nullable()});",
  "src/schemas/updateAppointmentDocumentModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateAppointmentDocumentModel = /** A view of the documents associated to the appointment */\n{draftPropertyInspectionReportId?: (/** The unique identifier of the draft property inspection report document */\nstring) | null | undefined, finalPropertyInspectionReportId?: (/** The unique identifier of the final property inspection report document */\nstring) | null | undefined};\nexport const updateAppointmentDocumentModel = /** A view of the documents associated to the appointment */\nz.object({draftPropertyInspectionReportId: /** The unique identifier of the draft property inspection report document */\nz.string().optional().nullable(), finalPropertyInspectionReportId: /** The unique identifier of the final property inspection report document */\nz.string().optional().nullable()});",
  "src/sections/Appointments/services/useGetApiAppointmentsIdOpenHouseAttendeesOpenHouseAttendeeId.generated.ts": "import { getApiAppointmentsIdOpenHouseAttendeesOpenHouseAttendeeIdResponse } from '@/sections/Appointments/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiAppointmentsIdOpenHouseAttendeesOpenHouseAttendeeIdFnArgs = {id: string, openHouseAttendeeId: string};\nexport const getApiAppointmentsIdOpenHouseAttendeesOpenHouseAttendeeIdFn = async ({id, openHouseAttendeeId}: GetApiAppointmentsIdOpenHouseAttendeesOpenHouseAttendeeIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/appointments/${id}/openHouseAttendees/${openHouseAttendeeId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiAppointmentsIdOpenHouseAttendeesOpenHouseAttendeeIdResponse.parse(data)\n    };\nexport const useGetApiAppointmentsIdOpenHouseAttendeesOpenHouseAttendeeId = ({id, openHouseAttendeeId}: GetApiAppointmentsIdOpenHouseAttendeesOpenHouseAttendeeIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Appointments', id, openHouseAttendeeId],\n        queryFn: () => getApiAppointmentsIdOpenHouseAttendeesOpenHouseAttendeeIdFn({id, openHouseAttendeeId})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Appointments/services/useDeleteApiAppointmentsIdOpenHouseAttendeesOpenHouseAttendeeId.generated.ts": "import { deleteApiAppointmentsIdOpenHouseAttendeesOpenHouseAttendeeIdResponse } from '@/sections/Appointments/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type DeleteApiAppointmentsIdOpenHouseAttendeesOpenHouseAttendeeIdFnArgs = {id: string, openHouseAttendeeId: string};\nexport const deleteApiAppointmentsIdOpenHouseAttendeesOpenHouseAttendeeIdFn = async ({id, openHouseAttendeeId}: DeleteApiAppointmentsIdOpenHouseAttendeesOpenHouseAttendeeIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/appointments/${id}/openHouseAttendees/${openHouseAttendeeId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'DELETE',\n          \n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return deleteApiAppointmentsIdOpenHouseAttendeesOpenHouseAttendeeIdResponse.parse(data)\n    };\nexport const useDeleteApiAppointmentsIdOpenHouseAttendeesOpenHouseAttendeeId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: deleteApiAppointmentsIdOpenHouseAttendeesOpenHouseAttendeeIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Appointments']})\n        }\n      })\n    };",
  "src/sections/Appointments/services/usePatchApiAppointmentsIdOpenHouseAttendeesOpenHouseAttendeeId.generated.ts": "import { UpdateOpenHouseAttendeeModel } from '@/schemas/updateOpenHouseAttendeeModel.generated.tsx'\nimport { patchApiAppointmentsIdOpenHouseAttendeesOpenHouseAttendeeIdResponse } from '@/sections/Appointments/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type PatchApiAppointmentsIdOpenHouseAttendeesOpenHouseAttendeeIdFnArgs = {'If-Match'?: string, id: string, openHouseAttendeeId: string, body: UpdateOpenHouseAttendeeModel};\nexport const patchApiAppointmentsIdOpenHouseAttendeesOpenHouseAttendeeIdFn = async ({'If-Match': ifMatch, id, openHouseAttendeeId, body}: PatchApiAppointmentsIdOpenHouseAttendeesOpenHouseAttendeeIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({'If-Match': ifMatch})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/appointments/${id}/openHouseAttendees/${openHouseAttendeeId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PATCH',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return patchApiAppointmentsIdOpenHouseAttendeesOpenHouseAttendeeIdResponse.parse(data)\n    };\nexport const usePatchApiAppointmentsIdOpenHouseAttendeesOpenHouseAttendeeId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: patchApiAppointmentsIdOpenHouseAttendeesOpenHouseAttendeeIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Appointments']})\n        }\n      })\n    };",
  "src/schemas/updateOpenHouseAttendeeModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateOpenHouseAttendeeModel = /** Request body used to upda te a new open house attendee */\n{interestLevel?: (/** The interest level of the open house attendee (veryInterested/mightBeInterested/notInterested/notSet) */\nstring) | null | undefined, notes?: (/** Notes on this open house attendee */\nstring) | null | undefined};\nexport const updateOpenHouseAttendeeModel = /** Request body used to upda te a new open house attendee */\nz.object({interestLevel: /** The interest level of the open house attendee (veryInterested/mightBeInterested/notInterested/notSet) */\nz.string().optional().nullable(), notes: /** Notes on this open house attendee */\nz.string().optional().nullable()});",
  "src/sections/Companies/services/useGetApiCompaniesId.generated.ts": "import { getApiCompaniesIdResponse } from '@/sections/Companies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiCompaniesIdFnArgs = {id: string, embed?: (Array<'companyTypes' | 'relationships'>) | null | undefined};\nexport const getApiCompaniesIdFn = async ({id, embed}: GetApiCompaniesIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/companies/${id}${querySerialiser({args:{embed}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiCompaniesIdResponse.parse(data)\n    };\nexport const useGetApiCompaniesId = ({id, embed}: GetApiCompaniesIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Companies', id, embed],\n        queryFn: () => getApiCompaniesIdFn({id, embed})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Companies/services/usePatchApiCompaniesId.generated.ts": "import { UpdateCompanyModel } from '@/schemas/updateCompanyModel.generated.tsx'\nimport { patchApiCompaniesIdResponse } from '@/sections/Companies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type PatchApiCompaniesIdFnArgs = {'If-Match'?: string, id: string, body: UpdateCompanyModel};\nexport const patchApiCompaniesIdFn = async ({'If-Match': ifMatch, id, body}: PatchApiCompaniesIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({'If-Match': ifMatch})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/companies/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PATCH',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return patchApiCompaniesIdResponse.parse(data)\n    };\nexport const usePatchApiCompaniesId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: patchApiCompaniesIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Companies']})\n        }\n      })\n    };",
  "src/schemas/updateCompanyModel.generated.tsx": "import { UpdateCompanyAddressModel, updateCompanyAddressModel } from '@/schemas/updateCompanyAddressModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type UpdateCompanyModel = /** Request body used to update an existing company */\n{name?: (/** The name of the company */\nstring) | null | undefined, branch?: (/** The branch name of the company */\nstring) | null | undefined, notes?: (/** A free text field containing notes that describe the company's business or service offering */\nstring) | null | undefined, active?: (/** A flag determining whether or not the company is currently active */\nboolean) | null | undefined, marketingConsent?: (/** The marketing consent status of the company (deny/notAsked) */\nstring) | null | undefined, vatRegistered?: (/** A flag determining whether or not the company is VAT registered */\nboolean) | null | undefined, typeIds?: (/** A collection of unique identifiers of company types that categorise the type of business the company operates */\nArray<string>) | null | undefined, supplierTypeId?: (/** The unique identifier of a supplier type, if the company is a supplier */\nstring) | null | undefined, workPhone?: (/** The work phone number of the company */\nstring) | null | undefined, mobilePhone?: (/** The mobile phone number of the company */\nstring) | null | undefined, email?: (/** The email address of the company */\nstring) | null | undefined, address?: (UpdateCompanyAddressModel) | null | undefined, communicationPreferenceLetter?: (/** A flag determining whether or not the company is happy to receive communications by letter */\nboolean) | null | undefined, communicationPreferenceEmail?: (/** A flag determining whether or not the company is happy to receive communications by email */\nboolean) | null | undefined, communicationPreferencePhone?: (/** A flag determining whether or not the company is happy to receive communications by phone */\nboolean) | null | undefined, communicationPreferenceSms?: (/** A flag determining whether or not the company is happy to receive communications by SMS */\nboolean) | null | undefined, metadata?: (/** App specific metadata to set against the company */\nRecord<string, Record<string, never>>) | null | undefined};\nexport const updateCompanyModel = /** Request body used to update an existing company */\nz.object({name: /** The name of the company */\nz.string().optional().nullable(), branch: /** The branch name of the company */\nz.string().optional().nullable(), notes: /** A free text field containing notes that describe the company's business or service offering */\nz.string().optional().nullable(), active: /** A flag determining whether or not the company is currently active */\nz.boolean().optional().nullable(), marketingConsent: /** The marketing consent status of the company (deny/notAsked) */\nz.string().optional().nullable(), vatRegistered: /** A flag determining whether or not the company is VAT registered */\nz.boolean().optional().nullable(), typeIds: /** A collection of unique identifiers of company types that categorise the type of business the company operates */\nz.array(z.string().min(1)).optional().nullable(), supplierTypeId: /** The unique identifier of a supplier type, if the company is a supplier */\nz.string().optional().nullable(), workPhone: /** The work phone number of the company */\nz.string().optional().nullable(), mobilePhone: /** The mobile phone number of the company */\nz.string().optional().nullable(), email: /** The email address of the company */\nz.string().optional().nullable(), address: updateCompanyAddressModel.optional().nullable(), communicationPreferenceLetter: /** A flag determining whether or not the company is happy to receive communications by letter */\nz.boolean().optional().nullable(), communicationPreferenceEmail: /** A flag determining whether or not the company is happy to receive communications by email */\nz.boolean().optional().nullable(), communicationPreferencePhone: /** A flag determining whether or not the company is happy to receive communications by phone */\nz.boolean().optional().nullable(), communicationPreferenceSms: /** A flag determining whether or not the company is happy to receive communications by SMS */\nz.boolean().optional().nullable(), metadata: /** App specific metadata to set against the company */\nz.record(z.string(), z.object({})).optional().nullable()});",
  "src/schemas/updateCompanyAddressModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateCompanyAddressModel = /** Request body to set the address of an existing company */\n{type?: (/** The type of address (primary/secondary/home/work/forwarding/company/previous) */\nstring) | null | undefined, buildingName?: (/** The building name */\nstring) | null | undefined, buildingNumber?: (/** The building number */\nstring) | null | undefined, line1?: (/** The first line of the address */\nstring) | null | undefined, line2?: (/** The second line of the address */\nstring) | null | undefined, line3?: (/** The third line of the address */\nstring) | null | undefined, line4?: (/** The fourth line of the address */\nstring) | null | undefined, postcode?: (/** The postcode */\nstring) | null | undefined, countryId?: (/** The ISO-3166 country code that the address resides within */\nstring) | null | undefined};\nexport const updateCompanyAddressModel = /** Request body to set the address of an existing company */\nz.object({type: /** The type of address (primary/secondary/home/work/forwarding/company/previous) */\nz.string().optional().nullable(), buildingName: /** The building name */\nz.string().optional().nullable(), buildingNumber: /** The building number */\nz.string().optional().nullable(), line1: /** The first line of the address */\nz.string().optional().nullable(), line2: /** The second line of the address */\nz.string().optional().nullable(), line3: /** The third line of the address */\nz.string().optional().nullable(), line4: /** The fourth line of the address */\nz.string().optional().nullable(), postcode: /** The postcode */\nz.string().optional().nullable(), countryId: /** The ISO-3166 country code that the address resides within */\nz.string().optional().nullable()});",
  "src/sections/Companies/services/useGetApiCompaniesIdStaffMembers.generated.ts": "import { getApiCompaniesIdStaffMembersResponse } from '@/sections/Companies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiCompaniesIdStaffMembersFnArgs = {id: string};\nexport const getApiCompaniesIdStaffMembersFn = async ({id}: GetApiCompaniesIdStaffMembersFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/companies/${id}/staffMembers${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiCompaniesIdStaffMembersResponse.parse(data)\n    };\nexport const useGetApiCompaniesIdStaffMembers = ({id}: GetApiCompaniesIdStaffMembersFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Companies', id],\n        queryFn: () => getApiCompaniesIdStaffMembersFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/schemas/staffModelPagedResult.generated.tsx": "import { z } from 'zod'\nimport { staffModel, StaffModel } from '@/schemas/staffModel.generated.tsx'\nimport { pagingLinkModel, PagingLinkModel } from '@/schemas/pagingLinkModel.generated.tsx'\n\nexport const staffModelPagedResult = z.object({_embedded: z.array(staffModel).optional().nullable(), pageNumber: z.number().int().optional().nullable(), pageSize: z.number().int().optional().nullable(), pageCount: z.number().int().optional().nullable(), totalPageCount: z.number().int().optional().nullable(), totalCount: z.number().int().optional().nullable(), _links: z.record(z.string(), pagingLinkModel).optional().nullable()});\nexport type StaffModelPagedResult = {_embedded?: (Array<StaffModel>) | null | undefined, pageNumber?: (number) | null | undefined, pageSize?: (number) | null | undefined, pageCount?: (number) | null | undefined, totalPageCount?: (number) | null | undefined, totalCount?: (number) | null | undefined, _links?: (Record<string, PagingLinkModel>) | null | undefined};",
  "src/schemas/staffModel.generated.tsx": "import { z } from 'zod'\n\nexport const staffModel = /** Representation of a staff member */\nz.object({name: /** The staff member's name */\nz.string().optional().nullable(), active: /** A flag determining whether or not the staff member is currently active */\nz.boolean().optional().nullable(), jobTitle: /** The staff member's job title */\nz.string().optional().nullable(), workPhone: /** The staff member's work phone */\nz.string().optional().nullable(), mobilePhone: /** The staff member's mobile phone */\nz.string().optional().nullable(), email: /** The staff member's email */\nz.string().optional().nullable(), salutation: /** The staff member's preferred salutation */\nz.string().optional().nullable()});\nexport type StaffModel = /** Representation of a staff member */\n{name?: (/** The staff member's name */\nstring) | null | undefined, active?: (/** A flag determining whether or not the staff member is currently active */\nboolean) | null | undefined, jobTitle?: (/** The staff member's job title */\nstring) | null | undefined, workPhone?: (/** The staff member's work phone */\nstring) | null | undefined, mobilePhone?: (/** The staff member's mobile phone */\nstring) | null | undefined, email?: (/** The staff member's email */\nstring) | null | undefined, salutation?: (/** The staff member's preferred salutation */\nstring) | null | undefined};",
  "src/sections/Configuration/services/useGetApiConfigurationTypes.generated.ts": "import { getApiConfigurationTypesResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationTypesFnArgs = {type?: (Array<'agencyTypes' | 'appointmentTypes' | 'applicantStatuses' | 'boardStatuses' | 'buyingPositions' | 'buyingReasons' | 'certificateTypes' | 'companyTypes' | 'contactCategories' | 'identityDocumentTypes' | 'documentTypes' | 'journalEntryTypes' | 'keyTypes' | 'followUpResponses' | 'sellingReasons' | 'rentInsuranceCancellationReasons' | 'rentingPositions' | 'supplierTypes' | 'taskTypes' | 'tenancyLegalStatuses' | 'tenancyTypes' | 'vendorTypes' | 'worksOrderTypes'>) | null | undefined};\nexport const getApiConfigurationTypesFn = async ({type}: GetApiConfigurationTypesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/types${querySerialiser({args:{type}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationTypesResponse.parse(data)\n    };\nexport const useGetApiConfigurationTypes = ({type}: GetApiConfigurationTypesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', type],\n        queryFn: () => getApiConfigurationTypesFn({type})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/apiTypes.generated.ts": "import { typeModel } from '@/schemas/typeModel.generated.tsx'\nimport { z } from 'zod'\nimport { listItemModel } from '@/schemas/listItemModel.generated.tsx'\nimport { certificateTypeModel } from '@/schemas/certificateTypeModel.generated.tsx'\nimport { listItemDetailModel } from '@/schemas/listItemDetailModel.generated.tsx'\nimport { terminologyModel } from '@/schemas/terminologyModel.generated.tsx'\n\nexport const getApiConfigurationTypesResponse = typeModel;\nexport const getApiConfigurationAgencyTypesResponse = z.array(listItemModel);\nexport const getApiConfigurationAgencyTypesIdResponse = listItemModel;\nexport const getApiConfigurationApplicantStatusesIdResponse = listItemModel;\nexport const getApiConfigurationApplicantStatusesResponse = z.array(listItemModel);\nexport const getApiConfigurationAppointmentTypesResponse = z.array(listItemModel);\nexport const getApiConfigurationAppointmentTypesIdResponse = listItemModel;\nexport const getApiConfigurationBoardStatusesResponse = z.array(listItemModel);\nexport const getApiConfigurationBoardStatusesIdResponse = listItemModel;\nexport const getApiConfigurationBuyingPositionsResponse = z.array(listItemModel);\nexport const getApiConfigurationBuyingPositionsIdResponse = listItemModel;\nexport const getApiConfigurationBuyingReasonsResponse = z.array(listItemModel);\nexport const getApiConfigurationCertificateTypesResponse = z.array(certificateTypeModel);\nexport const getApiConfigurationCertificateTypesIdResponse = certificateTypeModel;\nexport const getApiConfigurationCompanyTypesResponse = z.array(listItemModel);\nexport const getApiConfigurationCompanyTypesIdResponse = listItemModel;\nexport const getApiConfigurationContactCategoriesIdResponse = listItemModel;\nexport const getApiConfigurationContactCategoriesResponse = z.array(listItemModel);\nexport const getApiConfigurationDocumentTypesResponse = z.array(listItemModel);\nexport const getApiConfigurationDocumentTypesIdResponse = listItemModel;\nexport const getApiConfigurationFollowUpResponsesResponse = z.array(listItemModel);\nexport const getApiConfigurationFollowUpResponsesIdResponse = listItemModel;\nexport const getApiConfigurationIdentityDocumentTypesResponse = z.array(listItemModel);\nexport const getApiConfigurationIdentityDocumentTypesIdResponse = listItemModel;\nexport const getApiConfigurationJournalEntryTypesResponse = z.array(listItemModel);\nexport const getApiConfigurationJournalEntryTypesIdResponse = listItemModel;\nexport const getApiConfigurationKeyTypesResponse = z.array(listItemModel);\nexport const getApiConfigurationKeyTypesIdResponse = listItemModel;\nexport const getApiConfigurationPortalTypesResponse = z.array(listItemModel);\nexport const getApiConfigurationPortalTypesIdResponse = listItemModel;\nexport const getApiConfigurationPreTenancyCheckTypesResponse = z.array(listItemDetailModel);\nexport const getApiConfigurationPreTenancyCheckTypesIdResponse = listItemDetailModel;\nexport const getApiConfigurationPropertyServiceTypesResponse = z.array(listItemModel);\nexport const getApiConfigurationPropertyServiceTypesIdResponse = listItemModel;\nexport const getApiConfigurationRenewalCheckTypesResponse = z.array(listItemDetailModel);\nexport const getApiConfigurationRenewalCheckTypesIdResponse = listItemDetailModel;\nexport const getApiConfigurationRentInsuranceCancellationReasonsResponse = z.array(listItemModel);\nexport const getApiConfigurationRentInsuranceCancellationReasonsIdResponse = listItemModel;\nexport const getApiConfigurationRentingPositionsResponse = z.array(listItemModel);\nexport const getApiConfigurationRentingPositionsIdResponse = listItemModel;\nexport const getApiConfigurationRuralTenancyTypesResponse = z.array(listItemModel);\nexport const getApiConfigurationRuralTenancyTypesIdResponse = listItemModel;\nexport const getApiConfigurationSellingReasonsResponse = z.array(listItemModel);\nexport const getApiConfigurationSellingReasonsIdResponse = listItemModel;\nexport const getApiConfigurationSupplierTypesResponse = z.array(listItemModel);\nexport const getApiConfigurationSupplierTypesIdResponse = listItemModel;\nexport const getApiConfigurationTaskTypesResponse = z.array(listItemModel);\nexport const getApiConfigurationTaskTypesIdResponse = listItemModel;\nexport const getApiConfigurationTenancyLegalStatusesResponse = z.array(listItemModel);\nexport const getApiConfigurationTenancyLegalStatusesIdResponse = listItemModel;\nexport const getApiConfigurationTenancyRenewalOptionsResponse = z.array(listItemModel);\nexport const getApiConfigurationTenancyRenewalOptionsIdResponse = listItemModel;\nexport const getApiConfigurationTenancyRenewalOptionConditionsResponse = z.array(listItemModel);\nexport const getApiConfigurationTenancyRenewalOptionConditionsIdResponse = listItemModel;\nexport const getApiConfigurationTenancyTypesResponse = z.array(listItemModel);\nexport const getApiConfigurationTenancyTypesIdResponse = listItemModel;\nexport const getApiConfigurationVendorTypesResponse = z.array(listItemModel);\nexport const getApiConfigurationVendorTypesIdResponse = listItemModel;\nexport const getApiConfigurationWorksOrderTypesResponse = z.array(listItemModel);\nexport const getApiConfigurationWorksOrderTypesIdResponse = listItemModel;\nexport const getApiConfigurationTerminologyResponse = terminologyModel;",
  "src/schemas/typeModel.generated.tsx": "import { z } from 'zod'\nimport { listItemModel, ListItemModel } from '@/schemas/listItemModel.generated.tsx'\n\nexport const typeModel = /** Representation of all of the available configurable items */\nz.object({agencyTypes: /** A list of configurable agency types */\nz.array(listItemModel).optional().nullable(), appointmentTypes: /** A list of configurable appointment types */\nz.array(listItemModel).optional().nullable(), applicantStatuses: /** A list of configurable applicant statuses */\nz.array(listItemModel).optional().nullable(), boardStatuses: /** A list of configurable board statuses */\nz.array(listItemModel).optional().nullable(), buyingPositions: /** A list of configurable buying positions */\nz.array(listItemModel).optional().nullable(), buyingReasons: /** A list of configurable buying reasons */\nz.array(listItemModel).optional().nullable(), certificateTypes: /** A list of configurable certificate types */\nz.array(listItemModel).optional().nullable(), companyTypes: /** A list of configurable company types */\nz.array(listItemModel).optional().nullable(), contactCategories: /** A list of configurable contact categories */\nz.array(listItemModel).optional().nullable(), documentTypes: /** A list of configurable document types */\nz.array(listItemModel).optional().nullable(), identityDocumentTypes: /** A list of configurable identity document types */\nz.array(listItemModel).optional().nullable(), journalEntryTypes: /** A list of configurable journal entry types */\nz.array(listItemModel).optional().nullable(), keyTypes: /** A list of configurable key types */\nz.array(listItemModel).optional().nullable(), followUpResponses: /** A list of configurable follow up responses */\nz.array(listItemModel).optional().nullable(), sellingReasons: /** A list of configurable selling reasons */\nz.array(listItemModel).optional().nullable(), rentInsuranceCancellationReasons: /** A list of configurable rent insurance cancellation reasons */\nz.array(listItemModel).optional().nullable(), rentingPositions: /** A list of configurable renting positions */\nz.array(listItemModel).optional().nullable(), supplierTypes: /** A list of configurable supplier types */\nz.array(listItemModel).optional().nullable(), taskTypes: /** A list of configurable task types */\nz.array(listItemModel).optional().nullable(), tenancyLegalStatuses: /** A list of configurable tenancy legal status */\nz.array(listItemModel).optional().nullable(), tenancyTypes: /** A list of configurable tenancy types */\nz.array(listItemModel).optional().nullable(), vendorTypes: /** A list of configurable vendor types */\nz.array(listItemModel).optional().nullable(), worksOrderTypes: /** A list of configurable works order types */\nz.array(listItemModel).optional().nullable()});\nexport type TypeModel = /** Representation of all of the available configurable items */\n{agencyTypes?: (/** A list of configurable agency types */\nArray<ListItemModel>) | null | undefined, appointmentTypes?: (/** A list of configurable appointment types */\nArray<ListItemModel>) | null | undefined, applicantStatuses?: (/** A list of configurable applicant statuses */\nArray<ListItemModel>) | null | undefined, boardStatuses?: (/** A list of configurable board statuses */\nArray<ListItemModel>) | null | undefined, buyingPositions?: (/** A list of configurable buying positions */\nArray<ListItemModel>) | null | undefined, buyingReasons?: (/** A list of configurable buying reasons */\nArray<ListItemModel>) | null | undefined, certificateTypes?: (/** A list of configurable certificate types */\nArray<ListItemModel>) | null | undefined, companyTypes?: (/** A list of configurable company types */\nArray<ListItemModel>) | null | undefined, contactCategories?: (/** A list of configurable contact categories */\nArray<ListItemModel>) | null | undefined, documentTypes?: (/** A list of configurable document types */\nArray<ListItemModel>) | null | undefined, identityDocumentTypes?: (/** A list of configurable identity document types */\nArray<ListItemModel>) | null | undefined, journalEntryTypes?: (/** A list of configurable journal entry types */\nArray<ListItemModel>) | null | undefined, keyTypes?: (/** A list of configurable key types */\nArray<ListItemModel>) | null | undefined, followUpResponses?: (/** A list of configurable follow up responses */\nArray<ListItemModel>) | null | undefined, sellingReasons?: (/** A list of configurable selling reasons */\nArray<ListItemModel>) | null | undefined, rentInsuranceCancellationReasons?: (/** A list of configurable rent insurance cancellation reasons */\nArray<ListItemModel>) | null | undefined, rentingPositions?: (/** A list of configurable renting positions */\nArray<ListItemModel>) | null | undefined, supplierTypes?: (/** A list of configurable supplier types */\nArray<ListItemModel>) | null | undefined, taskTypes?: (/** A list of configurable task types */\nArray<ListItemModel>) | null | undefined, tenancyLegalStatuses?: (/** A list of configurable tenancy legal status */\nArray<ListItemModel>) | null | undefined, tenancyTypes?: (/** A list of configurable tenancy types */\nArray<ListItemModel>) | null | undefined, vendorTypes?: (/** A list of configurable vendor types */\nArray<ListItemModel>) | null | undefined, worksOrderTypes?: (/** A list of configurable works order types */\nArray<ListItemModel>) | null | undefined};",
  "src/schemas/listItemModel.generated.tsx": "import { z } from 'zod'\n\nexport const listItemModel = /** Representation of a configuration item */\nz.object({id: /** The unique identifier of the list item */\nz.string().optional().nullable(), value: /** The textual value for the list item */\nz.string().optional().nullable()});\nexport type ListItemModel = /** Representation of a configuration item */\n{id?: (/** The unique identifier of the list item */\nstring) | null | undefined, value?: (/** The textual value for the list item */\nstring) | null | undefined};",
  "src/sections/Configuration/services/useGetApiConfigurationAgencyTypes.generated.ts": "import { getApiConfigurationAgencyTypesResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationAgencyTypesFnArgs = Record<string, never>;\nexport const getApiConfigurationAgencyTypesFn = async ({}: GetApiConfigurationAgencyTypesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/agencyTypes${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationAgencyTypesResponse.parse(data)\n    };\nexport const useGetApiConfigurationAgencyTypes = ({}: GetApiConfigurationAgencyTypesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration'],\n        queryFn: () => getApiConfigurationAgencyTypesFn({})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationAgencyTypesId.generated.ts": "import { getApiConfigurationAgencyTypesIdResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationAgencyTypesIdFnArgs = {id: string};\nexport const getApiConfigurationAgencyTypesIdFn = async ({id}: GetApiConfigurationAgencyTypesIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/agencyTypes/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationAgencyTypesIdResponse.parse(data)\n    };\nexport const useGetApiConfigurationAgencyTypesId = ({id}: GetApiConfigurationAgencyTypesIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', id],\n        queryFn: () => getApiConfigurationAgencyTypesIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationApplicantStatusesId.generated.ts": "import { getApiConfigurationApplicantStatusesIdResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationApplicantStatusesIdFnArgs = {id: string};\nexport const getApiConfigurationApplicantStatusesIdFn = async ({id}: GetApiConfigurationApplicantStatusesIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/applicantStatuses/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationApplicantStatusesIdResponse.parse(data)\n    };\nexport const useGetApiConfigurationApplicantStatusesId = ({id}: GetApiConfigurationApplicantStatusesIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', id],\n        queryFn: () => getApiConfigurationApplicantStatusesIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationApplicantStatuses.generated.ts": "import { getApiConfigurationApplicantStatusesResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationApplicantStatusesFnArgs = {id?: (Array<string>) | null | undefined};\nexport const getApiConfigurationApplicantStatusesFn = async ({id}: GetApiConfigurationApplicantStatusesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/applicantStatuses${querySerialiser({args:{id}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationApplicantStatusesResponse.parse(data)\n    };\nexport const useGetApiConfigurationApplicantStatuses = ({id}: GetApiConfigurationApplicantStatusesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', id],\n        queryFn: () => getApiConfigurationApplicantStatusesFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationAppointmentTypes.generated.ts": "import { getApiConfigurationAppointmentTypesResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationAppointmentTypesFnArgs = Record<string, never>;\nexport const getApiConfigurationAppointmentTypesFn = async ({}: GetApiConfigurationAppointmentTypesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/appointmentTypes${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationAppointmentTypesResponse.parse(data)\n    };\nexport const useGetApiConfigurationAppointmentTypes = ({}: GetApiConfigurationAppointmentTypesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration'],\n        queryFn: () => getApiConfigurationAppointmentTypesFn({})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationAppointmentTypesId.generated.ts": "import { getApiConfigurationAppointmentTypesIdResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationAppointmentTypesIdFnArgs = {id: string};\nexport const getApiConfigurationAppointmentTypesIdFn = async ({id}: GetApiConfigurationAppointmentTypesIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/appointmentTypes/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationAppointmentTypesIdResponse.parse(data)\n    };\nexport const useGetApiConfigurationAppointmentTypesId = ({id}: GetApiConfigurationAppointmentTypesIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', id],\n        queryFn: () => getApiConfigurationAppointmentTypesIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationBoardStatuses.generated.ts": "import { getApiConfigurationBoardStatusesResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationBoardStatusesFnArgs = Record<string, never>;\nexport const getApiConfigurationBoardStatusesFn = async ({}: GetApiConfigurationBoardStatusesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/boardStatuses${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationBoardStatusesResponse.parse(data)\n    };\nexport const useGetApiConfigurationBoardStatuses = ({}: GetApiConfigurationBoardStatusesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration'],\n        queryFn: () => getApiConfigurationBoardStatusesFn({})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationBoardStatusesId.generated.ts": "import { getApiConfigurationBoardStatusesIdResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationBoardStatusesIdFnArgs = {id: string};\nexport const getApiConfigurationBoardStatusesIdFn = async ({id}: GetApiConfigurationBoardStatusesIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/boardStatuses/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationBoardStatusesIdResponse.parse(data)\n    };\nexport const useGetApiConfigurationBoardStatusesId = ({id}: GetApiConfigurationBoardStatusesIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', id],\n        queryFn: () => getApiConfigurationBoardStatusesIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationBuyingPositions.generated.ts": "import { getApiConfigurationBuyingPositionsResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationBuyingPositionsFnArgs = Record<string, never>;\nexport const getApiConfigurationBuyingPositionsFn = async ({}: GetApiConfigurationBuyingPositionsFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/buyingPositions${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationBuyingPositionsResponse.parse(data)\n    };\nexport const useGetApiConfigurationBuyingPositions = ({}: GetApiConfigurationBuyingPositionsFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration'],\n        queryFn: () => getApiConfigurationBuyingPositionsFn({})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationBuyingPositionsId.generated.ts": "import { getApiConfigurationBuyingPositionsIdResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationBuyingPositionsIdFnArgs = {id: string};\nexport const getApiConfigurationBuyingPositionsIdFn = async ({id}: GetApiConfigurationBuyingPositionsIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/buyingPositions/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationBuyingPositionsIdResponse.parse(data)\n    };\nexport const useGetApiConfigurationBuyingPositionsId = ({id}: GetApiConfigurationBuyingPositionsIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', id],\n        queryFn: () => getApiConfigurationBuyingPositionsIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationBuyingReasons.generated.ts": "import { getApiConfigurationBuyingReasonsResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationBuyingReasonsFnArgs = Record<string, never>;\nexport const getApiConfigurationBuyingReasonsFn = async ({}: GetApiConfigurationBuyingReasonsFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/buyingReasons${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationBuyingReasonsResponse.parse(data)\n    };\nexport const useGetApiConfigurationBuyingReasons = ({}: GetApiConfigurationBuyingReasonsFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration'],\n        queryFn: () => getApiConfigurationBuyingReasonsFn({})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationCertificateTypes.generated.ts": "import { getApiConfigurationCertificateTypesResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationCertificateTypesFnArgs = Record<string, never>;\nexport const getApiConfigurationCertificateTypesFn = async ({}: GetApiConfigurationCertificateTypesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/certificateTypes${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationCertificateTypesResponse.parse(data)\n    };\nexport const useGetApiConfigurationCertificateTypes = ({}: GetApiConfigurationCertificateTypesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration'],\n        queryFn: () => getApiConfigurationCertificateTypesFn({})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/schemas/certificateTypeModel.generated.tsx": "import { z } from 'zod'\nimport { listItemModel, ListItemModel } from '@/schemas/listItemModel.generated.tsx'\n\nexport const certificateTypeModel = /** Representation of a certificate type */\nz.object({id: /** The unique identifier of the list item */\nz.string().optional().nullable(), value: /** The textual value for the list item */\nz.string().optional().nullable(), statuses: /** The configurable statuses associated to the certificate type */\nz.array(listItemModel).optional().nullable()});\nexport type CertificateTypeModel = /** Representation of a certificate type */\n{id?: (/** The unique identifier of the list item */\nstring) | null | undefined, value?: (/** The textual value for the list item */\nstring) | null | undefined, statuses?: (/** The configurable statuses associated to the certificate type */\nArray<ListItemModel>) | null | undefined};",
  "src/sections/Configuration/services/useGetApiConfigurationCertificateTypesId.generated.ts": "import { getApiConfigurationCertificateTypesIdResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationCertificateTypesIdFnArgs = {id: string};\nexport const getApiConfigurationCertificateTypesIdFn = async ({id}: GetApiConfigurationCertificateTypesIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/certificateTypes/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationCertificateTypesIdResponse.parse(data)\n    };\nexport const useGetApiConfigurationCertificateTypesId = ({id}: GetApiConfigurationCertificateTypesIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', id],\n        queryFn: () => getApiConfigurationCertificateTypesIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationCompanyTypes.generated.ts": "import { getApiConfigurationCompanyTypesResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationCompanyTypesFnArgs = {id?: (Array<string>) | null | undefined};\nexport const getApiConfigurationCompanyTypesFn = async ({id}: GetApiConfigurationCompanyTypesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/companyTypes${querySerialiser({args:{id}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationCompanyTypesResponse.parse(data)\n    };\nexport const useGetApiConfigurationCompanyTypes = ({id}: GetApiConfigurationCompanyTypesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', id],\n        queryFn: () => getApiConfigurationCompanyTypesFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationCompanyTypesId.generated.ts": "import { getApiConfigurationCompanyTypesIdResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationCompanyTypesIdFnArgs = {id: string};\nexport const getApiConfigurationCompanyTypesIdFn = async ({id}: GetApiConfigurationCompanyTypesIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/companyTypes/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationCompanyTypesIdResponse.parse(data)\n    };\nexport const useGetApiConfigurationCompanyTypesId = ({id}: GetApiConfigurationCompanyTypesIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', id],\n        queryFn: () => getApiConfigurationCompanyTypesIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationContactCategoriesId.generated.ts": "import { getApiConfigurationContactCategoriesIdResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationContactCategoriesIdFnArgs = {id: string};\nexport const getApiConfigurationContactCategoriesIdFn = async ({id}: GetApiConfigurationContactCategoriesIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/contactCategories/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationContactCategoriesIdResponse.parse(data)\n    };\nexport const useGetApiConfigurationContactCategoriesId = ({id}: GetApiConfigurationContactCategoriesIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', id],\n        queryFn: () => getApiConfigurationContactCategoriesIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationContactCategories.generated.ts": "import { getApiConfigurationContactCategoriesResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationContactCategoriesFnArgs = {id?: (Array<string>) | null | undefined};\nexport const getApiConfigurationContactCategoriesFn = async ({id}: GetApiConfigurationContactCategoriesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/contactCategories${querySerialiser({args:{id}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationContactCategoriesResponse.parse(data)\n    };\nexport const useGetApiConfigurationContactCategories = ({id}: GetApiConfigurationContactCategoriesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', id],\n        queryFn: () => getApiConfigurationContactCategoriesFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationDocumentTypes.generated.ts": "import { getApiConfigurationDocumentTypesResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationDocumentTypesFnArgs = Record<string, never>;\nexport const getApiConfigurationDocumentTypesFn = async ({}: GetApiConfigurationDocumentTypesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/documentTypes${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationDocumentTypesResponse.parse(data)\n    };\nexport const useGetApiConfigurationDocumentTypes = ({}: GetApiConfigurationDocumentTypesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration'],\n        queryFn: () => getApiConfigurationDocumentTypesFn({})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationDocumentTypesId.generated.ts": "import { getApiConfigurationDocumentTypesIdResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationDocumentTypesIdFnArgs = {id: string};\nexport const getApiConfigurationDocumentTypesIdFn = async ({id}: GetApiConfigurationDocumentTypesIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/documentTypes/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationDocumentTypesIdResponse.parse(data)\n    };\nexport const useGetApiConfigurationDocumentTypesId = ({id}: GetApiConfigurationDocumentTypesIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', id],\n        queryFn: () => getApiConfigurationDocumentTypesIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationFollowUpResponses.generated.ts": "import { getApiConfigurationFollowUpResponsesResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationFollowUpResponsesFnArgs = Record<string, never>;\nexport const getApiConfigurationFollowUpResponsesFn = async ({}: GetApiConfigurationFollowUpResponsesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/followUpResponses${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationFollowUpResponsesResponse.parse(data)\n    };\nexport const useGetApiConfigurationFollowUpResponses = ({}: GetApiConfigurationFollowUpResponsesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration'],\n        queryFn: () => getApiConfigurationFollowUpResponsesFn({})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationFollowUpResponsesId.generated.ts": "import { getApiConfigurationFollowUpResponsesIdResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationFollowUpResponsesIdFnArgs = {id: string};\nexport const getApiConfigurationFollowUpResponsesIdFn = async ({id}: GetApiConfigurationFollowUpResponsesIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/followUpResponses/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationFollowUpResponsesIdResponse.parse(data)\n    };\nexport const useGetApiConfigurationFollowUpResponsesId = ({id}: GetApiConfigurationFollowUpResponsesIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', id],\n        queryFn: () => getApiConfigurationFollowUpResponsesIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationIdentityDocumentTypes.generated.ts": "import { getApiConfigurationIdentityDocumentTypesResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationIdentityDocumentTypesFnArgs = Record<string, never>;\nexport const getApiConfigurationIdentityDocumentTypesFn = async ({}: GetApiConfigurationIdentityDocumentTypesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/identityDocumentTypes${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationIdentityDocumentTypesResponse.parse(data)\n    };\nexport const useGetApiConfigurationIdentityDocumentTypes = ({}: GetApiConfigurationIdentityDocumentTypesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration'],\n        queryFn: () => getApiConfigurationIdentityDocumentTypesFn({})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationIdentityDocumentTypesId.generated.ts": "import { getApiConfigurationIdentityDocumentTypesIdResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationIdentityDocumentTypesIdFnArgs = {id: string};\nexport const getApiConfigurationIdentityDocumentTypesIdFn = async ({id}: GetApiConfigurationIdentityDocumentTypesIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/identityDocumentTypes/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationIdentityDocumentTypesIdResponse.parse(data)\n    };\nexport const useGetApiConfigurationIdentityDocumentTypesId = ({id}: GetApiConfigurationIdentityDocumentTypesIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', id],\n        queryFn: () => getApiConfigurationIdentityDocumentTypesIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationJournalEntryTypes.generated.ts": "import { getApiConfigurationJournalEntryTypesResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationJournalEntryTypesFnArgs = Record<string, never>;\nexport const getApiConfigurationJournalEntryTypesFn = async ({}: GetApiConfigurationJournalEntryTypesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/journalEntryTypes${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationJournalEntryTypesResponse.parse(data)\n    };\nexport const useGetApiConfigurationJournalEntryTypes = ({}: GetApiConfigurationJournalEntryTypesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration'],\n        queryFn: () => getApiConfigurationJournalEntryTypesFn({})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationJournalEntryTypesId.generated.ts": "import { getApiConfigurationJournalEntryTypesIdResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationJournalEntryTypesIdFnArgs = {id: string};\nexport const getApiConfigurationJournalEntryTypesIdFn = async ({id}: GetApiConfigurationJournalEntryTypesIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/journalEntryTypes/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationJournalEntryTypesIdResponse.parse(data)\n    };\nexport const useGetApiConfigurationJournalEntryTypesId = ({id}: GetApiConfigurationJournalEntryTypesIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', id],\n        queryFn: () => getApiConfigurationJournalEntryTypesIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationKeyTypes.generated.ts": "import { getApiConfigurationKeyTypesResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationKeyTypesFnArgs = Record<string, never>;\nexport const getApiConfigurationKeyTypesFn = async ({}: GetApiConfigurationKeyTypesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/keyTypes${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationKeyTypesResponse.parse(data)\n    };\nexport const useGetApiConfigurationKeyTypes = ({}: GetApiConfigurationKeyTypesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration'],\n        queryFn: () => getApiConfigurationKeyTypesFn({})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationKeyTypesId.generated.ts": "import { getApiConfigurationKeyTypesIdResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationKeyTypesIdFnArgs = {id: string};\nexport const getApiConfigurationKeyTypesIdFn = async ({id}: GetApiConfigurationKeyTypesIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/keyTypes/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationKeyTypesIdResponse.parse(data)\n    };\nexport const useGetApiConfigurationKeyTypesId = ({id}: GetApiConfigurationKeyTypesIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', id],\n        queryFn: () => getApiConfigurationKeyTypesIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationPortalTypes.generated.ts": "import { getApiConfigurationPortalTypesResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationPortalTypesFnArgs = {id?: (Array<string>) | null | undefined};\nexport const getApiConfigurationPortalTypesFn = async ({id}: GetApiConfigurationPortalTypesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/portalTypes${querySerialiser({args:{id}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationPortalTypesResponse.parse(data)\n    };\nexport const useGetApiConfigurationPortalTypes = ({id}: GetApiConfigurationPortalTypesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', id],\n        queryFn: () => getApiConfigurationPortalTypesFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationPortalTypesId.generated.ts": "import { getApiConfigurationPortalTypesIdResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationPortalTypesIdFnArgs = {id: string};\nexport const getApiConfigurationPortalTypesIdFn = async ({id}: GetApiConfigurationPortalTypesIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/portalTypes/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationPortalTypesIdResponse.parse(data)\n    };\nexport const useGetApiConfigurationPortalTypesId = ({id}: GetApiConfigurationPortalTypesIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', id],\n        queryFn: () => getApiConfigurationPortalTypesIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationPreTenancyCheckTypes.generated.ts": "import { getApiConfigurationPreTenancyCheckTypesResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationPreTenancyCheckTypesFnArgs = {active?: (boolean) | null | undefined, officeId?: (Array<string>) | null | undefined};\nexport const getApiConfigurationPreTenancyCheckTypesFn = async ({active, officeId}: GetApiConfigurationPreTenancyCheckTypesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/preTenancyCheckTypes${querySerialiser({args:{active, officeId}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationPreTenancyCheckTypesResponse.parse(data)\n    };\nexport const useGetApiConfigurationPreTenancyCheckTypes = ({active, officeId}: GetApiConfigurationPreTenancyCheckTypesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', active, officeId],\n        queryFn: () => getApiConfigurationPreTenancyCheckTypesFn({active, officeId})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/schemas/listItemDetailModel.generated.tsx": "import { z } from 'zod'\n\nexport const listItemDetailModel = /** Representation of detail properties configuration item\r\nconfiguration */\nz.object({id: /** The unique identifier of the list item */\nz.string().optional().nullable(), value: /** The textual value for the list item */\nz.string().optional().nullable(), active: /** A flag determining the status */\nz.boolean().optional().nullable(), officeIds: /** A collection of unique identifiers of offices associated */\nz.array(z.string().min(1)).optional().nullable()});\nexport type ListItemDetailModel = /** Representation of detail properties configuration item\r\nconfiguration */\n{id?: (/** The unique identifier of the list item */\nstring) | null | undefined, value?: (/** The textual value for the list item */\nstring) | null | undefined, active?: (/** A flag determining the status */\nboolean) | null | undefined, officeIds?: (/** A collection of unique identifiers of offices associated */\nArray<string>) | null | undefined};",
  "src/sections/Configuration/services/useGetApiConfigurationPreTenancyCheckTypesId.generated.ts": "import { getApiConfigurationPreTenancyCheckTypesIdResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationPreTenancyCheckTypesIdFnArgs = {id: string};\nexport const getApiConfigurationPreTenancyCheckTypesIdFn = async ({id}: GetApiConfigurationPreTenancyCheckTypesIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/preTenancyCheckTypes/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationPreTenancyCheckTypesIdResponse.parse(data)\n    };\nexport const useGetApiConfigurationPreTenancyCheckTypesId = ({id}: GetApiConfigurationPreTenancyCheckTypesIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', id],\n        queryFn: () => getApiConfigurationPreTenancyCheckTypesIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationPropertyServiceTypes.generated.ts": "import { getApiConfigurationPropertyServiceTypesResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationPropertyServiceTypesFnArgs = Record<string, never>;\nexport const getApiConfigurationPropertyServiceTypesFn = async ({}: GetApiConfigurationPropertyServiceTypesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/propertyServiceTypes${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationPropertyServiceTypesResponse.parse(data)\n    };\nexport const useGetApiConfigurationPropertyServiceTypes = ({}: GetApiConfigurationPropertyServiceTypesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration'],\n        queryFn: () => getApiConfigurationPropertyServiceTypesFn({})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationPropertyServiceTypesId.generated.ts": "import { getApiConfigurationPropertyServiceTypesIdResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationPropertyServiceTypesIdFnArgs = {id: string};\nexport const getApiConfigurationPropertyServiceTypesIdFn = async ({id}: GetApiConfigurationPropertyServiceTypesIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/propertyServiceTypes/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationPropertyServiceTypesIdResponse.parse(data)\n    };\nexport const useGetApiConfigurationPropertyServiceTypesId = ({id}: GetApiConfigurationPropertyServiceTypesIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', id],\n        queryFn: () => getApiConfigurationPropertyServiceTypesIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationRenewalCheckTypes.generated.ts": "import { getApiConfigurationRenewalCheckTypesResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationRenewalCheckTypesFnArgs = {active?: (boolean) | null | undefined, officeId?: (Array<string>) | null | undefined};\nexport const getApiConfigurationRenewalCheckTypesFn = async ({active, officeId}: GetApiConfigurationRenewalCheckTypesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/renewalCheckTypes${querySerialiser({args:{active, officeId}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationRenewalCheckTypesResponse.parse(data)\n    };\nexport const useGetApiConfigurationRenewalCheckTypes = ({active, officeId}: GetApiConfigurationRenewalCheckTypesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', active, officeId],\n        queryFn: () => getApiConfigurationRenewalCheckTypesFn({active, officeId})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationRenewalCheckTypesId.generated.ts": "import { getApiConfigurationRenewalCheckTypesIdResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationRenewalCheckTypesIdFnArgs = {id: string};\nexport const getApiConfigurationRenewalCheckTypesIdFn = async ({id}: GetApiConfigurationRenewalCheckTypesIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/renewalCheckTypes/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationRenewalCheckTypesIdResponse.parse(data)\n    };\nexport const useGetApiConfigurationRenewalCheckTypesId = ({id}: GetApiConfigurationRenewalCheckTypesIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', id],\n        queryFn: () => getApiConfigurationRenewalCheckTypesIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationRentInsuranceCancellationReasons.generated.ts": "import { getApiConfigurationRentInsuranceCancellationReasonsResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationRentInsuranceCancellationReasonsFnArgs = Record<string, never>;\nexport const getApiConfigurationRentInsuranceCancellationReasonsFn = async ({}: GetApiConfigurationRentInsuranceCancellationReasonsFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/rentInsuranceCancellationReasons${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationRentInsuranceCancellationReasonsResponse.parse(data)\n    };\nexport const useGetApiConfigurationRentInsuranceCancellationReasons = ({}: GetApiConfigurationRentInsuranceCancellationReasonsFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration'],\n        queryFn: () => getApiConfigurationRentInsuranceCancellationReasonsFn({})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationRentInsuranceCancellationReasonsId.generated.ts": "import { getApiConfigurationRentInsuranceCancellationReasonsIdResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationRentInsuranceCancellationReasonsIdFnArgs = {id: string};\nexport const getApiConfigurationRentInsuranceCancellationReasonsIdFn = async ({id}: GetApiConfigurationRentInsuranceCancellationReasonsIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/rentInsuranceCancellationReasons/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationRentInsuranceCancellationReasonsIdResponse.parse(data)\n    };\nexport const useGetApiConfigurationRentInsuranceCancellationReasonsId = ({id}: GetApiConfigurationRentInsuranceCancellationReasonsIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', id],\n        queryFn: () => getApiConfigurationRentInsuranceCancellationReasonsIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationRentingPositions.generated.ts": "import { getApiConfigurationRentingPositionsResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationRentingPositionsFnArgs = Record<string, never>;\nexport const getApiConfigurationRentingPositionsFn = async ({}: GetApiConfigurationRentingPositionsFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/rentingPositions${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationRentingPositionsResponse.parse(data)\n    };\nexport const useGetApiConfigurationRentingPositions = ({}: GetApiConfigurationRentingPositionsFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration'],\n        queryFn: () => getApiConfigurationRentingPositionsFn({})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationRentingPositionsId.generated.ts": "import { getApiConfigurationRentingPositionsIdResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationRentingPositionsIdFnArgs = {id: string};\nexport const getApiConfigurationRentingPositionsIdFn = async ({id}: GetApiConfigurationRentingPositionsIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/rentingPositions/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationRentingPositionsIdResponse.parse(data)\n    };\nexport const useGetApiConfigurationRentingPositionsId = ({id}: GetApiConfigurationRentingPositionsIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', id],\n        queryFn: () => getApiConfigurationRentingPositionsIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationRuralTenancyTypes.generated.ts": "import { getApiConfigurationRuralTenancyTypesResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationRuralTenancyTypesFnArgs = Record<string, never>;\nexport const getApiConfigurationRuralTenancyTypesFn = async ({}: GetApiConfigurationRuralTenancyTypesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/ruralTenancyTypes${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationRuralTenancyTypesResponse.parse(data)\n    };\nexport const useGetApiConfigurationRuralTenancyTypes = ({}: GetApiConfigurationRuralTenancyTypesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration'],\n        queryFn: () => getApiConfigurationRuralTenancyTypesFn({})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationRuralTenancyTypesId.generated.ts": "import { getApiConfigurationRuralTenancyTypesIdResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationRuralTenancyTypesIdFnArgs = {id: string};\nexport const getApiConfigurationRuralTenancyTypesIdFn = async ({id}: GetApiConfigurationRuralTenancyTypesIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/ruralTenancyTypes/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationRuralTenancyTypesIdResponse.parse(data)\n    };\nexport const useGetApiConfigurationRuralTenancyTypesId = ({id}: GetApiConfigurationRuralTenancyTypesIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', id],\n        queryFn: () => getApiConfigurationRuralTenancyTypesIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationSellingReasons.generated.ts": "import { getApiConfigurationSellingReasonsResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationSellingReasonsFnArgs = Record<string, never>;\nexport const getApiConfigurationSellingReasonsFn = async ({}: GetApiConfigurationSellingReasonsFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/sellingReasons${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationSellingReasonsResponse.parse(data)\n    };\nexport const useGetApiConfigurationSellingReasons = ({}: GetApiConfigurationSellingReasonsFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration'],\n        queryFn: () => getApiConfigurationSellingReasonsFn({})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationSellingReasonsId.generated.ts": "import { getApiConfigurationSellingReasonsIdResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationSellingReasonsIdFnArgs = {id: string};\nexport const getApiConfigurationSellingReasonsIdFn = async ({id}: GetApiConfigurationSellingReasonsIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/sellingReasons/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationSellingReasonsIdResponse.parse(data)\n    };\nexport const useGetApiConfigurationSellingReasonsId = ({id}: GetApiConfigurationSellingReasonsIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', id],\n        queryFn: () => getApiConfigurationSellingReasonsIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationSupplierTypes.generated.ts": "import { getApiConfigurationSupplierTypesResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationSupplierTypesFnArgs = Record<string, never>;\nexport const getApiConfigurationSupplierTypesFn = async ({}: GetApiConfigurationSupplierTypesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/supplierTypes${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationSupplierTypesResponse.parse(data)\n    };\nexport const useGetApiConfigurationSupplierTypes = ({}: GetApiConfigurationSupplierTypesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration'],\n        queryFn: () => getApiConfigurationSupplierTypesFn({})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationSupplierTypesId.generated.ts": "import { getApiConfigurationSupplierTypesIdResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationSupplierTypesIdFnArgs = {id: string};\nexport const getApiConfigurationSupplierTypesIdFn = async ({id}: GetApiConfigurationSupplierTypesIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/supplierTypes/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationSupplierTypesIdResponse.parse(data)\n    };\nexport const useGetApiConfigurationSupplierTypesId = ({id}: GetApiConfigurationSupplierTypesIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', id],\n        queryFn: () => getApiConfigurationSupplierTypesIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationTaskTypes.generated.ts": "import { getApiConfigurationTaskTypesResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationTaskTypesFnArgs = Record<string, never>;\nexport const getApiConfigurationTaskTypesFn = async ({}: GetApiConfigurationTaskTypesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/taskTypes${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationTaskTypesResponse.parse(data)\n    };\nexport const useGetApiConfigurationTaskTypes = ({}: GetApiConfigurationTaskTypesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration'],\n        queryFn: () => getApiConfigurationTaskTypesFn({})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationTaskTypesId.generated.ts": "import { getApiConfigurationTaskTypesIdResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationTaskTypesIdFnArgs = {id: string};\nexport const getApiConfigurationTaskTypesIdFn = async ({id}: GetApiConfigurationTaskTypesIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/taskTypes/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationTaskTypesIdResponse.parse(data)\n    };\nexport const useGetApiConfigurationTaskTypesId = ({id}: GetApiConfigurationTaskTypesIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', id],\n        queryFn: () => getApiConfigurationTaskTypesIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationTenancyLegalStatuses.generated.ts": "import { getApiConfigurationTenancyLegalStatusesResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationTenancyLegalStatusesFnArgs = Record<string, never>;\nexport const getApiConfigurationTenancyLegalStatusesFn = async ({}: GetApiConfigurationTenancyLegalStatusesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/tenancyLegalStatuses${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationTenancyLegalStatusesResponse.parse(data)\n    };\nexport const useGetApiConfigurationTenancyLegalStatuses = ({}: GetApiConfigurationTenancyLegalStatusesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration'],\n        queryFn: () => getApiConfigurationTenancyLegalStatusesFn({})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationTenancyLegalStatusesId.generated.ts": "import { getApiConfigurationTenancyLegalStatusesIdResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationTenancyLegalStatusesIdFnArgs = {id: string};\nexport const getApiConfigurationTenancyLegalStatusesIdFn = async ({id}: GetApiConfigurationTenancyLegalStatusesIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/tenancyLegalStatuses/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationTenancyLegalStatusesIdResponse.parse(data)\n    };\nexport const useGetApiConfigurationTenancyLegalStatusesId = ({id}: GetApiConfigurationTenancyLegalStatusesIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', id],\n        queryFn: () => getApiConfigurationTenancyLegalStatusesIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationTenancyRenewalOptions.generated.ts": "import { getApiConfigurationTenancyRenewalOptionsResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationTenancyRenewalOptionsFnArgs = {id?: (Array<string>) | null | undefined};\nexport const getApiConfigurationTenancyRenewalOptionsFn = async ({id}: GetApiConfigurationTenancyRenewalOptionsFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/tenancyRenewalOptions${querySerialiser({args:{id}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationTenancyRenewalOptionsResponse.parse(data)\n    };\nexport const useGetApiConfigurationTenancyRenewalOptions = ({id}: GetApiConfigurationTenancyRenewalOptionsFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', id],\n        queryFn: () => getApiConfigurationTenancyRenewalOptionsFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationTenancyRenewalOptionsId.generated.ts": "import { getApiConfigurationTenancyRenewalOptionsIdResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationTenancyRenewalOptionsIdFnArgs = {id: string};\nexport const getApiConfigurationTenancyRenewalOptionsIdFn = async ({id}: GetApiConfigurationTenancyRenewalOptionsIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/tenancyRenewalOptions/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationTenancyRenewalOptionsIdResponse.parse(data)\n    };\nexport const useGetApiConfigurationTenancyRenewalOptionsId = ({id}: GetApiConfigurationTenancyRenewalOptionsIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', id],\n        queryFn: () => getApiConfigurationTenancyRenewalOptionsIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationTenancyRenewalOptionConditions.generated.ts": "import { getApiConfigurationTenancyRenewalOptionConditionsResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationTenancyRenewalOptionConditionsFnArgs = {id?: (Array<string>) | null | undefined};\nexport const getApiConfigurationTenancyRenewalOptionConditionsFn = async ({id}: GetApiConfigurationTenancyRenewalOptionConditionsFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/tenancyRenewalOptionConditions${querySerialiser({args:{id}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationTenancyRenewalOptionConditionsResponse.parse(data)\n    };\nexport const useGetApiConfigurationTenancyRenewalOptionConditions = ({id}: GetApiConfigurationTenancyRenewalOptionConditionsFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', id],\n        queryFn: () => getApiConfigurationTenancyRenewalOptionConditionsFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationTenancyRenewalOptionConditionsId.generated.ts": "import { getApiConfigurationTenancyRenewalOptionConditionsIdResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationTenancyRenewalOptionConditionsIdFnArgs = {id: string};\nexport const getApiConfigurationTenancyRenewalOptionConditionsIdFn = async ({id}: GetApiConfigurationTenancyRenewalOptionConditionsIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/tenancyRenewalOptionConditions/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationTenancyRenewalOptionConditionsIdResponse.parse(data)\n    };\nexport const useGetApiConfigurationTenancyRenewalOptionConditionsId = ({id}: GetApiConfigurationTenancyRenewalOptionConditionsIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', id],\n        queryFn: () => getApiConfigurationTenancyRenewalOptionConditionsIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationTenancyTypes.generated.ts": "import { getApiConfigurationTenancyTypesResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationTenancyTypesFnArgs = Record<string, never>;\nexport const getApiConfigurationTenancyTypesFn = async ({}: GetApiConfigurationTenancyTypesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/tenancyTypes${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationTenancyTypesResponse.parse(data)\n    };\nexport const useGetApiConfigurationTenancyTypes = ({}: GetApiConfigurationTenancyTypesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration'],\n        queryFn: () => getApiConfigurationTenancyTypesFn({})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationTenancyTypesId.generated.ts": "import { getApiConfigurationTenancyTypesIdResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationTenancyTypesIdFnArgs = {id: string};\nexport const getApiConfigurationTenancyTypesIdFn = async ({id}: GetApiConfigurationTenancyTypesIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/tenancyTypes/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationTenancyTypesIdResponse.parse(data)\n    };\nexport const useGetApiConfigurationTenancyTypesId = ({id}: GetApiConfigurationTenancyTypesIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', id],\n        queryFn: () => getApiConfigurationTenancyTypesIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationVendorTypes.generated.ts": "import { getApiConfigurationVendorTypesResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationVendorTypesFnArgs = Record<string, never>;\nexport const getApiConfigurationVendorTypesFn = async ({}: GetApiConfigurationVendorTypesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/vendorTypes${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationVendorTypesResponse.parse(data)\n    };\nexport const useGetApiConfigurationVendorTypes = ({}: GetApiConfigurationVendorTypesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration'],\n        queryFn: () => getApiConfigurationVendorTypesFn({})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationVendorTypesId.generated.ts": "import { getApiConfigurationVendorTypesIdResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationVendorTypesIdFnArgs = {id: string};\nexport const getApiConfigurationVendorTypesIdFn = async ({id}: GetApiConfigurationVendorTypesIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/vendorTypes/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationVendorTypesIdResponse.parse(data)\n    };\nexport const useGetApiConfigurationVendorTypesId = ({id}: GetApiConfigurationVendorTypesIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', id],\n        queryFn: () => getApiConfigurationVendorTypesIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationWorksOrderTypes.generated.ts": "import { getApiConfigurationWorksOrderTypesResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationWorksOrderTypesFnArgs = Record<string, never>;\nexport const getApiConfigurationWorksOrderTypesFn = async ({}: GetApiConfigurationWorksOrderTypesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/worksOrderTypes${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationWorksOrderTypesResponse.parse(data)\n    };\nexport const useGetApiConfigurationWorksOrderTypes = ({}: GetApiConfigurationWorksOrderTypesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration'],\n        queryFn: () => getApiConfigurationWorksOrderTypesFn({})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationWorksOrderTypesId.generated.ts": "import { getApiConfigurationWorksOrderTypesIdResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationWorksOrderTypesIdFnArgs = {id: string};\nexport const getApiConfigurationWorksOrderTypesIdFn = async ({id}: GetApiConfigurationWorksOrderTypesIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/worksOrderTypes/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationWorksOrderTypesIdResponse.parse(data)\n    };\nexport const useGetApiConfigurationWorksOrderTypesId = ({id}: GetApiConfigurationWorksOrderTypesIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration', id],\n        queryFn: () => getApiConfigurationWorksOrderTypesIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Configuration/services/useGetApiConfigurationTerminology.generated.ts": "import { getApiConfigurationTerminologyResponse } from '@/sections/Configuration/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConfigurationTerminologyFnArgs = Record<string, never>;\nexport const getApiConfigurationTerminologyFn = async ({}: GetApiConfigurationTerminologyFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/configuration/terminology${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConfigurationTerminologyResponse.parse(data)\n    };\nexport const useGetApiConfigurationTerminology = ({}: GetApiConfigurationTerminologyFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Configuration'],\n        queryFn: () => getApiConfigurationTerminologyFn({})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/schemas/terminologyModel.generated.tsx": "import { z } from 'zod'\nimport { propertyTerminologyModel, PropertyTerminologyModel } from '@/schemas/propertyTerminologyModel.generated.tsx'\n\nexport const terminologyModel = /** Representation of the configuration settings for terminology */\nz.object({properties: propertyTerminologyModel.optional().nullable()});\nexport type TerminologyModel = /** Representation of the configuration settings for terminology */\n{properties?: (PropertyTerminologyModel) | null | undefined};",
  "src/schemas/propertyTerminologyModel.generated.tsx": "import { z } from 'zod'\n\nexport const propertyTerminologyModel = /** Terminologies associated with the properties */\nz.object({useSoldStc: /** A flag denoting whether the agent's CRM is configured to use \"Sold STC/SSTC\" terminology instead of \"Under Offer\" */\nz.boolean().optional().nullable(), useMarketAppraisal: /** A flag denoting whether the agent's CRM is configured to use \"Market Appraisal\" terminology instead of \"Valuation\" */\nz.boolean().optional().nullable()});\nexport type PropertyTerminologyModel = /** Terminologies associated with the properties */\n{useSoldStc?: (/** A flag denoting whether the agent's CRM is configured to use \"Sold STC/SSTC\" terminology instead of \"Under Offer\" */\nboolean) | null | undefined, useMarketAppraisal?: (/** A flag denoting whether the agent's CRM is configured to use \"Market Appraisal\" terminology instead of \"Valuation\" */\nboolean) | null | undefined};",
  "src/sections/Contacts/services/useGetApiContactsId.generated.ts": "import { getApiContactsIdResponse } from '@/sections/Contacts/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiContactsIdFnArgs = {id: string, embed?: (Array<'documents' | 'identityChecks' | 'negotiators' | 'offices' | 'relationships' | 'source'>) | null | undefined, extrasField?: (Array<string>) | null | undefined};\nexport const getApiContactsIdFn = async ({id, embed, extrasField}: GetApiContactsIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/contacts/${id}${querySerialiser({args:{embed, extrasField}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiContactsIdResponse.parse(data)\n    };\nexport const useGetApiContactsId = ({id, embed, extrasField}: GetApiContactsIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Contacts', id, embed, extrasField],\n        queryFn: () => getApiContactsIdFn({id, embed, extrasField})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Contacts/services/usePatchApiContactsId.generated.ts": "import { UpdateContactModel } from '@/schemas/updateContactModel.generated.tsx'\nimport { patchApiContactsIdResponse } from '@/sections/Contacts/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type PatchApiContactsIdFnArgs = {'If-Match'?: string, id: string, body: UpdateContactModel};\nexport const patchApiContactsIdFn = async ({'If-Match': ifMatch, id, body}: PatchApiContactsIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({'If-Match': ifMatch})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/contacts/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PATCH',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return patchApiContactsIdResponse.parse(data)\n    };\nexport const usePatchApiContactsId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: patchApiContactsIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Contacts']})\n        }\n      })\n    };",
  "src/schemas/updateContactModel.generated.tsx": "import { UpdateContactSourceModel, updateContactSourceModel } from '@/schemas/updateContactSourceModel.generated.tsx'\nimport { UpdateContactAddressModel, updateContactAddressModel } from '@/schemas/updateContactAddressModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type UpdateContactModel = /** Request body used to update an existing contact */\n{title?: (/** The contact's title  (eg. Mr, Mrs, Miss, Dr) */\nstring) | null | undefined, forename?: (/** The contact's forename */\nstring) | null | undefined, surname?: (/** The contact's surname */\nstring) | null | undefined, dateOfBirth?: (/** The contact's date of birth */\nstring) | null | undefined, active?: (/** A flag determining whether or not the contact is currently active */\nboolean) | null | undefined, marketingConsent?: (/** The marketing consent status of the contact (grant/deny/notAsked) */\nstring) | null | undefined, source?: (UpdateContactSourceModel) | null | undefined, homePhone?: (/** The home phone number of the contact */\nstring) | null | undefined, workPhone?: (/** The work phone number of the contact */\nstring) | null | undefined, mobilePhone?: (/** The mobile phone number of the contact */\nstring) | null | undefined, email?: (/** The email address of the contact */\nstring) | null | undefined, officeIds?: (/** A collection of unique identifiers of offices attached to the contact. The first item in the collection is considered the primary office */\nArray<string>) | null | undefined, negotiatorIds?: (/** A collection of unique identifiers of negotiators attached to the contact. The first item in the collection is considered the primary negotiator */\nArray<string>) | null | undefined, categoryIds?: (/** A collection of categories associated to the contact. */\nArray<string>) | null | undefined, primaryAddress?: (UpdateContactAddressModel) | null | undefined, secondaryAddress?: (UpdateContactAddressModel) | null | undefined, workAddress?: (UpdateContactAddressModel) | null | undefined, communicationPreferenceLetter?: (/** A flag determining whether or not the contact is happy to receive communications by letter */\nboolean) | null | undefined, communicationPreferenceEmail?: (/** A flag determining whether or not the contact is happy to receive communications by email */\nboolean) | null | undefined, communicationPreferencePhone?: (/** A flag determining whether or not the contact is happy to receive communications by phone */\nboolean) | null | undefined, communicationPreferenceSMS?: (/** A flag determining whether or not the contact is happy to receive communications by SMS */\nboolean) | null | undefined, fromArchive?: (/** A flag determining whether the contact is archived */\nboolean) | null | undefined, metadata?: (/** App specific metadata to set against the contact */\nRecord<string, Record<string, never>>) | null | undefined, additionalContactDetails?: (/** A collection of additional contact details */\nRecord<string, string>) | null | undefined};\nexport const updateContactModel = /** Request body used to update an existing contact */\nz.object({title: /** The contact's title  (eg. Mr, Mrs, Miss, Dr) */\nz.string().optional().nullable(), forename: /** The contact's forename */\nz.string().optional().nullable(), surname: /** The contact's surname */\nz.string().optional().nullable(), dateOfBirth: /** The contact's date of birth */\nz.string().optional().nullable(), active: /** A flag determining whether or not the contact is currently active */\nz.boolean().optional().nullable(), marketingConsent: /** The marketing consent status of the contact (grant/deny/notAsked) */\nz.string().optional().nullable(), source: updateContactSourceModel.optional().nullable(), homePhone: /** The home phone number of the contact */\nz.string().optional().nullable(), workPhone: /** The work phone number of the contact */\nz.string().optional().nullable(), mobilePhone: /** The mobile phone number of the contact */\nz.string().optional().nullable(), email: /** The email address of the contact */\nz.string().optional().nullable(), officeIds: /** A collection of unique identifiers of offices attached to the contact. The first item in the collection is considered the primary office */\nz.array(z.string().min(1)).optional().nullable(), negotiatorIds: /** A collection of unique identifiers of negotiators attached to the contact. The first item in the collection is considered the primary negotiator */\nz.array(z.string().min(1)).optional().nullable(), categoryIds: /** A collection of categories associated to the contact. */\nz.array(z.string().min(1)).optional().nullable(), primaryAddress: updateContactAddressModel.optional().nullable(), secondaryAddress: updateContactAddressModel.optional().nullable(), workAddress: updateContactAddressModel.optional().nullable(), communicationPreferenceLetter: /** A flag determining whether or not the contact is happy to receive communications by letter */\nz.boolean().optional().nullable(), communicationPreferenceEmail: /** A flag determining whether or not the contact is happy to receive communications by email */\nz.boolean().optional().nullable(), communicationPreferencePhone: /** A flag determining whether or not the contact is happy to receive communications by phone */\nz.boolean().optional().nullable(), communicationPreferenceSMS: /** A flag determining whether or not the contact is happy to receive communications by SMS */\nz.boolean().optional().nullable(), fromArchive: /** A flag determining whether the contact is archived */\nz.boolean().optional().nullable(), metadata: /** App specific metadata to set against the contact */\nz.record(z.string(), z.object({})).optional().nullable(), additionalContactDetails: /** A collection of additional contact details */\nz.record(z.string(), z.string().min(1)).optional().nullable()});",
  "src/schemas/updateContactSourceModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateContactSourceModel = /** Request body used to update the source of an existing contact */\n{id?: (/** The unique identifier of the source of the contact */\nstring) | null | undefined, type?: (/** The source type (office/source) */\nstring) | null | undefined};\nexport const updateContactSourceModel = /** Request body used to update the source of an existing contact */\nz.object({id: /** The unique identifier of the source of the contact */\nz.string().optional().nullable(), type: /** The source type (office/source) */\nz.string().optional().nullable()});",
  "src/schemas/updateContactAddressModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateContactAddressModel = /** Request body used to update an address on an existing contact */\n{type?: (/** The type of address (primary/secondary/home/work/forwarding/company/previous) */\nstring) | null | undefined, buildingName?: (/** The building name */\nstring) | null | undefined, buildingNumber?: (/** The building number */\nstring) | null | undefined, line1?: (/** The first line of the address */\nstring) | null | undefined, line2?: (/** The second line of the address */\nstring) | null | undefined, line3?: (/** The third line of the address */\nstring) | null | undefined, line4?: (/** The fourth line of the address */\nstring) | null | undefined, postcode?: (/** The postcode */\nstring) | null | undefined, countryId?: (/** The ISO-3166 country code that the adderess resides in */\nstring) | null | undefined};\nexport const updateContactAddressModel = /** Request body used to update an address on an existing contact */\nz.object({type: /** The type of address (primary/secondary/home/work/forwarding/company/previous) */\nz.string().optional().nullable(), buildingName: /** The building name */\nz.string().optional().nullable(), buildingNumber: /** The building number */\nz.string().optional().nullable(), line1: /** The first line of the address */\nz.string().optional().nullable(), line2: /** The second line of the address */\nz.string().optional().nullable(), line3: /** The third line of the address */\nz.string().optional().nullable(), line4: /** The fourth line of the address */\nz.string().optional().nullable(), postcode: /** The postcode */\nz.string().optional().nullable(), countryId: /** The ISO-3166 country code that the adderess resides in */\nz.string().optional().nullable()});",
  "src/sections/Contacts/services/useGetApiContactsIdSubscriptionsSubscriptionId.generated.ts": "import { getApiContactsIdSubscriptionsSubscriptionIdResponse } from '@/sections/Contacts/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiContactsIdSubscriptionsSubscriptionIdFnArgs = {id: string, subscriptionId: string};\nexport const getApiContactsIdSubscriptionsSubscriptionIdFn = async ({id, subscriptionId}: GetApiContactsIdSubscriptionsSubscriptionIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/contacts/${id}/subscriptions/${subscriptionId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiContactsIdSubscriptionsSubscriptionIdResponse.parse(data)\n    };\nexport const useGetApiContactsIdSubscriptionsSubscriptionId = ({id, subscriptionId}: GetApiContactsIdSubscriptionsSubscriptionIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Contacts', id, subscriptionId],\n        queryFn: () => getApiContactsIdSubscriptionsSubscriptionIdFn({id, subscriptionId})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Contacts/services/useUpdateApiContactsIdSubscriptionsSubscriptionId.generated.ts": "import { UpdateContactSubscriptionModel } from '@/schemas/updateContactSubscriptionModel.generated.tsx'\nimport { updateApiContactsIdSubscriptionsSubscriptionIdResponse } from '@/sections/Contacts/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type UpdateApiContactsIdSubscriptionsSubscriptionIdFnArgs = {id: string, subscriptionId: string, body: UpdateContactSubscriptionModel};\nexport const updateApiContactsIdSubscriptionsSubscriptionIdFn = async ({id, subscriptionId, body}: UpdateApiContactsIdSubscriptionsSubscriptionIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/contacts/${id}/subscriptions/${subscriptionId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PUT',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return updateApiContactsIdSubscriptionsSubscriptionIdResponse.parse(data)\n    };\nexport const useUpdateApiContactsIdSubscriptionsSubscriptionId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: updateApiContactsIdSubscriptionsSubscriptionIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Contacts']})\n        }\n      })\n    };",
  "src/schemas/updateContactSubscriptionModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateContactSubscriptionModel = /** Request body used to update an existing contact subscription */\n{status?: (/** The status of the subscription (subscribed/unsubscribed) */\nstring) | null | undefined};\nexport const updateContactSubscriptionModel = /** Request body used to update an existing contact subscription */\nz.object({status: /** The status of the subscription (subscribed/unsubscribed) */\nz.string().optional().nullable()});",
  "src/sections/Conveyancing/services/useGetApiConveyancingId.generated.ts": "import { getApiConveyancingIdResponse } from '@/sections/Conveyancing/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiConveyancingIdFnArgs = {id: string, embed?: (Array<'buyerSolicitor' | 'offer' | 'property' | 'vendor' | 'vendorSolicitor'>) | null | undefined};\nexport const getApiConveyancingIdFn = async ({id, embed}: GetApiConveyancingIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/conveyancing/${id}${querySerialiser({args:{embed}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiConveyancingIdResponse.parse(data)\n    };\nexport const useGetApiConveyancingId = ({id, embed}: GetApiConveyancingIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Conveyancing', id, embed],\n        queryFn: () => getApiConveyancingIdFn({id, embed})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Conveyancing/services/usePatchApiConveyancingId.generated.ts": "import { UpdateConveyancingModel } from '@/schemas/updateConveyancingModel.generated.tsx'\nimport { patchApiConveyancingIdResponse } from '@/sections/Conveyancing/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type PatchApiConveyancingIdFnArgs = {'If-Match'?: string, id: string, body: UpdateConveyancingModel};\nexport const patchApiConveyancingIdFn = async ({'If-Match': ifMatch, id, body}: PatchApiConveyancingIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({'If-Match': ifMatch})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/conveyancing/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PATCH',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return patchApiConveyancingIdResponse.parse(data)\n    };\nexport const usePatchApiConveyancingId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: patchApiConveyancingIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Conveyancing']})\n        }\n      })\n    };",
  "src/schemas/updateConveyancingModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateConveyancingModel = /** Request body for updating sales progression information on an existing offer */\n{vendorSolicitorId?: (/** The unique identifier of the vendor that this offer is associated to. Empty if the offer is external and relates to a property not instructed to the agent */\nstring) | null | undefined, buyerSolicitorId?: (/** The unique identifier of the solicitor / conveyancer that the vendor has instructed */\nstring) | null | undefined, fixturesAndFittingsCompleted?: (/** The date when the fixtures and fittings form has been completed */\nstring) | null | undefined, deedsRequested?: (/** The date when the title deeds were requested from land registry */\nstring) | null | undefined, deedsReceived?: (/** The date when the title deeds were received from land registry */\nstring) | null | undefined, enquiriesSent?: (/** The date when the legal enquiries raised by the buyers solicitor were sent */\nstring) | null | undefined, enquiriesAnswered?: (/** The date when the legal enquiries raised by the buyers solicitor were answered */\nstring) | null | undefined, searchesPaid?: (/** The date when the buyer paid for conveyancing searches */\nstring) | null | undefined, searchesApplied?: (/** The date when conveyancing searches were applied for */\nstring) | null | undefined, searchesReceived?: (/** The date when conveyancing searches were received */\nstring) | null | undefined, contractSent?: (/** The date when the draft contract was sent */\nstring) | null | undefined, contractReceived?: (/** The date when the draft contract was received */\nstring) | null | undefined, contractApproved?: (/** The date when the contract was approved */\nstring) | null | undefined, contractVendorSigned?: (/** The date when the vendor signed the approved contract */\nstring) | null | undefined, contractBuyerSigned?: (/** The date when the buyer signed the approved contract */\nstring) | null | undefined, mortgageRequired?: (/** Indication of whether the buyer will require a mortgage to fund the purchase (yes/no/unknown) */\nstring) | null | undefined, mortgageLoanPercentage?: (/** The loan to value percentage of the mortgage required */\nnumber) | null | undefined, mortgageSubmitted?: (/** The date when the mortgage application was submitted */\nstring) | null | undefined, mortgageOfferReceived?: (/** The date when the mortgage offer was received */\nstring) | null | undefined, mortgageLenderId?: (/** The unique identifier of the company who will provide the mortgage */\nstring) | null | undefined, mortgageBrokerId?: (/** The unique identifier of the company who brokered the mortgage */\nstring) | null | undefined, mortgageSurveyDate?: (/** The date of the mortgage valuation/survey */\nDate) | null | undefined, mortgageSurveyorId?: (/** The unique identifier of the company who will perform the mortgage valuation/survey */\nstring) | null | undefined, additionalSurveyRequired?: (/** Indication of whether the buyer requires that an additional survey take place (yes/no/unknown) */\nstring) | null | undefined, additionalSurveyDate?: (/** The date of the additional survey */\nstring) | null | undefined, additionalSurveyorId?: (/** The unique identifier of the company who will perform the additional survey */\nstring) | null | undefined, exchangedVendor?: (/** The date when the vendor conveyancer confirms the exchange */\nstring) | null | undefined, exchangedBuyer?: (/** The date when the buyer conveyancer confirms the exchange */\nstring) | null | undefined, completion?: (/** The date when the sale completed */\nstring) | null | undefined, metadata?: (/** App specific metadata to set against this conveyancing record */\nRecord<string, Record<string, never>>) | null | undefined};\nexport const updateConveyancingModel = /** Request body for updating sales progression information on an existing offer */\nz.object({vendorSolicitorId: /** The unique identifier of the vendor that this offer is associated to. Empty if the offer is external and relates to a property not instructed to the agent */\nz.string().optional().nullable(), buyerSolicitorId: /** The unique identifier of the solicitor / conveyancer that the vendor has instructed */\nz.string().optional().nullable(), fixturesAndFittingsCompleted: /** The date when the fixtures and fittings form has been completed */\nz.string().optional().nullable(), deedsRequested: /** The date when the title deeds were requested from land registry */\nz.string().optional().nullable(), deedsReceived: /** The date when the title deeds were received from land registry */\nz.string().optional().nullable(), enquiriesSent: /** The date when the legal enquiries raised by the buyers solicitor were sent */\nz.string().optional().nullable(), enquiriesAnswered: /** The date when the legal enquiries raised by the buyers solicitor were answered */\nz.string().optional().nullable(), searchesPaid: /** The date when the buyer paid for conveyancing searches */\nz.string().optional().nullable(), searchesApplied: /** The date when conveyancing searches were applied for */\nz.string().optional().nullable(), searchesReceived: /** The date when conveyancing searches were received */\nz.string().optional().nullable(), contractSent: /** The date when the draft contract was sent */\nz.string().optional().nullable(), contractReceived: /** The date when the draft contract was received */\nz.string().optional().nullable(), contractApproved: /** The date when the contract was approved */\nz.string().optional().nullable(), contractVendorSigned: /** The date when the vendor signed the approved contract */\nz.string().optional().nullable(), contractBuyerSigned: /** The date when the buyer signed the approved contract */\nz.string().optional().nullable(), mortgageRequired: /** Indication of whether the buyer will require a mortgage to fund the purchase (yes/no/unknown) */\nz.string().optional().nullable(), mortgageLoanPercentage: /** The loan to value percentage of the mortgage required */\nz.number().int().optional().nullable(), mortgageSubmitted: /** The date when the mortgage application was submitted */\nz.string().optional().nullable(), mortgageOfferReceived: /** The date when the mortgage offer was received */\nz.string().optional().nullable(), mortgageLenderId: /** The unique identifier of the company who will provide the mortgage */\nz.string().optional().nullable(), mortgageBrokerId: /** The unique identifier of the company who brokered the mortgage */\nz.string().optional().nullable(), mortgageSurveyDate: /** The date of the mortgage valuation/survey */\nz.string().pipe( z.coerce.date() ).optional().nullable(), mortgageSurveyorId: /** The unique identifier of the company who will perform the mortgage valuation/survey */\nz.string().optional().nullable(), additionalSurveyRequired: /** Indication of whether the buyer requires that an additional survey take place (yes/no/unknown) */\nz.string().optional().nullable(), additionalSurveyDate: /** The date of the additional survey */\nz.string().optional().nullable(), additionalSurveyorId: /** The unique identifier of the company who will perform the additional survey */\nz.string().optional().nullable(), exchangedVendor: /** The date when the vendor conveyancer confirms the exchange */\nz.string().optional().nullable(), exchangedBuyer: /** The date when the buyer conveyancer confirms the exchange */\nz.string().optional().nullable(), completion: /** The date when the sale completed */\nz.string().optional().nullable(), metadata: /** App specific metadata to set against this conveyancing record */\nz.record(z.string(), z.object({})).optional().nullable()});",
  "src/sections/Conveyancing/services/useDeleteApiConveyancingIdDownward.generated.ts": "import { deleteApiConveyancingIdDownwardResponse } from '@/sections/Conveyancing/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type DeleteApiConveyancingIdDownwardFnArgs = {id: string};\nexport const deleteApiConveyancingIdDownwardFn = async ({id}: DeleteApiConveyancingIdDownwardFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/conveyancing/${id}/downward${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'DELETE',\n          \n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return deleteApiConveyancingIdDownwardResponse.parse(data)\n    };\nexport const useDeleteApiConveyancingIdDownward = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: deleteApiConveyancingIdDownwardFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Conveyancing']})\n        }\n      })\n    };",
  "src/sections/Conveyancing/services/useDeleteApiConveyancingIdUpward.generated.ts": "import { deleteApiConveyancingIdUpwardResponse } from '@/sections/Conveyancing/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type DeleteApiConveyancingIdUpwardFnArgs = {id: string};\nexport const deleteApiConveyancingIdUpwardFn = async ({id}: DeleteApiConveyancingIdUpwardFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/conveyancing/${id}/upward${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'DELETE',\n          \n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return deleteApiConveyancingIdUpwardResponse.parse(data)\n    };\nexport const useDeleteApiConveyancingIdUpward = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: deleteApiConveyancingIdUpwardFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Conveyancing']})\n        }\n      })\n    };",
  "src/sections/Departments/services/useGetApiDepartmentsId.generated.ts": "import { getApiDepartmentsIdResponse } from '@/sections/Departments/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiDepartmentsIdFnArgs = {id: string};\nexport const getApiDepartmentsIdFn = async ({id}: GetApiDepartmentsIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/departments/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiDepartmentsIdResponse.parse(data)\n    };\nexport const useGetApiDepartmentsId = ({id}: GetApiDepartmentsIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Departments', id],\n        queryFn: () => getApiDepartmentsIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Documents/services/useGetApiDocumentsId.generated.ts": "import { getApiDocumentsIdResponse } from '@/sections/Documents/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiDocumentsIdFnArgs = {id: string, embed?: (Array<'documentType'>) | null | undefined};\nexport const getApiDocumentsIdFn = async ({id, embed}: GetApiDocumentsIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/documents/${id}${querySerialiser({args:{embed}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiDocumentsIdResponse.parse(data)\n    };\nexport const useGetApiDocumentsId = ({id, embed}: GetApiDocumentsIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Documents', id, embed],\n        queryFn: () => getApiDocumentsIdFn({id, embed})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Documents/services/useDeleteApiDocumentsId.generated.ts": "import { deleteApiDocumentsIdResponse } from '@/sections/Documents/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type DeleteApiDocumentsIdFnArgs = {id: string};\nexport const deleteApiDocumentsIdFn = async ({id}: DeleteApiDocumentsIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/documents/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'DELETE',\n          \n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return deleteApiDocumentsIdResponse.parse(data)\n    };\nexport const useDeleteApiDocumentsId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: deleteApiDocumentsIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Documents']})\n        }\n      })\n    };",
  "src/sections/Documents/services/usePatchApiDocumentsId.generated.ts": "import { UpdateDocumentModel } from '@/schemas/updateDocumentModel.generated.tsx'\nimport { patchApiDocumentsIdResponse } from '@/sections/Documents/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type PatchApiDocumentsIdFnArgs = {'If-Match'?: string, id: string, body: UpdateDocumentModel};\nexport const patchApiDocumentsIdFn = async ({'If-Match': ifMatch, id, body}: PatchApiDocumentsIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({'If-Match': ifMatch})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/documents/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PATCH',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return patchApiDocumentsIdResponse.parse(data)\n    };\nexport const usePatchApiDocumentsId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: patchApiDocumentsIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Documents']})\n        }\n      })\n    };",
  "src/schemas/updateDocumentModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateDocumentModel = /** Request body used to update an existing document */\n{typeId?: (/** The unique identifier of the type of document */\nstring) | null | undefined, name?: (/** The filename of the document */\nstring) | null | undefined, isPrivate?: (/** A flag denoting whether or not the document is private */\nboolean) | null | undefined, metadata?: (/** App specific metadata to set against the document */\nRecord<string, Record<string, never>>) | null | undefined};\nexport const updateDocumentModel = /** Request body used to update an existing document */\nz.object({typeId: /** The unique identifier of the type of document */\nz.string().optional().nullable(), name: /** The filename of the document */\nz.string().optional().nullable(), isPrivate: /** A flag denoting whether or not the document is private */\nz.boolean().optional().nullable(), metadata: /** App specific metadata to set against the document */\nz.record(z.string(), z.object({})).optional().nullable()});",
  "src/sections/Documents/services/useGetApiDocumentsIdDownload.generated.ts": "import { getApiDocumentsIdDownloadResponse } from '@/sections/Documents/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiDocumentsIdDownloadFnArgs = {id: string};\nexport const getApiDocumentsIdDownloadFn = async ({id}: GetApiDocumentsIdDownloadFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/documents/${id}/download${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiDocumentsIdDownloadResponse.parse(data)\n    };\nexport const useGetApiDocumentsIdDownload = ({id}: GetApiDocumentsIdDownloadFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Documents', id],\n        queryFn: () => getApiDocumentsIdDownloadFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Enquiries/services/useGetApiEnquiriesId.generated.ts": "import { getApiEnquiriesIdResponse } from '@/sections/Enquiries/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiEnquiriesIdFnArgs = {id: number};\nexport const getApiEnquiriesIdFn = async ({id}: GetApiEnquiriesIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/enquiries/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiEnquiriesIdResponse.parse(data)\n    };\nexport const useGetApiEnquiriesId = ({id}: GetApiEnquiriesIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Enquiries', id],\n        queryFn: () => getApiEnquiriesIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Enquiries/services/usePatchApiEnquiriesId.generated.ts": "import { UpdateEnquiryModel } from '@/schemas/updateEnquiryModel.generated.tsx'\nimport { patchApiEnquiriesIdResponse } from '@/sections/Enquiries/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type PatchApiEnquiriesIdFnArgs = {'If-Match'?: string, id: number, body: UpdateEnquiryModel};\nexport const patchApiEnquiriesIdFn = async ({'If-Match': ifMatch, id, body}: PatchApiEnquiriesIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({'If-Match': ifMatch})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/enquiries/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PATCH',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return patchApiEnquiriesIdResponse.parse(data)\n    };\nexport const usePatchApiEnquiriesId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: patchApiEnquiriesIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Enquiries']})\n        }\n      })\n    };",
  "src/schemas/updateEnquiryModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateEnquiryModel = /** Request body used to update an existing enquiry */\n{applicantId?: (/** The unique identifier of the applicant associated to the enquiry */\nstring) | null | undefined, status?: (/** The status of the enquiry (added/alreadyExists/duplicateEntry/pending/rejected/spam) */\nstring) | null | undefined};\nexport const updateEnquiryModel = /** Request body used to update an existing enquiry */\nz.object({applicantId: /** The unique identifier of the applicant associated to the enquiry */\nz.string().optional().nullable(), status: /** The status of the enquiry (added/alreadyExists/duplicateEntry/pending/rejected/spam) */\nz.string().optional().nullable()});",
  "src/sections/IdentityChecks/services/useGetApiIdentityChecksId.generated.ts": "import { getApiIdentityChecksIdResponse } from '@/sections/IdentityChecks/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiIdentityChecksIdFnArgs = {id: string, embed?: (Array<'contact' | 'document1' | 'document2' | 'documentType1' | 'documentType2'>) | null | undefined};\nexport const getApiIdentityChecksIdFn = async ({id, embed}: GetApiIdentityChecksIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/identityChecks/${id}${querySerialiser({args:{embed}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiIdentityChecksIdResponse.parse(data)\n    };\nexport const useGetApiIdentityChecksId = ({id, embed}: GetApiIdentityChecksIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['IdentityChecks', id, embed],\n        queryFn: () => getApiIdentityChecksIdFn({id, embed})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/IdentityChecks/services/usePatchApiIdentityChecksId.generated.ts": "import { UpdateIdentityCheckModel } from '@/schemas/updateIdentityCheckModel.generated.tsx'\nimport { patchApiIdentityChecksIdResponse } from '@/sections/IdentityChecks/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type PatchApiIdentityChecksIdFnArgs = {'If-Match'?: string, id: string, body: UpdateIdentityCheckModel};\nexport const patchApiIdentityChecksIdFn = async ({'If-Match': ifMatch, id, body}: PatchApiIdentityChecksIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({'If-Match': ifMatch})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/identityChecks/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PATCH',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return patchApiIdentityChecksIdResponse.parse(data)\n    };\nexport const usePatchApiIdentityChecksId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: patchApiIdentityChecksIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['IdentityChecks']})\n        }\n      })\n    };",
  "src/schemas/updateIdentityCheckModel.generated.tsx": "import { UpdateIdentityDocumentModel, updateIdentityDocumentModel } from '@/schemas/updateIdentityDocumentModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type UpdateIdentityCheckModel = /** Request body used to update an exist contact identity check */\n{checkDate?: (/** The date when the identity check was performed. This may differ to the date when the check was created */\nstring) | null | undefined, status?: (/** The current status of the identity check (pass/fail/pending/cancelled/warnings/unchecked) */\nstring) | null | undefined, negotiatorId?: (/** The unique identifier of the negotiator that initiated the identity check */\nstring) | null | undefined, identityDocument1?: (UpdateIdentityDocumentModel) | null | undefined, identityDocument2?: (UpdateIdentityDocumentModel) | null | undefined, metadata?: (/** App specific metadata to set against the identity check */\nRecord<string, Record<string, never>>) | null | undefined};\nexport const updateIdentityCheckModel = /** Request body used to update an exist contact identity check */\nz.object({checkDate: /** The date when the identity check was performed. This may differ to the date when the check was created */\nz.string().optional().nullable(), status: /** The current status of the identity check (pass/fail/pending/cancelled/warnings/unchecked) */\nz.string().optional().nullable(), negotiatorId: /** The unique identifier of the negotiator that initiated the identity check */\nz.string().optional().nullable(), identityDocument1: updateIdentityDocumentModel.optional().nullable(), identityDocument2: updateIdentityDocumentModel.optional().nullable(), metadata: /** App specific metadata to set against the identity check */\nz.record(z.string(), z.object({})).optional().nullable()});",
  "src/schemas/updateIdentityDocumentModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateIdentityDocumentModel = /** Request body to update an identity document attached to an existing contact identity check */\n{typeId?: (/** The unique identifier of the type of identity document provided */\nstring) | null | undefined, expiry?: (/** The date when the document expires and becomes invalid */\nstring) | null | undefined, details?: (/** Details regarding the identity document (eg. passport number) */\nstring) | null | undefined, fileData?: (/** The base64 encoded identity document content, prefixed with the content type (eg. data:text/plain;base64,VGVzdCBmaWxl)\r\nThe total request payload cannot exceed 6Mb, regardless of the number of documents being sent */\nstring) | null | undefined, fileUrl?: (/** The presigned s3 url which a document has been uploaded to (This supports files up to 30MB) */\nstring) | null | undefined, name?: (/** The filename to store the document as */\nstring) | null | undefined};\nexport const updateIdentityDocumentModel = /** Request body to update an identity document attached to an existing contact identity check */\nz.object({typeId: /** The unique identifier of the type of identity document provided */\nz.string().optional().nullable(), expiry: /** The date when the document expires and becomes invalid */\nz.string().optional().nullable(), details: /** Details regarding the identity document (eg. passport number) */\nz.string().optional().nullable(), fileData: /** The base64 encoded identity document content, prefixed with the content type (eg. data:text/plain;base64,VGVzdCBmaWxl)\r\nThe total request payload cannot exceed 6Mb, regardless of the number of documents being sent */\nz.string().optional().nullable(), fileUrl: /** The presigned s3 url which a document has been uploaded to (This supports files up to 30MB) */\nz.string().optional().nullable(), name: /** The filename to store the document as */\nz.string().optional().nullable()});",
  "src/sections/Invoices/services/useGetApiInvoicesId.generated.ts": "import { getApiInvoicesIdResponse } from '@/sections/Invoices/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiInvoicesIdFnArgs = {id: string};\nexport const getApiInvoicesIdFn = async ({id}: GetApiInvoicesIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/invoices/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiInvoicesIdResponse.parse(data)\n    };\nexport const useGetApiInvoicesId = ({id}: GetApiInvoicesIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Invoices', id],\n        queryFn: () => getApiInvoicesIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/schemas/invoiceDetailModel.generated.tsx": "import { z } from 'zod'\nimport { chargeModel, ChargeModel } from '@/schemas/chargeModel.generated.tsx'\nimport { creditModel, CreditModel } from '@/schemas/creditModel.generated.tsx'\nimport { paymentModel, PaymentModel } from '@/schemas/paymentModel.generated.tsx'\nimport { linkModel, LinkModel } from '@/schemas/linkModel.generated.tsx'\n\nexport const invoiceDetailModel = /** Detailed representation of an individual invoice */\nz.object({id: /** Unique identifier of the invoice */\nz.string().optional().nullable(), created: /** The date and time when the invoice was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time when the invoice was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), reference: /** The invoice reference */\nz.string().optional().nullable(), negotiatorId: /** Unique identifier of the negotiator associated with the invoice */\nz.string().optional().nullable(), propertyId: /** Unique identifier of the property associated with the invoice */\nz.string().optional().nullable(), description: /** Description of the invoice */\nz.string().optional().nullable(), status: /** The status of the invoice */\nz.string().optional().nullable(), date: /** The date of the invoice */\nz.string().pipe( z.coerce.date() ).optional().nullable(), dueDate: /** The due date of the invoice */\nz.string().pipe( z.coerce.date() ).optional().nullable(), isRaised: /** Flag indicating whether the invoice has been raised */\nz.boolean().optional().nullable(), netAmount: /** The net amount due for the invoice in the system base currency */\nz.number().optional().nullable(), vatAmount: /** The amount of VAT due for the invoice in the system base currency */\nz.number().optional().nullable(), outstandingAmount: /** The value of the invoice outstanding in the system base currency */\nz.number().optional().nullable(), charges: /** Collection of charges associated with the invoice */\nz.array(chargeModel).optional().nullable(), credits: /** Collection of credits associated with the invoice */\nz.array(creditModel).optional().nullable(), payments: /** Collection of payments associated with the invoice */\nz.array(paymentModel).optional().nullable(), _links: z.record(z.string(), linkModel).optional().nullable(), _embedded: z.record(z.string(), z.object({})).optional().nullable()});\nexport type InvoiceDetailModel = /** Detailed representation of an individual invoice */\n{id?: (/** Unique identifier of the invoice */\nstring) | null | undefined, created?: (/** The date and time when the invoice was created */\nDate) | null | undefined, modified?: (/** The date and time when the invoice was last modified */\nDate) | null | undefined, reference?: (/** The invoice reference */\nstring) | null | undefined, negotiatorId?: (/** Unique identifier of the negotiator associated with the invoice */\nstring) | null | undefined, propertyId?: (/** Unique identifier of the property associated with the invoice */\nstring) | null | undefined, description?: (/** Description of the invoice */\nstring) | null | undefined, status?: (/** The status of the invoice */\nstring) | null | undefined, date?: (/** The date of the invoice */\nDate) | null | undefined, dueDate?: (/** The due date of the invoice */\nDate) | null | undefined, isRaised?: (/** Flag indicating whether the invoice has been raised */\nboolean) | null | undefined, netAmount?: (/** The net amount due for the invoice in the system base currency */\nnumber) | null | undefined, vatAmount?: (/** The amount of VAT due for the invoice in the system base currency */\nnumber) | null | undefined, outstandingAmount?: (/** The value of the invoice outstanding in the system base currency */\nnumber) | null | undefined, charges?: (/** Collection of charges associated with the invoice */\nArray<ChargeModel>) | null | undefined, credits?: (/** Collection of credits associated with the invoice */\nArray<CreditModel>) | null | undefined, payments?: (/** Collection of payments associated with the invoice */\nArray<PaymentModel>) | null | undefined, _links?: (Record<string, LinkModel>) | null | undefined, _embedded?: (Record<string, Record<string, never>>) | null | undefined};",
  "src/sections/Invoices/services/useGetApiInvoicesPaymentsId.generated.ts": "import { getApiInvoicesPaymentsIdResponse } from '@/sections/Invoices/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiInvoicesPaymentsIdFnArgs = {id: string};\nexport const getApiInvoicesPaymentsIdFn = async ({id}: GetApiInvoicesPaymentsIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/invoices/payments/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiInvoicesPaymentsIdResponse.parse(data)\n    };\nexport const useGetApiInvoicesPaymentsId = ({id}: GetApiInvoicesPaymentsIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Invoices', id],\n        queryFn: () => getApiInvoicesPaymentsIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Invoices/services/useGetApiInvoicesCreditsId.generated.ts": "import { getApiInvoicesCreditsIdResponse } from '@/sections/Invoices/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiInvoicesCreditsIdFnArgs = {id: string};\nexport const getApiInvoicesCreditsIdFn = async ({id}: GetApiInvoicesCreditsIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/invoices/credits/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiInvoicesCreditsIdResponse.parse(data)\n    };\nexport const useGetApiInvoicesCreditsId = ({id}: GetApiInvoicesCreditsIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Invoices', id],\n        queryFn: () => getApiInvoicesCreditsIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Invoices/services/useGetApiInvoicesChargesId.generated.ts": "import { getApiInvoicesChargesIdResponse } from '@/sections/Invoices/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiInvoicesChargesIdFnArgs = {id: string};\nexport const getApiInvoicesChargesIdFn = async ({id}: GetApiInvoicesChargesIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/invoices/charges/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiInvoicesChargesIdResponse.parse(data)\n    };\nexport const useGetApiInvoicesChargesId = ({id}: GetApiInvoicesChargesIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Invoices', id],\n        queryFn: () => getApiInvoicesChargesIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Landlords/services/useGetApiLandlordsId.generated.ts": "import { getApiLandlordsIdResponse } from '@/sections/Landlords/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiLandlordsIdFnArgs = {id: string, embed?: (Array<'appointments' | 'documents' | 'office' | 'properties' | 'solicitor' | 'source'>) | null | undefined, extrasField?: (Array<string>) | null | undefined};\nexport const getApiLandlordsIdFn = async ({id, embed, extrasField}: GetApiLandlordsIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/landlords/${id}${querySerialiser({args:{embed, extrasField}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiLandlordsIdResponse.parse(data)\n    };\nexport const useGetApiLandlordsId = ({id, embed, extrasField}: GetApiLandlordsIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Landlords', id, embed, extrasField],\n        queryFn: () => getApiLandlordsIdFn({id, embed, extrasField})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Landlords/services/usePatchApiLandlordsId.generated.ts": "import { UpdateLandlordModel } from '@/schemas/updateLandlordModel.generated.tsx'\nimport { patchApiLandlordsIdResponse } from '@/sections/Landlords/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type PatchApiLandlordsIdFnArgs = {'If-Match'?: string, id: string, body: UpdateLandlordModel};\nexport const patchApiLandlordsIdFn = async ({'If-Match': ifMatch, id, body}: PatchApiLandlordsIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({'If-Match': ifMatch})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/landlords/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PATCH',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return patchApiLandlordsIdResponse.parse(data)\n    };\nexport const usePatchApiLandlordsId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: patchApiLandlordsIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Landlords']})\n        }\n      })\n    };",
  "src/schemas/updateLandlordModel.generated.tsx": "import { UpdateLandlordSourceModel, updateLandlordSourceModel } from '@/schemas/updateLandlordSourceModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type UpdateLandlordModel = /** Request body used to update an existing landlord */\n{active?: (/** A flag determining whether or not the landlord is currently active */\nboolean) | null | undefined, solicitorId?: (/** The unique identifier of the company acting as the landlord's solicitor */\nstring) | null | undefined, officeId?: (/** The unique identifier of the office that is associated to the landlord */\nstring) | null | undefined, source?: (UpdateLandlordSourceModel) | null | undefined, metadata?: (/** App specific metadata that to set against the landlord */\nRecord<string, Record<string, never>>) | null | undefined};\nexport const updateLandlordModel = /** Request body used to update an existing landlord */\nz.object({active: /** A flag determining whether or not the landlord is currently active */\nz.boolean().optional().nullable(), solicitorId: /** The unique identifier of the company acting as the landlord's solicitor */\nz.string().optional().nullable(), officeId: /** The unique identifier of the office that is associated to the landlord */\nz.string().optional().nullable(), source: updateLandlordSourceModel.optional().nullable(), metadata: /** App specific metadata that to set against the landlord */\nz.record(z.string(), z.object({})).optional().nullable()});",
  "src/schemas/updateLandlordSourceModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateLandlordSourceModel = /** Request body used to update the source of an existing landlord */\n{id?: (/** The unique identifier of the source of the landlord */\nstring) | null | undefined, type?: (/** The source type (office/source) */\nstring) | null | undefined};\nexport const updateLandlordSourceModel = /** Request body used to update the source of an existing landlord */\nz.object({id: /** The unique identifier of the source of the landlord */\nz.string().optional().nullable(), type: /** The source type (office/source) */\nz.string().optional().nullable()});",
  "src/sections/Landlords/services/useGetApiLandlordsIdRelationshipsRelationshipId.generated.ts": "import { getApiLandlordsIdRelationshipsRelationshipIdResponse } from '@/sections/Landlords/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiLandlordsIdRelationshipsRelationshipIdFnArgs = {id: string, relationshipId: string};\nexport const getApiLandlordsIdRelationshipsRelationshipIdFn = async ({id, relationshipId}: GetApiLandlordsIdRelationshipsRelationshipIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/landlords/${id}/relationships/${relationshipId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiLandlordsIdRelationshipsRelationshipIdResponse.parse(data)\n    };\nexport const useGetApiLandlordsIdRelationshipsRelationshipId = ({id, relationshipId}: GetApiLandlordsIdRelationshipsRelationshipIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Landlords', id, relationshipId],\n        queryFn: () => getApiLandlordsIdRelationshipsRelationshipIdFn({id, relationshipId})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Landlords/services/useDeleteApiLandlordsIdRelationshipsRelationshipId.generated.ts": "import { deleteApiLandlordsIdRelationshipsRelationshipIdResponse } from '@/sections/Landlords/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type DeleteApiLandlordsIdRelationshipsRelationshipIdFnArgs = {id: string, relationshipId: string};\nexport const deleteApiLandlordsIdRelationshipsRelationshipIdFn = async ({id, relationshipId}: DeleteApiLandlordsIdRelationshipsRelationshipIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/landlords/${id}/relationships/${relationshipId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'DELETE',\n          \n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return deleteApiLandlordsIdRelationshipsRelationshipIdResponse.parse(data)\n    };\nexport const useDeleteApiLandlordsIdRelationshipsRelationshipId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: deleteApiLandlordsIdRelationshipsRelationshipIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Landlords']})\n        }\n      })\n    };",
  "src/sections/Metadata/services/useGetApiMetadataId.generated.ts": "import { getApiMetadataIdResponse } from '@/sections/Metadata/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiMetadataIdFnArgs = {id: string};\nexport const getApiMetadataIdFn = async ({id}: GetApiMetadataIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/metadata/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiMetadataIdResponse.parse(data)\n    };\nexport const useGetApiMetadataId = ({id}: GetApiMetadataIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Metadata', id],\n        queryFn: () => getApiMetadataIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Metadata/services/useUpdateApiMetadataId.generated.ts": "import { UpdateMetadataRequest } from '@/schemas/updateMetadataRequest.generated.tsx'\nimport { updateApiMetadataIdResponse } from '@/sections/Metadata/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type UpdateApiMetadataIdFnArgs = {id: string, body: UpdateMetadataRequest};\nexport const updateApiMetadataIdFn = async ({id, body}: UpdateApiMetadataIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/metadata/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PUT',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return updateApiMetadataIdResponse.parse(data)\n    };\nexport const useUpdateApiMetadataId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: updateApiMetadataIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Metadata']})\n        }\n      })\n    };",
  "src/schemas/updateMetadataRequest.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateMetadataRequest = /** Payload to update a metadata record */\n{metadata: /** The updated JSON document to store */\nstring};\nexport const updateMetadataRequest = /** Payload to update a metadata record */\nz.object({metadata: /** The updated JSON document to store */\nz.string().min(1)});",
  "src/sections/Metadata/services/useDeleteApiMetadataId.generated.ts": "import { deleteApiMetadataIdResponse } from '@/sections/Metadata/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type DeleteApiMetadataIdFnArgs = {id: string};\nexport const deleteApiMetadataIdFn = async ({id}: DeleteApiMetadataIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/metadata/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'DELETE',\n          \n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return deleteApiMetadataIdResponse.parse(data)\n    };\nexport const useDeleteApiMetadataId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: deleteApiMetadataIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Metadata']})\n        }\n      })\n    };",
  "src/sections/Metadata/services/usePatchApiMetadataId.generated.ts": "import { patchApiMetadataIdResponse } from '@/sections/Metadata/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type PatchApiMetadataIdFnArgs = {id: string, body: /** The patch metadata payload. */\nArray<Record<string, never>>};\nexport const patchApiMetadataIdFn = async ({id, body}: PatchApiMetadataIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/metadata/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PATCH',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return patchApiMetadataIdResponse.parse(data)\n    };\nexport const usePatchApiMetadataId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: patchApiMetadataIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Metadata']})\n        }\n      })\n    };",
  "src/sections/MetadataSchema/services/useGetApiMetadataMetadataSchemaId.generated.ts": "import { getApiMetadataMetadataSchemaIdResponse } from '@/sections/MetadataSchema/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiMetadataMetadataSchemaIdFnArgs = {id: string};\nexport const getApiMetadataMetadataSchemaIdFn = async ({id}: GetApiMetadataMetadataSchemaIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/metadata/metadataSchema/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiMetadataMetadataSchemaIdResponse.parse(data)\n    };\nexport const useGetApiMetadataMetadataSchemaId = ({id}: GetApiMetadataMetadataSchemaIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['MetadataSchema', id],\n        queryFn: () => getApiMetadataMetadataSchemaIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/MetadataSchema/services/useUpdateApiMetadataMetadataSchemaId.generated.ts": "import { UpdateSchemaRequest } from '@/schemas/updateSchemaRequest.generated.tsx'\nimport { updateApiMetadataMetadataSchemaIdResponse } from '@/sections/MetadataSchema/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type UpdateApiMetadataMetadataSchemaIdFnArgs = {id: string, body: UpdateSchemaRequest};\nexport const updateApiMetadataMetadataSchemaIdFn = async ({id, body}: UpdateApiMetadataMetadataSchemaIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/metadata/metadataSchema/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PUT',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return updateApiMetadataMetadataSchemaIdResponse.parse(data)\n    };\nexport const useUpdateApiMetadataMetadataSchemaId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: updateApiMetadataMetadataSchemaIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['MetadataSchema']})\n        }\n      })\n    };",
  "src/schemas/updateSchemaRequest.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateSchemaRequest = /** Payload to update a JSON schema */\n{schema: /** The updated JSON schema to store */\nstring};\nexport const updateSchemaRequest = /** Payload to update a JSON schema */\nz.object({schema: /** The updated JSON schema to store */\nz.string().min(1)});",
  "src/sections/Negotiators/services/useGetApiNegotiatorsId.generated.ts": "import { getApiNegotiatorsIdResponse } from '@/sections/Negotiators/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiNegotiatorsIdFnArgs = {id: string, embed?: (Array<'office'>) | null | undefined};\nexport const getApiNegotiatorsIdFn = async ({id, embed}: GetApiNegotiatorsIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/negotiators/${id}${querySerialiser({args:{embed}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiNegotiatorsIdResponse.parse(data)\n    };\nexport const useGetApiNegotiatorsId = ({id, embed}: GetApiNegotiatorsIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Negotiators', id, embed],\n        queryFn: () => getApiNegotiatorsIdFn({id, embed})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Negotiators/services/usePatchApiNegotiatorsId.generated.ts": "import { UpdateNegotiatorModel } from '@/schemas/updateNegotiatorModel.generated.tsx'\nimport { patchApiNegotiatorsIdResponse } from '@/sections/Negotiators/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type PatchApiNegotiatorsIdFnArgs = {'If-Match'?: string, id: string, body: UpdateNegotiatorModel};\nexport const patchApiNegotiatorsIdFn = async ({'If-Match': ifMatch, id, body}: PatchApiNegotiatorsIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({'If-Match': ifMatch})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/negotiators/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PATCH',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return patchApiNegotiatorsIdResponse.parse(data)\n    };\nexport const usePatchApiNegotiatorsId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: patchApiNegotiatorsIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Negotiators']})\n        }\n      })\n    };",
  "src/schemas/updateNegotiatorModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateNegotiatorModel = /** Request body used to update an existing negotiator */\n{name?: (/** The name of the negotiator */\nstring) | null | undefined, jobTitle?: (/** The job title of the negotiator */\nstring) | null | undefined, active?: (/** A flag determining whether or not the negotiator is active */\nboolean) | null | undefined, workPhone?: (/** The work phone number of the negotiator */\nstring) | null | undefined, mobilePhone?: (/** The mobile phone number of the negotiator */\nstring) | null | undefined, email?: (/** The email address of the negotiator */\nstring) | null | undefined, diaryNegotiatorIds?: (/** The identifiers of other negotiators whose diaries should be displayed to this negotiator when rendering diary/calendar view components in applicants */\nArray<string>) | null | undefined, diaryOfficeIds?: (/** The identifiers of other offices whose diaries should be displayed to this negotiator when rendering diary/calendar view components in applicants */\nArray<string>) | null | undefined, metadata?: (/** App specific metadata to set against the negotiator */\nRecord<string, Record<string, never>>) | null | undefined};\nexport const updateNegotiatorModel = /** Request body used to update an existing negotiator */\nz.object({name: /** The name of the negotiator */\nz.string().optional().nullable(), jobTitle: /** The job title of the negotiator */\nz.string().optional().nullable(), active: /** A flag determining whether or not the negotiator is active */\nz.boolean().optional().nullable(), workPhone: /** The work phone number of the negotiator */\nz.string().optional().nullable(), mobilePhone: /** The mobile phone number of the negotiator */\nz.string().optional().nullable(), email: /** The email address of the negotiator */\nz.string().optional().nullable(), diaryNegotiatorIds: /** The identifiers of other negotiators whose diaries should be displayed to this negotiator when rendering diary/calendar view components in applicants */\nz.array(z.string().min(1)).optional().nullable(), diaryOfficeIds: /** The identifiers of other offices whose diaries should be displayed to this negotiator when rendering diary/calendar view components in applicants */\nz.array(z.string().min(1)).optional().nullable(), metadata: /** App specific metadata to set against the negotiator */\nz.record(z.string(), z.object({})).optional().nullable()});",
  "src/sections/Offers/services/useGetApiOffersId.generated.ts": "import { getApiOffersIdResponse } from '@/sections/Offers/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiOffersIdFnArgs = {id: string, embed?: (Array<'applicant' | 'conveyancing' | 'property' | 'negotiator'>) | null | undefined};\nexport const getApiOffersIdFn = async ({id, embed}: GetApiOffersIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/offers/${id}${querySerialiser({args:{embed}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiOffersIdResponse.parse(data)\n    };\nexport const useGetApiOffersId = ({id, embed}: GetApiOffersIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Offers', id, embed],\n        queryFn: () => getApiOffersIdFn({id, embed})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Offers/services/usePatchApiOffersId.generated.ts": "import { UpdateOfferModel } from '@/schemas/updateOfferModel.generated.tsx'\nimport { patchApiOffersIdResponse } from '@/sections/Offers/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type PatchApiOffersIdFnArgs = {'If-Match'?: string, id: string, body: UpdateOfferModel};\nexport const patchApiOffersIdFn = async ({'If-Match': ifMatch, id, body}: PatchApiOffersIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({'If-Match': ifMatch})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/offers/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PATCH',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return patchApiOffersIdResponse.parse(data)\n    };\nexport const usePatchApiOffersId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: patchApiOffersIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Offers']})\n        }\n      })\n    };",
  "src/schemas/updateOfferModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateOfferModel = /** Request body used to update an existing offer */\n{negotiatorId?: (/** The unique identifier of the negotiator associated to the offer */\nstring) | null | undefined, date?: (/** The date when the offer was made */\nstring) | null | undefined, amount?: (/** The monetary amount of the offer */\nnumber) | null | undefined, status?: (/** The current status of the offer (pending/withdrawn/rejected/accepted/noteOfInterest) */\nstring) | null | undefined, inclusions?: (/** A free text field describing items that should be included in the sale */\nstring) | null | undefined, exclusions?: (/** A free text field describing items that are explicitly excluded from the sale */\nstring) | null | undefined, conditions?: (/** A free text field describing any other conditions set by either party that relate to the sale */\nstring) | null | undefined, metadata?: (/** App specific metadata to set against the offer */\nRecord<string, Record<string, never>>) | null | undefined};\nexport const updateOfferModel = /** Request body used to update an existing offer */\nz.object({negotiatorId: /** The unique identifier of the negotiator associated to the offer */\nz.string().optional().nullable(), date: /** The date when the offer was made */\nz.string().optional().nullable(), amount: /** The monetary amount of the offer */\nz.number().optional().nullable(), status: /** The current status of the offer (pending/withdrawn/rejected/accepted/noteOfInterest) */\nz.string().optional().nullable(), inclusions: /** A free text field describing items that should be included in the sale */\nz.string().optional().nullable(), exclusions: /** A free text field describing items that are explicitly excluded from the sale */\nz.string().optional().nullable(), conditions: /** A free text field describing any other conditions set by either party that relate to the sale */\nz.string().optional().nullable(), metadata: /** App specific metadata to set against the offer */\nz.record(z.string(), z.object({})).optional().nullable()});",
  "src/sections/Offices/services/useGetApiOfficesId.generated.ts": "import { getApiOfficesIdResponse } from '@/sections/Offices/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiOfficesIdFnArgs = {id: string, embed?: (Array<'negotiators'>) | null | undefined, extrasField?: (Array<string>) | null | undefined};\nexport const getApiOfficesIdFn = async ({id, embed, extrasField}: GetApiOfficesIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/offices/${id}${querySerialiser({args:{embed, extrasField}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiOfficesIdResponse.parse(data)\n    };\nexport const useGetApiOfficesId = ({id, embed, extrasField}: GetApiOfficesIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Offices', id, embed, extrasField],\n        queryFn: () => getApiOfficesIdFn({id, embed, extrasField})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Offices/services/usePatchApiOfficesId.generated.ts": "import { UpdateOfficeModel } from '@/schemas/updateOfficeModel.generated.tsx'\nimport { patchApiOfficesIdResponse } from '@/sections/Offices/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type PatchApiOfficesIdFnArgs = {'If-Match'?: string, id: string, body: UpdateOfficeModel};\nexport const patchApiOfficesIdFn = async ({'If-Match': ifMatch, id, body}: PatchApiOfficesIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({'If-Match': ifMatch})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/offices/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PATCH',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return patchApiOfficesIdResponse.parse(data)\n    };\nexport const usePatchApiOfficesId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: patchApiOfficesIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Offices']})\n        }\n      })\n    };",
  "src/schemas/updateOfficeModel.generated.tsx": "import { UpdateOfficeAddressModel, updateOfficeAddressModel } from '@/schemas/updateOfficeAddressModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type UpdateOfficeModel = /** Request body used to update an existing office */\n{name?: (/** The name of the office */\nstring) | null | undefined, active?: (/** A flag denoting whether or not this office is active */\nboolean) | null | undefined, manager?: (/** The name of the office manager */\nstring) | null | undefined, address?: (UpdateOfficeAddressModel) | null | undefined, workPhone?: (/** The work phone number of the office */\nstring) | null | undefined, email?: (/** The email address of the office */\nstring) | null | undefined, metadata?: (/** App specific metadata to set against the office */\nRecord<string, Record<string, never>>) | null | undefined};\nexport const updateOfficeModel = /** Request body used to update an existing office */\nz.object({name: /** The name of the office */\nz.string().optional().nullable(), active: /** A flag denoting whether or not this office is active */\nz.boolean().optional().nullable(), manager: /** The name of the office manager */\nz.string().optional().nullable(), address: updateOfficeAddressModel.optional().nullable(), workPhone: /** The work phone number of the office */\nz.string().optional().nullable(), email: /** The email address of the office */\nz.string().optional().nullable(), metadata: /** App specific metadata to set against the office */\nz.record(z.string(), z.object({})).optional().nullable()});",
  "src/schemas/updateOfficeAddressModel.generated.tsx": "import { UpdateOfficeAddressGeolocationModel, updateOfficeAddressGeolocationModel } from '@/schemas/updateOfficeAddressGeolocationModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type UpdateOfficeAddressModel = /** Request body used to update the address of an existing office */\n{buildingName?: (/** The building name */\nstring) | null | undefined, buildingNumber?: (/** The building number */\nstring) | null | undefined, line1?: (/** The first line of the address */\nstring) | null | undefined, line2?: (/** The second line of the address */\nstring) | null | undefined, line3?: (/** The third line of the address */\nstring) | null | undefined, line4?: (/** The fourth line of the address */\nstring) | null | undefined, postcode?: (/** The postcode */\nstring) | null | undefined, countryId?: (/** The ISO-3166 country code that the address resides within */\nstring) | null | undefined, geolocation?: (UpdateOfficeAddressGeolocationModel) | null | undefined};\nexport const updateOfficeAddressModel = /** Request body used to update the address of an existing office */\nz.object({buildingName: /** The building name */\nz.string().optional().nullable(), buildingNumber: /** The building number */\nz.string().optional().nullable(), line1: /** The first line of the address */\nz.string().optional().nullable(), line2: /** The second line of the address */\nz.string().optional().nullable(), line3: /** The third line of the address */\nz.string().optional().nullable(), line4: /** The fourth line of the address */\nz.string().optional().nullable(), postcode: /** The postcode */\nz.string().optional().nullable(), countryId: /** The ISO-3166 country code that the address resides within */\nz.string().optional().nullable(), geolocation: updateOfficeAddressGeolocationModel.optional().nullable()});",
  "src/schemas/updateOfficeAddressGeolocationModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateOfficeAddressGeolocationModel = /** Request body used to set the geolocation coordinates of an existing address */\n{latitude?: (/** The latitude coordinate of the coordinate pair */\nnumber) | null | undefined, longitude?: (/** The longitude coordinate of the coordinate pair */\nnumber) | null | undefined};\nexport const updateOfficeAddressGeolocationModel = /** Request body used to set the geolocation coordinates of an existing address */\nz.object({latitude: /** The latitude coordinate of the coordinate pair */\nz.number().optional().nullable(), longitude: /** The longitude coordinate of the coordinate pair */\nz.number().optional().nullable()});",
  "src/sections/Properties/services/useGetApiPropertiesId.generated.ts": "import { getApiPropertiesIdResponse } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiPropertiesIdFnArgs = {id: string, embed?: (Array<'appointments' | 'area' | 'certificates' | 'department' | 'documents' | 'images' | 'keys' | 'landlord' | 'negotiator' | 'offers' | 'offices' | 'tenancies' | 'vendor'>) | null | undefined, extrasField?: (Array<string>) | null | undefined};\nexport const getApiPropertiesIdFn = async ({id, embed, extrasField}: GetApiPropertiesIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/properties/${id}${querySerialiser({args:{embed, extrasField}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiPropertiesIdResponse.parse(data)\n    };\nexport const useGetApiPropertiesId = ({id, embed, extrasField}: GetApiPropertiesIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Properties', id, embed, extrasField],\n        queryFn: () => getApiPropertiesIdFn({id, embed, extrasField})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Properties/services/usePatchApiPropertiesId.generated.ts": "import { UpdatePropertyModel } from '@/schemas/updatePropertyModel.generated.tsx'\nimport { patchApiPropertiesIdResponse } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type PatchApiPropertiesIdFnArgs = {'If-Match'?: string, id: string, body: UpdatePropertyModel};\nexport const patchApiPropertiesIdFn = async ({'If-Match': ifMatch, id, body}: PatchApiPropertiesIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({'If-Match': ifMatch})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/properties/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PATCH',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return patchApiPropertiesIdResponse.parse(data)\n    };\nexport const usePatchApiPropertiesId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: patchApiPropertiesIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Properties']})\n        }\n      })\n    };",
  "src/schemas/updatePropertyModel.generated.tsx": "import { UpdatePropertyAddressModel, updatePropertyAddressModel } from '@/schemas/updatePropertyAddressModel.generated.tsx'\nimport { UpdatePropertyEpcModel, updatePropertyEpcModel } from '@/schemas/updatePropertyEpcModel.generated.tsx'\nimport { UpdatePropertyExternalAreaModel, updatePropertyExternalAreaModel } from '@/schemas/updatePropertyExternalAreaModel.generated.tsx'\nimport { UpdatePropertyInternalAreaModel, updatePropertyInternalAreaModel } from '@/schemas/updatePropertyInternalAreaModel.generated.tsx'\nimport { UpdatePropertySellingModel, updatePropertySellingModel } from '@/schemas/updatePropertySellingModel.generated.tsx'\nimport { UpdatePropertyLettingModel, updatePropertyLettingModel } from '@/schemas/updatePropertyLettingModel.generated.tsx'\nimport { UpdatePropertyRegionalModel, updatePropertyRegionalModel } from '@/schemas/updatePropertyRegionalModel.generated.tsx'\nimport { UpdatePropertyRuralModel, updatePropertyRuralModel } from '@/schemas/updatePropertyRuralModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type UpdatePropertyModel = /** Request body used to update an existing property */\n{lastCall?: (/** The date the owner of the property was last called */\nstring) | null | undefined, nextCall?: (/** The date the owner of the property is next due to be called */\nstring) | null | undefined, roomDetailsApproved?: (/** A flag determining whether or not the property's room details have been approved by the vendor or landlord */\nboolean) | null | undefined, strapline?: (/** The strapline description containing a short summary about the property */\nstring) | null | undefined, description?: (/** The brief description of the property */\nstring) | null | undefined, summary?: (/** The summary of accommodation, typically short phrases or bullet points describing the key features of the property */\nstring) | null | undefined, alternateId?: (/** An optional alternative identifier specified for this property */\nstring) | null | undefined, specialFeatures?: (/** The property's special feature property requirements (eg Swimming Pool, Tennis Court), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<string>) | null | undefined, address?: (UpdatePropertyAddressModel) | null | undefined, bedrooms?: (/** The total number of bedrooms in the property */\nnumber) | null | undefined, bedroomsMax?: (/** The maximum number of bedrooms in the property */\nnumber) | null | undefined, numberOfUnits?: (/** The number of units offered on the market. This is typically used when marketing development sites. */\nnumber) | null | undefined, receptions?: (/** The total number of reception rooms in the property */\nnumber) | null | undefined, receptionsMax?: (/** The maximum number of reception rooms in the property */\nnumber) | null | undefined, bathrooms?: (/** The total number of bathrooms in the property */\nnumber) | null | undefined, bathroomsMax?: (/** The maximum number of bathrooms in the property */\nnumber) | null | undefined, parkingSpaces?: (/** The total number of parking spaces the property has. This is only supported by some departments. Please refer to the glossary for support [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nnumber) | null | undefined, councilTax?: (/** The council tax banding of the property (A/B/C/D/E/F/G/H/I/notYetAvailable) */\nstring) | null | undefined, internetAdvertising?: (/** A flag denoting whether or not this property can be advertised on the internet */\nboolean) | null | undefined, viewingArrangements?: (/** The arrangements regarding viewing the property */\nstring) | null | undefined, videoUrl?: (/** The url of a video associated with this property, such as a virtual tour */\nstring) | null | undefined, videoCaption?: (/** The caption for the video url associated with this property */\nstring) | null | undefined, video2Url?: (/** The url of a second video associated with this property, such as a virtual tour */\nstring) | null | undefined, video2Caption?: (/** The caption for the second video url associated with this property */\nstring) | null | undefined, notes?: (/** Any general notes regarding the property. These are not usually exposed to end users and may contain sensitive information about a sale */\nstring) | null | undefined, longDescription?: (/** The long description of the property */\nstring) | null | undefined, floorLevel?: (/** The floor level the property is on. Note that this field can only be set when certain configuration settings are enabled on the property's department. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nnumber) | null | undefined, internalFloors?: (/** The number of internal floors the property has. Note that this field can only be set when certain configuration settings are enabled on the property's department. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nnumber) | null | undefined, totalFloors?: (/** The total number of floors the property has. Note that this field can only be set when certain configuration settings are enabled on the property's department. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nnumber) | null | undefined, boardStatus?: (/** The status of the advertising board sited outside or near to the property */\nstring) | null | undefined, boardNotes?: (/** Any notes relevant to the advertising board sited outside or near to the property */\nstring) | null | undefined, boardUpdated?: (/** The date the advertising board was last updated (or should be updated when the date is in the future) */\nstring) | null | undefined, valuation?: (/** The date on which the property was valued. Note that this can differ to physical appointment dates in some cases */\nstring) | null | undefined, epc?: (UpdatePropertyEpcModel) | null | undefined, externalArea?: (UpdatePropertyExternalAreaModel) | null | undefined, internalArea?: (UpdatePropertyInternalAreaModel) | null | undefined, selling?: (UpdatePropertySellingModel) | null | undefined, letting?: (UpdatePropertyLettingModel) | null | undefined, regional?: (UpdatePropertyRegionalModel) | null | undefined, rural?: (UpdatePropertyRuralModel) | null | undefined, type?: (/** The attributes describing the overall type of the property (eg house, bungalow, land), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<string>) | null | undefined, style?: (/** The attributes describing the style of property (eg detached, semiDetached), defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<string>) | null | undefined, situation?: (/** The attributes describing other aspects of the property - such as outside space - as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<string>) | null | undefined, parking?: (/** The attributes describing the parking available at the property (eg garage), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<string>) | null | undefined, age?: (/** The attributes describing the age of the property (eg new, period), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<string>) | null | undefined, locality?: (/** The attributes describing the general location of the property (eg rural, townCity), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nArray<string>) | null | undefined, negotiatorId?: (/** The unique identifier of the negotiator managing the property */\nstring) | null | undefined, officeIds?: (/** A collection of unique identifiers of offices attached to the property. The first item in the collection is considered the primary office */\nArray<string>) | null | undefined, areaId?: (/** The unique identifier of the area that the property resides in */\nstring) | null | undefined, url?: (/** The url to the property on an external website */\nstring) | null | undefined, urlCaption?: (/** The caption to accompany the url to the property on an external website */\nstring) | null | undefined, groundRent?: (/** Any ground rent payment that applies to the property */\nnumber) | null | undefined, groundRentComment?: (/** Comments regarding the ground rent of the property */\nstring) | null | undefined, groundRentReviewDate?: (/** The date when the ground rent payable on the property should be reviewed */\nDate) | null | undefined, groundRentIncrease?: (/** The annual percentage increase of the ground rent after being reviewed */\nnumber) | null | undefined, serviceCharge?: (/** Any service charge payment that applies to the property */\nnumber) | null | undefined, serviceChargeComment?: (/** Comments regarding the service charge of the property */\nstring) | null | undefined, availableServicesIds?: (/** Identifiers of any services connected at the property */\nArray<string>) | null | undefined, metadata?: (/** App specific metadata to set against the property */\nRecord<string, Record<string, never>>) | null | undefined};\nexport const updatePropertyModel = /** Request body used to update an existing property */\nz.object({lastCall: /** The date the owner of the property was last called */\nz.string().optional().nullable(), nextCall: /** The date the owner of the property is next due to be called */\nz.string().optional().nullable(), roomDetailsApproved: /** A flag determining whether or not the property's room details have been approved by the vendor or landlord */\nz.boolean().optional().nullable(), strapline: /** The strapline description containing a short summary about the property */\nz.string().optional().nullable(), description: /** The brief description of the property */\nz.string().optional().nullable(), summary: /** The summary of accommodation, typically short phrases or bullet points describing the key features of the property */\nz.string().optional().nullable(), alternateId: /** An optional alternative identifier specified for this property */\nz.string().optional().nullable(), specialFeatures: /** The property's special feature property requirements (eg Swimming Pool, Tennis Court), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(z.string().min(1)).optional().nullable(), address: updatePropertyAddressModel.optional().nullable(), bedrooms: /** The total number of bedrooms in the property */\nz.number().int().optional().nullable(), bedroomsMax: /** The maximum number of bedrooms in the property */\nz.number().int().optional().nullable(), numberOfUnits: /** The number of units offered on the market. This is typically used when marketing development sites. */\nz.number().int().optional().nullable(), receptions: /** The total number of reception rooms in the property */\nz.number().int().optional().nullable(), receptionsMax: /** The maximum number of reception rooms in the property */\nz.number().int().optional().nullable(), bathrooms: /** The total number of bathrooms in the property */\nz.number().int().optional().nullable(), bathroomsMax: /** The maximum number of bathrooms in the property */\nz.number().int().optional().nullable(), parkingSpaces: /** The total number of parking spaces the property has. This is only supported by some departments. Please refer to the glossary for support [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.number().int().optional().nullable(), councilTax: /** The council tax banding of the property (A/B/C/D/E/F/G/H/I/notYetAvailable) */\nz.string().optional().nullable(), internetAdvertising: /** A flag denoting whether or not this property can be advertised on the internet */\nz.boolean().optional().nullable(), viewingArrangements: /** The arrangements regarding viewing the property */\nz.string().optional().nullable(), videoUrl: /** The url of a video associated with this property, such as a virtual tour */\nz.string().optional().nullable(), videoCaption: /** The caption for the video url associated with this property */\nz.string().optional().nullable(), video2Url: /** The url of a second video associated with this property, such as a virtual tour */\nz.string().optional().nullable(), video2Caption: /** The caption for the second video url associated with this property */\nz.string().optional().nullable(), notes: /** Any general notes regarding the property. These are not usually exposed to end users and may contain sensitive information about a sale */\nz.string().optional().nullable(), longDescription: /** The long description of the property */\nz.string().optional().nullable(), floorLevel: /** The floor level the property is on. Note that this field can only be set when certain configuration settings are enabled on the property's department. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nz.number().int().optional().nullable(), internalFloors: /** The number of internal floors the property has. Note that this field can only be set when certain configuration settings are enabled on the property's department. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nz.number().int().optional().nullable(), totalFloors: /** The total number of floors the property has. Note that this field can only be set when certain configuration settings are enabled on the property's department. Please [refer to the glossary](https://foundations-documentation.reapit.cloud/platform-glossary#department) for more information */\nz.number().int().optional().nullable(), boardStatus: /** The status of the advertising board sited outside or near to the property */\nz.string().optional().nullable(), boardNotes: /** Any notes relevant to the advertising board sited outside or near to the property */\nz.string().optional().nullable(), boardUpdated: /** The date the advertising board was last updated (or should be updated when the date is in the future) */\nz.string().optional().nullable(), valuation: /** The date on which the property was valued. Note that this can differ to physical appointment dates in some cases */\nz.string().optional().nullable(), epc: updatePropertyEpcModel.optional().nullable(), externalArea: updatePropertyExternalAreaModel.optional().nullable(), internalArea: updatePropertyInternalAreaModel.optional().nullable(), selling: updatePropertySellingModel.optional().nullable(), letting: updatePropertyLettingModel.optional().nullable(), regional: updatePropertyRegionalModel.optional().nullable(), rural: updatePropertyRuralModel.optional().nullable(), type: /** The attributes describing the overall type of the property (eg house, bungalow, land), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(z.string().min(1)).optional().nullable(), style: /** The attributes describing the style of property (eg detached, semiDetached), defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(z.string().min(1)).optional().nullable(), situation: /** The attributes describing other aspects of the property - such as outside space - as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(z.string().min(1)).optional().nullable(), parking: /** The attributes describing the parking available at the property (eg garage), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(z.string().min(1)).optional().nullable(), age: /** The attributes describing the age of the property (eg new, period), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(z.string().min(1)).optional().nullable(), locality: /** The attributes describing the general location of the property (eg rural, townCity), as defined by the property's [department](https://foundations-documentation.reapit.cloud/platform-glossary#department) */\nz.array(z.string().min(1)).optional().nullable(), negotiatorId: /** The unique identifier of the negotiator managing the property */\nz.string().optional().nullable(), officeIds: /** A collection of unique identifiers of offices attached to the property. The first item in the collection is considered the primary office */\nz.array(z.string().min(1)).optional().nullable(), areaId: /** The unique identifier of the area that the property resides in */\nz.string().optional().nullable(), url: /** The url to the property on an external website */\nz.string().optional().nullable(), urlCaption: /** The caption to accompany the url to the property on an external website */\nz.string().optional().nullable(), groundRent: /** Any ground rent payment that applies to the property */\nz.number().optional().nullable(), groundRentComment: /** Comments regarding the ground rent of the property */\nz.string().optional().nullable(), groundRentReviewDate: /** The date when the ground rent payable on the property should be reviewed */\nz.string().pipe( z.coerce.date() ).optional().nullable(), groundRentIncrease: /** The annual percentage increase of the ground rent after being reviewed */\nz.number().optional().nullable(), serviceCharge: /** Any service charge payment that applies to the property */\nz.number().optional().nullable(), serviceChargeComment: /** Comments regarding the service charge of the property */\nz.string().optional().nullable(), availableServicesIds: /** Identifiers of any services connected at the property */\nz.array(z.string().min(1)).optional().nullable(), metadata: /** App specific metadata to set against the property */\nz.record(z.string(), z.object({})).optional().nullable()});",
  "src/schemas/updatePropertyAddressModel.generated.tsx": "import { UpdatePropertyGeolocationModel, updatePropertyGeolocationModel } from '@/schemas/updatePropertyGeolocationModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type UpdatePropertyAddressModel = /** Request body used to update the address of an existing property */\n{buildingName?: (/** The building name */\nstring) | null | undefined, buildingNumber?: (/** The building number */\nstring) | null | undefined, line1?: (/** The first line of the address */\nstring) | null | undefined, line2?: (/** The second line of the address */\nstring) | null | undefined, line3?: (/** The third line of the address */\nstring) | null | undefined, line4?: (/** The fourth line of the address */\nstring) | null | undefined, postcode?: (/** The postcode */\nstring) | null | undefined, countryId?: (/** The ISO-3166 country code that the address resides within */\nstring) | null | undefined, geolocation?: (UpdatePropertyGeolocationModel) | null | undefined};\nexport const updatePropertyAddressModel = /** Request body used to update the address of an existing property */\nz.object({buildingName: /** The building name */\nz.string().optional().nullable(), buildingNumber: /** The building number */\nz.string().optional().nullable(), line1: /** The first line of the address */\nz.string().optional().nullable(), line2: /** The second line of the address */\nz.string().optional().nullable(), line3: /** The third line of the address */\nz.string().optional().nullable(), line4: /** The fourth line of the address */\nz.string().optional().nullable(), postcode: /** The postcode */\nz.string().optional().nullable(), countryId: /** The ISO-3166 country code that the address resides within */\nz.string().optional().nullable(), geolocation: updatePropertyGeolocationModel.optional().nullable()});",
  "src/schemas/updatePropertyGeolocationModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdatePropertyGeolocationModel = /** Request body used to update the geolocation coordinates of an existing property's address */\n{latitude?: (/** The latitude coordinate of the coordinate pair */\nnumber) | null | undefined, longitude?: (/** The longitude coordinate of the coordinate pair */\nnumber) | null | undefined};\nexport const updatePropertyGeolocationModel = /** Request body used to update the geolocation coordinates of an existing property's address */\nz.object({latitude: /** The latitude coordinate of the coordinate pair */\nz.number().optional().nullable(), longitude: /** The longitude coordinate of the coordinate pair */\nz.number().optional().nullable()});",
  "src/schemas/updatePropertyEpcModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdatePropertyEpcModel = /** Request body used to update the EPC statistics of an existing property */\n{exempt?: (/** A flag denoting whether or not this property is exempt from requiring an EPC certificate */\nboolean) | null | undefined, eer?: (/** The current energy efficiency rating */\nnumber) | null | undefined, eerPotential?: (/** The potential energy efficiency rating */\nnumber) | null | undefined, eir?: (/** The current environmental impact rating */\nnumber) | null | undefined, eirPotential?: (/** The potential environmental impact rating */\nnumber) | null | undefined, fullDocumentUrl?: (/** The URL to access the full EPC document */\nstring) | null | undefined, firstPageDocumentUrl?: (/** The URL to access the first page of the EPC document */\nstring) | null | undefined};\nexport const updatePropertyEpcModel = /** Request body used to update the EPC statistics of an existing property */\nz.object({exempt: /** A flag denoting whether or not this property is exempt from requiring an EPC certificate */\nz.boolean().optional().nullable(), eer: /** The current energy efficiency rating */\nz.number().int().optional().nullable(), eerPotential: /** The potential energy efficiency rating */\nz.number().int().optional().nullable(), eir: /** The current environmental impact rating */\nz.number().int().optional().nullable(), eirPotential: /** The potential environmental impact rating */\nz.number().int().optional().nullable(), fullDocumentUrl: /** The URL to access the full EPC document */\nz.string().optional().nullable(), firstPageDocumentUrl: /** The URL to access the first page of the EPC document */\nz.string().optional().nullable()});",
  "src/schemas/updatePropertyExternalAreaModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdatePropertyExternalAreaModel = /** Request body to update the external land area of an existing property */\n{type?: (/** The unit of area (acres/hectares) */\nstring) | null | undefined, min?: (/** The minimum area bound */\nnumber) | null | undefined, max?: (/** The maximum area bound (please note there is no corresponding field in the Reapit CRM) */\nnumber) | null | undefined};\nexport const updatePropertyExternalAreaModel = /** Request body to update the external land area of an existing property */\nz.object({type: /** The unit of area (acres/hectares) */\nz.string().optional().nullable(), min: /** The minimum area bound */\nz.number().optional().nullable(), max: /** The maximum area bound (please note there is no corresponding field in the Reapit CRM) */\nz.number().optional().nullable()});",
  "src/schemas/updatePropertyInternalAreaModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdatePropertyInternalAreaModel = /** Request body to update the internal dimensions of an existing property */\n{type?: (/** The unit of area (squareFeet/squareMetres) */\nstring) | null | undefined, min?: (/** The minimum area bound */\nnumber) | null | undefined, max?: (/** The maximum area bound */\nnumber) | null | undefined};\nexport const updatePropertyInternalAreaModel = /** Request body to update the internal dimensions of an existing property */\nz.object({type: /** The unit of area (squareFeet/squareMetres) */\nz.string().optional().nullable(), min: /** The minimum area bound */\nz.number().optional().nullable(), max: /** The maximum area bound */\nz.number().optional().nullable()});",
  "src/schemas/updatePropertySellingModel.generated.tsx": "import { UpdatePropertyTenureModel, updatePropertyTenureModel } from '@/schemas/updatePropertyTenureModel.generated.tsx'\nimport { UpdatePropertyCommissionFeeModel, updatePropertyCommissionFeeModel } from '@/schemas/updatePropertyCommissionFeeModel.generated.tsx'\nimport { UpdatePropertySharedOwnershipModel, updatePropertySharedOwnershipModel } from '@/schemas/updatePropertySharedOwnershipModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type UpdatePropertySellingModel = /** Request body used to update details specific to sales marketing on an existing property */\n{instructed?: (/** The date that the property was marked as for sale */\nstring) | null | undefined, price?: (/** The marketing price of the property */\nnumber) | null | undefined, reservationFee?: (/** The fee charged by the agent to reserve a property (typically a new build) */\nnumber) | null | undefined, qualifier?: (/** The price qualifier (askingPrice/priceOnApplication/guidePrice/offersInRegion/offersOver/offersInExcess/fixedPrice/priceReducedTo) */\nstring) | null | undefined, status?: (/** The current status of the sale (preAppraisal/valuation/paidValuation/forSale/forSaleUnavailable/underOffer/underOfferUnavailable/reserved/exchanged/completed/soldExternally/withdrawn) */\nstring) | null | undefined, disposal?: (/** The method used to sell the property (auction/confidential/tender/offersInvited/privateTreaty/sharedOwnership) */\nstring) | null | undefined, completed?: (/** The date the property sale was completed */\nstring) | null | undefined, exchanged?: (/** The date the property was exchanged */\nstring) | null | undefined, accountPaid?: (/** The date the property account was paid */\nstring) | null | undefined, tenure?: (UpdatePropertyTenureModel) | null | undefined, sellingAgency?: (/** The selling agency type (marketingForAssociate/clientsOnly/comparable/subAgent/jointSole/jointSoleFeeAvailable/multiple/multipleFeeAvailable/ownToSell/soleSellingRights/soleSellingRightsFeeAvailable/soleAgent/soleAgentFeeAvailable) */\nstring) | null | undefined, agencyId?: (/** The unique identifier of the custom selling agency type - only applicable when SellingAgency is not set */\nstring) | null | undefined, agreementExpiry?: (/** The date on which the agreement between the vendor and agent expires */\nstring) | null | undefined, fee?: (UpdatePropertyCommissionFeeModel) | null | undefined, recommendedPrice?: (/** The agent's recommended asking price */\nnumber) | null | undefined, valuationPrice?: (/** The agent's valuation price */\nnumber) | null | undefined, brochureId?: (/** The unique identifier of the document used for the sales brochure */\nstring) | null | undefined, decoration?: (/** The property's decorative condition (unmodernised/fair/good/veryGood) */\nArray<string>) | null | undefined, sharedOwnership?: (UpdatePropertySharedOwnershipModel) | null | undefined};\nexport const updatePropertySellingModel = /** Request body used to update details specific to sales marketing on an existing property */\nz.object({instructed: /** The date that the property was marked as for sale */\nz.string().optional().nullable(), price: /** The marketing price of the property */\nz.number().int().optional().nullable(), reservationFee: /** The fee charged by the agent to reserve a property (typically a new build) */\nz.number().int().optional().nullable(), qualifier: /** The price qualifier (askingPrice/priceOnApplication/guidePrice/offersInRegion/offersOver/offersInExcess/fixedPrice/priceReducedTo) */\nz.string().optional().nullable(), status: /** The current status of the sale (preAppraisal/valuation/paidValuation/forSale/forSaleUnavailable/underOffer/underOfferUnavailable/reserved/exchanged/completed/soldExternally/withdrawn) */\nz.string().optional().nullable(), disposal: /** The method used to sell the property (auction/confidential/tender/offersInvited/privateTreaty/sharedOwnership) */\nz.string().optional().nullable(), completed: /** The date the property sale was completed */\nz.string().optional().nullable(), exchanged: /** The date the property was exchanged */\nz.string().optional().nullable(), accountPaid: /** The date the property account was paid */\nz.string().optional().nullable(), tenure: updatePropertyTenureModel.optional().nullable(), sellingAgency: /** The selling agency type (marketingForAssociate/clientsOnly/comparable/subAgent/jointSole/jointSoleFeeAvailable/multiple/multipleFeeAvailable/ownToSell/soleSellingRights/soleSellingRightsFeeAvailable/soleAgent/soleAgentFeeAvailable) */\nz.string().optional().nullable(), agencyId: /** The unique identifier of the custom selling agency type - only applicable when SellingAgency is not set */\nz.string().optional().nullable(), agreementExpiry: /** The date on which the agreement between the vendor and agent expires */\nz.string().optional().nullable(), fee: updatePropertyCommissionFeeModel.optional().nullable(), recommendedPrice: /** The agent's recommended asking price */\nz.number().int().optional().nullable(), valuationPrice: /** The agent's valuation price */\nz.number().int().optional().nullable(), brochureId: /** The unique identifier of the document used for the sales brochure */\nz.string().optional().nullable(), decoration: /** The property's decorative condition (unmodernised/fair/good/veryGood) */\nz.array(z.string().min(1)).optional().nullable(), sharedOwnership: updatePropertySharedOwnershipModel.optional().nullable()});",
  "src/schemas/updatePropertyTenureModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdatePropertyTenureModel = /** Request body used to set the tenure of an existing property */\n{type?: (/** The type of tenure that applies to the property (freehold/leasehold/shareOfFreehold/commonhold/tba) */\nstring) | null | undefined, expiry?: (/** The tenure expiration date */\nstring) | null | undefined};\nexport const updatePropertyTenureModel = /** Request body used to set the tenure of an existing property */\nz.object({type: /** The type of tenure that applies to the property (freehold/leasehold/shareOfFreehold/commonhold/tba) */\nz.string().optional().nullable(), expiry: /** The tenure expiration date */\nz.string().optional().nullable()});",
  "src/schemas/updatePropertyCommissionFeeModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdatePropertyCommissionFeeModel = /** Request body used to update the commission fee for a property */\n{type?: (/** The commission letting fee type (percentage/fixed) */\nstring) | null | undefined, amount?: (/** The commission letting fee amount */\nnumber) | null | undefined};\nexport const updatePropertyCommissionFeeModel = /** Request body used to update the commission fee for a property */\nz.object({type: /** The commission letting fee type (percentage/fixed) */\nz.string().optional().nullable(), amount: /** The commission letting fee amount */\nz.number().optional().nullable()});",
  "src/schemas/updatePropertySharedOwnershipModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdatePropertySharedOwnershipModel = /** Details relating to the shared ownership of the property */\n{sharedPercentage?: (/** The percentage of the shared ownership property being sold by the vendor */\nnumber) | null | undefined, rent?: (/** The rent payable on the remainder of the shared ownership property */\nnumber) | null | undefined, rentFrequency?: (/** The frequency at which the shared ownership rent should be paid */\nstring) | null | undefined};\nexport const updatePropertySharedOwnershipModel = /** Details relating to the shared ownership of the property */\nz.object({sharedPercentage: /** The percentage of the shared ownership property being sold by the vendor */\nz.number().optional().nullable(), rent: /** The rent payable on the remainder of the shared ownership property */\nz.number().optional().nullable(), rentFrequency: /** The frequency at which the shared ownership rent should be paid */\nz.string().optional().nullable()});",
  "src/schemas/updatePropertyLettingModel.generated.tsx": "import { UpdatePropertyCommissionFeeModel, updatePropertyCommissionFeeModel } from '@/schemas/updatePropertyCommissionFeeModel.generated.tsx'\nimport { UpdateUtilityModel, updateUtilityModel } from '@/schemas/updateUtilityModel.generated.tsx'\nimport { UpdatePropertyLettingsDepositModel, updatePropertyLettingsDepositModel } from '@/schemas/updatePropertyLettingsDepositModel.generated.tsx'\nimport { UpdatePropertyLettingRentInsuranceModel, updatePropertyLettingRentInsuranceModel } from '@/schemas/updatePropertyLettingRentInsuranceModel.generated.tsx'\nimport { UpdatePropertyLettingLicencingModel, updatePropertyLettingLicencingModel } from '@/schemas/updatePropertyLettingLicencingModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type UpdatePropertyLettingModel = /** Request body used to update details specific to lettings marketing on an existing property */\n{instructed?: (/** The date the property was marked as to let */\nstring) | null | undefined, availableFrom?: (/** The date the property is next available from */\nstring) | null | undefined, availableTo?: (/** The date the property is available to */\nstring) | null | undefined, agreementSigned?: (/** The date the letting agreement between the landlord and agent was signed */\nstring) | null | undefined, rent?: (/** The rent being charged for the property */\nnumber) | null | undefined, rentFrequency?: (/** The frequency at which rent will be collected (weekly/monthly/annually) */\nstring) | null | undefined, rentIncludes?: (/** Details of any bills that are included in the rent */\nstring) | null | undefined, furnishing?: (/** The furnishing state that the property can be offered in (furnished/unfurnished/partFurnished) */\nArray<string>) | null | undefined, term?: (/** The acceptable letting terms (short/long/any) */\nstring) | null | undefined, status?: (/** The current status of the let (valuation/toLet/toLetUnavailable/underOffer/underOfferUnavailable/arrangingTenancyUnavailable/arrangingTenancy/tenancyCurrentUnavailable/tenancyCurrent/tenancyFinished/tenancyCancelled/sold/letByOtherAgent/letPrivately/provisional/withdrawn) */\nstring) | null | undefined, agentRole?: (/** The role that the agent will be performing for this lettings property (managed/rentCollection/collectFirstPayment/collectRentToDate/lettingOnly/introducingTenant) */\nstring) | null | undefined, landlordId?: (/** The unique identifier of the landlord letting the property */\nstring) | null | undefined, brochureId?: (/** The unique identifier of the document used for the lettings brochure */\nstring) | null | undefined, worksOrderNote?: (/** A note to accompany any works orders created for the property */\nstring) | null | undefined, minimumTerm?: (/** Sets the minimum number of months the property can be let out for */\nnumber) | null | undefined, managementFee?: (UpdatePropertyCommissionFeeModel) | null | undefined, lettingFee?: (UpdatePropertyCommissionFeeModel) | null | undefined, qualifier?: (/** The rent qualifier (rentOnApplication/askingRent) */\nstring) | null | undefined, utilities?: (UpdateUtilityModel) | null | undefined, deposit?: (UpdatePropertyLettingsDepositModel) | null | undefined, rentInsurance?: (UpdatePropertyLettingRentInsuranceModel) | null | undefined, licencing?: (UpdatePropertyLettingLicencingModel) | null | undefined};\nexport const updatePropertyLettingModel = /** Request body used to update details specific to lettings marketing on an existing property */\nz.object({instructed: /** The date the property was marked as to let */\nz.string().optional().nullable(), availableFrom: /** The date the property is next available from */\nz.string().optional().nullable(), availableTo: /** The date the property is available to */\nz.string().optional().nullable(), agreementSigned: /** The date the letting agreement between the landlord and agent was signed */\nz.string().optional().nullable(), rent: /** The rent being charged for the property */\nz.number().optional().nullable(), rentFrequency: /** The frequency at which rent will be collected (weekly/monthly/annually) */\nz.string().optional().nullable(), rentIncludes: /** Details of any bills that are included in the rent */\nz.string().optional().nullable(), furnishing: /** The furnishing state that the property can be offered in (furnished/unfurnished/partFurnished) */\nz.array(z.string().min(1)).optional().nullable(), term: /** The acceptable letting terms (short/long/any) */\nz.string().optional().nullable(), status: /** The current status of the let (valuation/toLet/toLetUnavailable/underOffer/underOfferUnavailable/arrangingTenancyUnavailable/arrangingTenancy/tenancyCurrentUnavailable/tenancyCurrent/tenancyFinished/tenancyCancelled/sold/letByOtherAgent/letPrivately/provisional/withdrawn) */\nz.string().optional().nullable(), agentRole: /** The role that the agent will be performing for this lettings property (managed/rentCollection/collectFirstPayment/collectRentToDate/lettingOnly/introducingTenant) */\nz.string().optional().nullable(), landlordId: /** The unique identifier of the landlord letting the property */\nz.string().optional().nullable(), brochureId: /** The unique identifier of the document used for the lettings brochure */\nz.string().optional().nullable(), worksOrderNote: /** A note to accompany any works orders created for the property */\nz.string().optional().nullable(), minimumTerm: /** Sets the minimum number of months the property can be let out for */\nz.number().int().optional().nullable(), managementFee: updatePropertyCommissionFeeModel.optional().nullable(), lettingFee: updatePropertyCommissionFeeModel.optional().nullable(), qualifier: /** The rent qualifier (rentOnApplication/askingRent) */\nz.string().optional().nullable(), utilities: updateUtilityModel.optional().nullable(), deposit: updatePropertyLettingsDepositModel.optional().nullable(), rentInsurance: updatePropertyLettingRentInsuranceModel.optional().nullable(), licencing: updatePropertyLettingLicencingModel.optional().nullable()});",
  "src/schemas/updateUtilityModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateUtilityModel = /** Representation of property details specific to utilities */\n{hasGas?: (/** A flag denoting whether or not the property has gas connected */\nboolean) | null | undefined, gasCompanyId?: (/** The unique identifier of the company supplying the gas to the property */\nstring) | null | undefined, gasMeterPoint?: (/** The gas meter point number */\nstring) | null | undefined, electricityCompanyId?: (/** The unique identifier of the company supplying the electricity to the property */\nstring) | null | undefined, electricityMeterPoint?: (/** The electricity meter point number */\nstring) | null | undefined, waterCompanyId?: (/** The unique identifier of the company supplying the water to the property */\nstring) | null | undefined, waterMeterPoint?: (/** The water meter point number */\nstring) | null | undefined, telephoneCompanyId?: (/** The unique identifier of the company supplying the telephone to the property */\nstring) | null | undefined, internetCompanyId?: (/** The unique identifier of the company supplying the internet to the property */\nstring) | null | undefined, cableTvCompanyId?: (/** The unique identifier of the company supplying the cable tv to the property */\nstring) | null | undefined};\nexport const updateUtilityModel = /** Representation of property details specific to utilities */\nz.object({hasGas: /** A flag denoting whether or not the property has gas connected */\nz.boolean().optional().nullable(), gasCompanyId: /** The unique identifier of the company supplying the gas to the property */\nz.string().optional().nullable(), gasMeterPoint: /** The gas meter point number */\nz.string().optional().nullable(), electricityCompanyId: /** The unique identifier of the company supplying the electricity to the property */\nz.string().optional().nullable(), electricityMeterPoint: /** The electricity meter point number */\nz.string().optional().nullable(), waterCompanyId: /** The unique identifier of the company supplying the water to the property */\nz.string().optional().nullable(), waterMeterPoint: /** The water meter point number */\nz.string().optional().nullable(), telephoneCompanyId: /** The unique identifier of the company supplying the telephone to the property */\nz.string().optional().nullable(), internetCompanyId: /** The unique identifier of the company supplying the internet to the property */\nz.string().optional().nullable(), cableTvCompanyId: /** The unique identifier of the company supplying the cable tv to the property */\nz.string().optional().nullable()});",
  "src/schemas/updatePropertyLettingsDepositModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdatePropertyLettingsDepositModel = /** Representation of a property details related to deposit */\n{type?: (/** The type of deposit (weeks/months/fixed) */\nstring) | null | undefined, amount?: (/** The deposit amount. This can be the number of weeks or months rent or a monetry amount based on the `type` */\nnumber) | null | undefined};\nexport const updatePropertyLettingsDepositModel = /** Representation of a property details related to deposit */\nz.object({type: /** The type of deposit (weeks/months/fixed) */\nz.string().optional().nullable(), amount: /** The deposit amount. This can be the number of weeks or months rent or a monetry amount based on the `type` */\nz.number().optional().nullable()});",
  "src/schemas/updatePropertyLettingRentInsuranceModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdatePropertyLettingRentInsuranceModel = /** Request body used to update details specific to rent insurance associated with a lettings property */\n{status?: (/** Status indicating whether or not rent protection insurance has been taken out (notAsked/cancelled/declined/quoted/taken) */\nstring) | null | undefined, referenceNumber?: (/** The reference number of the insurance policy when rent protection insurance has been taken out */\nstring) | null | undefined, start?: (/** The insurance policy start date */\nstring) | null | undefined, end?: (/** The insurance policy end date */\nstring) | null | undefined, cancelledReasonId?: (/** The identifier of the reason the insurance policy was cancelled, to be used in conjunction with the relevant configuration API endpoint */\nstring) | null | undefined, cancelledComment?: (/** A textual comment or note entered by the agent when an insurance policy was cancelled */\nstring) | null | undefined, autoRenew?: (/** Flag indicating whether or not the insurance policy should auto renew */\nboolean) | null | undefined};\nexport const updatePropertyLettingRentInsuranceModel = /** Request body used to update details specific to rent insurance associated with a lettings property */\nz.object({status: /** Status indicating whether or not rent protection insurance has been taken out (notAsked/cancelled/declined/quoted/taken) */\nz.string().optional().nullable(), referenceNumber: /** The reference number of the insurance policy when rent protection insurance has been taken out */\nz.string().optional().nullable(), start: /** The insurance policy start date */\nz.string().optional().nullable(), end: /** The insurance policy end date */\nz.string().optional().nullable(), cancelledReasonId: /** The identifier of the reason the insurance policy was cancelled, to be used in conjunction with the relevant configuration API endpoint */\nz.string().optional().nullable(), cancelledComment: /** A textual comment or note entered by the agent when an insurance policy was cancelled */\nz.string().optional().nullable(), autoRenew: /** Flag indicating whether or not the insurance policy should auto renew */\nz.boolean().optional().nullable()});",
  "src/schemas/updatePropertyLettingLicencingModel.generated.tsx": "import { UpdateLicenceApplicationModel, updateLicenceApplicationModel } from '@/schemas/updateLicenceApplicationModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type UpdatePropertyLettingLicencingModel = /** Representation of property details specific to property Licencing */\n{licenceRequired?: (/** A flag determining whether or not a licence is required to let the property. Typically required for houses of multiple occupancy (HMOs) */\nboolean) | null | undefined, licenceType?: (/** The type of licence (additional/mandatory/none/selective) */\nstring) | null | undefined, households?: (/** The number of households that the licence permits in the property */\nnumber) | null | undefined, occupants?: (/** The number of occupants that the licence permits in the property */\nnumber) | null | undefined, aboveCommercialPremises?: (/** A flag determining whether or not the property is above commercial premises */\nboolean) | null | undefined, application?: (UpdateLicenceApplicationModel) | null | undefined};\nexport const updatePropertyLettingLicencingModel = /** Representation of property details specific to property Licencing */\nz.object({licenceRequired: /** A flag determining whether or not a licence is required to let the property. Typically required for houses of multiple occupancy (HMOs) */\nz.boolean().optional().nullable(), licenceType: /** The type of licence (additional/mandatory/none/selective) */\nz.string().optional().nullable(), households: /** The number of households that the licence permits in the property */\nz.number().int().optional().nullable(), occupants: /** The number of occupants that the licence permits in the property */\nz.number().int().optional().nullable(), aboveCommercialPremises: /** A flag determining whether or not the property is above commercial premises */\nz.boolean().optional().nullable(), application: updateLicenceApplicationModel.optional().nullable()});",
  "src/schemas/updateLicenceApplicationModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateLicenceApplicationModel = /** Representation of property details specific to property licence application */\n{status?: (/** The status of the licence application (applied/granted/landlordApplying/notApplicable) */\nstring) | null | undefined, referenceNumber?: (/** The licence application reference number */\nstring) | null | undefined, date?: (/** The date the licence was applied for */\nDate) | null | undefined, granted?: (/** The date the licence application was granted */\nDate) | null | undefined, expiry?: (/** The date the licence will expire */\nDate) | null | undefined};\nexport const updateLicenceApplicationModel = /** Representation of property details specific to property licence application */\nz.object({status: /** The status of the licence application (applied/granted/landlordApplying/notApplicable) */\nz.string().optional().nullable(), referenceNumber: /** The licence application reference number */\nz.string().optional().nullable(), date: /** The date the licence was applied for */\nz.string().pipe( z.coerce.date() ).optional().nullable(), granted: /** The date the licence application was granted */\nz.string().pipe( z.coerce.date() ).optional().nullable(), expiry: /** The date the licence will expire */\nz.string().pipe( z.coerce.date() ).optional().nullable()});",
  "src/schemas/updatePropertyRegionalModel.generated.tsx": "import { CreateIrelandPropertyModel, createIrelandPropertyModel } from '@/schemas/createIrelandPropertyModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type UpdatePropertyRegionalModel = /** Request body used to set region specific property details. Child models are named based on the ISO3166 country code that the data inside the model relates to */\n{irl?: (CreateIrelandPropertyModel) | null | undefined};\nexport const updatePropertyRegionalModel = /** Request body used to set region specific property details. Child models are named based on the ISO3166 country code that the data inside the model relates to */\nz.object({irl: createIrelandPropertyModel.optional().nullable()});",
  "src/schemas/updatePropertyRuralModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdatePropertyRuralModel = /** Request body used to set details specific to rural properties. */\n{buildingsDescription?: (/** Details of the building associated with the property. */\nstring) | null | undefined, landDescription?: (/** Details of the land associated with the property. */\nstring) | null | undefined};\nexport const updatePropertyRuralModel = /** Request body used to set details specific to rural properties. */\nz.object({buildingsDescription: /** Details of the building associated with the property. */\nz.string().optional().nullable(), landDescription: /** Details of the land associated with the property. */\nz.string().optional().nullable()});",
  "src/sections/Properties/services/useGetApiPropertiesIdCertificatesCertificateId.generated.ts": "import { getApiPropertiesIdCertificatesCertificateIdResponse } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiPropertiesIdCertificatesCertificateIdFnArgs = {id: string, certificateId: string};\nexport const getApiPropertiesIdCertificatesCertificateIdFn = async ({id, certificateId}: GetApiPropertiesIdCertificatesCertificateIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/properties/${id}/certificates/${certificateId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiPropertiesIdCertificatesCertificateIdResponse.parse(data)\n    };\nexport const useGetApiPropertiesIdCertificatesCertificateId = ({id, certificateId}: GetApiPropertiesIdCertificatesCertificateIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Properties', id, certificateId],\n        queryFn: () => getApiPropertiesIdCertificatesCertificateIdFn({id, certificateId})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Properties/services/usePatchApiPropertiesIdCertificatesCertificateId.generated.ts": "import { UpdateCertificateModel } from '@/schemas/updateCertificateModel.generated.tsx'\nimport { patchApiPropertiesIdCertificatesCertificateIdResponse } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type PatchApiPropertiesIdCertificatesCertificateIdFnArgs = {'If-Match'?: string, id: string, certificateId: string, body: UpdateCertificateModel};\nexport const patchApiPropertiesIdCertificatesCertificateIdFn = async ({'If-Match': ifMatch, id, certificateId, body}: PatchApiPropertiesIdCertificatesCertificateIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({'If-Match': ifMatch})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/properties/${id}/certificates/${certificateId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PATCH',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return patchApiPropertiesIdCertificatesCertificateIdResponse.parse(data)\n    };\nexport const usePatchApiPropertiesIdCertificatesCertificateId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: patchApiPropertiesIdCertificatesCertificateIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Properties']})\n        }\n      })\n    };",
  "src/schemas/updateCertificateModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateCertificateModel = /** Request body used to update an existing certificate */\n{start?: (/** The certificate's start date */\nDate) | null | undefined, expiry?: (/** The certificate's expiry date */\nDate) | null | undefined, companyId?: (/** The unique identifier of the company */\nstring) | null | undefined, notes?: (/** Any general notes regarding the certificate */\nstring) | null | undefined, referenceNumber?: (/** The certificate's reference number */\nstring) | null | undefined};\nexport const updateCertificateModel = /** Request body used to update an existing certificate */\nz.object({start: /** The certificate's start date */\nz.string().pipe( z.coerce.date() ).optional().nullable(), expiry: /** The certificate's expiry date */\nz.string().pipe( z.coerce.date() ).optional().nullable(), companyId: /** The unique identifier of the company */\nz.string().optional().nullable(), notes: /** Any general notes regarding the certificate */\nz.string().optional().nullable(), referenceNumber: /** The certificate's reference number */\nz.string().optional().nullable()});",
  "src/sections/Properties/services/useGetApiPropertiesIdCertificatesResponsibilities.generated.ts": "import { getApiPropertiesIdCertificatesResponsibilitiesResponse } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiPropertiesIdCertificatesResponsibilitiesFnArgs = {id: string};\nexport const getApiPropertiesIdCertificatesResponsibilitiesFn = async ({id}: GetApiPropertiesIdCertificatesResponsibilitiesFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/properties/${id}/certificates/responsibilities${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiPropertiesIdCertificatesResponsibilitiesResponse.parse(data)\n    };\nexport const useGetApiPropertiesIdCertificatesResponsibilities = ({id}: GetApiPropertiesIdCertificatesResponsibilitiesFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Properties', id],\n        queryFn: () => getApiPropertiesIdCertificatesResponsibilitiesFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/schemas/propertyCertificateResponsibilitiesModel.generated.tsx": "import { z } from 'zod'\nimport { certificateResponsiblePartyModel, CertificateResponsiblePartyModel } from '@/schemas/certificateResponsiblePartyModel.generated.tsx'\n\nexport const propertyCertificateResponsibilitiesModel = /** Representation of certificate responsibilities configured for a property */\nz.object({id: /** The id of the property to which the configured certificate responsibilities apply */\nz.string().optional().nullable(), created: /** The date and time on which the property was created */\nz.string().pipe( z.coerce.date() ).optional().nullable(), modified: /** The date and time on which the property was last modified */\nz.string().pipe( z.coerce.date() ).optional().nullable(), responsibleParties: /** The configured certificate responsibilities */\nz.array(certificateResponsiblePartyModel).optional().nullable(), _eTag: /** The ETag for the current version of the property. Used for managing update concurrency */\nz.string().optional().nullable()});\nexport type PropertyCertificateResponsibilitiesModel = /** Representation of certificate responsibilities configured for a property */\n{id?: (/** The id of the property to which the configured certificate responsibilities apply */\nstring) | null | undefined, created?: (/** The date and time on which the property was created */\nDate) | null | undefined, modified?: (/** The date and time on which the property was last modified */\nDate) | null | undefined, responsibleParties?: (/** The configured certificate responsibilities */\nArray<CertificateResponsiblePartyModel>) | null | undefined, _eTag?: (/** The ETag for the current version of the property. Used for managing update concurrency */\nstring) | null | undefined};",
  "src/schemas/certificateResponsiblePartyModel.generated.tsx": "import { z } from 'zod'\n\nexport const certificateResponsiblePartyModel = /** Record describing the responsible party for a given type of certificate within a property entry */\nz.object({typeId: /** Identifier for the type of certificate for which the party is responsible */\nz.string().optional().nullable(), responsibleParty: /** The party responsible for the specified certificate type (landlord/agent/notRequired/notSet) */\nz.string().optional().nullable()});\nexport type CertificateResponsiblePartyModel = /** Record describing the responsible party for a given type of certificate within a property entry */\n{typeId?: (/** Identifier for the type of certificate for which the party is responsible */\nstring) | null | undefined, responsibleParty?: (/** The party responsible for the specified certificate type (landlord/agent/notRequired/notSet) */\nstring) | null | undefined};",
  "src/sections/Properties/services/usePatchApiPropertiesIdCertificatesResponsibilities.generated.ts": "import { UpdateCertificateResponsibilitiesModel } from '@/schemas/updateCertificateResponsibilitiesModel.generated.tsx'\nimport { patchApiPropertiesIdCertificatesResponsibilitiesResponse } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type PatchApiPropertiesIdCertificatesResponsibilitiesFnArgs = {'If-Match'?: string, id: string, body: UpdateCertificateResponsibilitiesModel};\nexport const patchApiPropertiesIdCertificatesResponsibilitiesFn = async ({'If-Match': ifMatch, id, body}: PatchApiPropertiesIdCertificatesResponsibilitiesFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({'If-Match': ifMatch})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/properties/${id}/certificates/responsibilities${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PATCH',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return patchApiPropertiesIdCertificatesResponsibilitiesResponse.parse(data)\n    };\nexport const usePatchApiPropertiesIdCertificatesResponsibilities = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: patchApiPropertiesIdCertificatesResponsibilitiesFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Properties']})\n        }\n      })\n    };",
  "src/schemas/updateCertificateResponsibilitiesModel.generated.tsx": "import { UpdateCertificateResponsiblePartyModel, updateCertificateResponsiblePartyModel } from '@/schemas/updateCertificateResponsiblePartyModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type UpdateCertificateResponsibilitiesModel = /** Object containing a collection of certificate type to responsible party mappings */\n{responsibleParties?: (/** A collection of certificate type to responsible party mappings */\nArray<UpdateCertificateResponsiblePartyModel>) | null | undefined};\nexport const updateCertificateResponsibilitiesModel = /** Object containing a collection of certificate type to responsible party mappings */\nz.object({responsibleParties: /** A collection of certificate type to responsible party mappings */\nz.array(updateCertificateResponsiblePartyModel).optional().nullable()});",
  "src/schemas/updateCertificateResponsiblePartyModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateCertificateResponsiblePartyModel = /** Record describing the responsible party for a given type of certificate within a property entry */\n{typeId?: (/** Identifier for the type of certificate for which the party is responsible */\nstring) | null | undefined, responsibleParty?: (/** The party responsible for the specified certificate type (landlord/agent/notRequired/notSet) */\nstring) | null | undefined};\nexport const updateCertificateResponsiblePartyModel = /** Record describing the responsible party for a given type of certificate within a property entry */\nz.object({typeId: /** Identifier for the type of certificate for which the party is responsible */\nz.string().optional().nullable(), responsibleParty: /** The party responsible for the specified certificate type (landlord/agent/notRequired/notSet) */\nz.string().optional().nullable()});",
  "src/sections/Properties/services/useGetApiPropertiesIdKeysKeyId.generated.ts": "import { getApiPropertiesIdKeysKeyIdResponse } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiPropertiesIdKeysKeyIdFnArgs = {id: string, keyId: string};\nexport const getApiPropertiesIdKeysKeyIdFn = async ({id, keyId}: GetApiPropertiesIdKeysKeyIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/properties/${id}/keys/${keyId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiPropertiesIdKeysKeyIdResponse.parse(data)\n    };\nexport const useGetApiPropertiesIdKeysKeyId = ({id, keyId}: GetApiPropertiesIdKeysKeyIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Properties', id, keyId],\n        queryFn: () => getApiPropertiesIdKeysKeyIdFn({id, keyId})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Properties/services/useGetApiPropertiesIdKeysKeyIdMovementsMovementId.generated.ts": "import { getApiPropertiesIdKeysKeyIdMovementsMovementIdResponse } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiPropertiesIdKeysKeyIdMovementsMovementIdFnArgs = {id: string, keyId: string, movementId: string};\nexport const getApiPropertiesIdKeysKeyIdMovementsMovementIdFn = async ({id, keyId, movementId}: GetApiPropertiesIdKeysKeyIdMovementsMovementIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/properties/${id}/keys/${keyId}/movements/${movementId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiPropertiesIdKeysKeyIdMovementsMovementIdResponse.parse(data)\n    };\nexport const useGetApiPropertiesIdKeysKeyIdMovementsMovementId = ({id, keyId, movementId}: GetApiPropertiesIdKeysKeyIdMovementsMovementIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Properties', id, keyId, movementId],\n        queryFn: () => getApiPropertiesIdKeysKeyIdMovementsMovementIdFn({id, keyId, movementId})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Properties/services/useUpdateApiPropertiesIdKeysKeyIdMovementsMovementId.generated.ts": "import { CheckInKeyModel } from '@/schemas/checkInKeyModel.generated.tsx'\nimport { updateApiPropertiesIdKeysKeyIdMovementsMovementIdResponse } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type UpdateApiPropertiesIdKeysKeyIdMovementsMovementIdFnArgs = {id: string, keyId: string, movementId: string, body: CheckInKeyModel};\nexport const updateApiPropertiesIdKeysKeyIdMovementsMovementIdFn = async ({id, keyId, movementId, body}: UpdateApiPropertiesIdKeysKeyIdMovementsMovementIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/properties/${id}/keys/${keyId}/movements/${movementId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PUT',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return updateApiPropertiesIdKeysKeyIdMovementsMovementIdResponse.parse(data)\n    };\nexport const useUpdateApiPropertiesIdKeysKeyIdMovementsMovementId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: updateApiPropertiesIdKeysKeyIdMovementsMovementIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Properties']})\n        }\n      })\n    };",
  "src/schemas/checkInKeyModel.generated.tsx": "import { z } from 'zod'\n\nexport type CheckInKeyModel = /** Request body used for checking in a key */\n{checkInNegotiatorId?: (/** The unique identifier of the negotiator who performed the key check in */\nstring) | null | undefined};\nexport const checkInKeyModel = /** Request body used for checking in a key */\nz.object({checkInNegotiatorId: /** The unique identifier of the negotiator who performed the key check in */\nz.string().optional().nullable()});",
  "src/sections/Properties/services/useGetApiPropertiesIdChecksCheckId.generated.ts": "import { getApiPropertiesIdChecksCheckIdResponse } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiPropertiesIdChecksCheckIdFnArgs = {id: string, checkId: string};\nexport const getApiPropertiesIdChecksCheckIdFn = async ({id, checkId}: GetApiPropertiesIdChecksCheckIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/properties/${id}/checks/${checkId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiPropertiesIdChecksCheckIdResponse.parse(data)\n    };\nexport const useGetApiPropertiesIdChecksCheckId = ({id, checkId}: GetApiPropertiesIdChecksCheckIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Properties', id, checkId],\n        queryFn: () => getApiPropertiesIdChecksCheckIdFn({id, checkId})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Properties/services/useDeleteApiPropertiesIdChecksCheckId.generated.ts": "import { deleteApiPropertiesIdChecksCheckIdResponse } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type DeleteApiPropertiesIdChecksCheckIdFnArgs = {id: string, checkId: string};\nexport const deleteApiPropertiesIdChecksCheckIdFn = async ({id, checkId}: DeleteApiPropertiesIdChecksCheckIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/properties/${id}/checks/${checkId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'DELETE',\n          \n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return deleteApiPropertiesIdChecksCheckIdResponse.parse(data)\n    };\nexport const useDeleteApiPropertiesIdChecksCheckId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: deleteApiPropertiesIdChecksCheckIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Properties']})\n        }\n      })\n    };",
  "src/sections/Properties/services/usePatchApiPropertiesIdChecksCheckId.generated.ts": "import { UpdatePropertyCheckModel } from '@/schemas/updatePropertyCheckModel.generated.tsx'\nimport { patchApiPropertiesIdChecksCheckIdResponse } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type PatchApiPropertiesIdChecksCheckIdFnArgs = {'If-Match'?: string, id: string, checkId: string, body: UpdatePropertyCheckModel};\nexport const patchApiPropertiesIdChecksCheckIdFn = async ({'If-Match': ifMatch, id, checkId, body}: PatchApiPropertiesIdChecksCheckIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({'If-Match': ifMatch})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/properties/${id}/checks/${checkId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PATCH',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return patchApiPropertiesIdChecksCheckIdResponse.parse(data)\n    };\nexport const usePatchApiPropertiesIdChecksCheckId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: patchApiPropertiesIdChecksCheckIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Properties']})\n        }\n      })\n    };",
  "src/schemas/updatePropertyCheckModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdatePropertyCheckModel = /** Model for the update of an existing check */\n{status?: (/** The status of the check (needed/notNeeded/arranging/completed) */\nstring) | null | undefined};\nexport const updatePropertyCheckModel = /** Model for the update of an existing check */\nz.object({status: /** The status of the check (needed/notNeeded/arranging/completed) */\nz.string().optional().nullable()});",
  "src/sections/Properties/services/useGetApiPropertiesIdAppraisalsAppraisalId.generated.ts": "import { getApiPropertiesIdAppraisalsAppraisalIdResponse } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiPropertiesIdAppraisalsAppraisalIdFnArgs = {id: string, appraisalId: string};\nexport const getApiPropertiesIdAppraisalsAppraisalIdFn = async ({id, appraisalId}: GetApiPropertiesIdAppraisalsAppraisalIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/properties/${id}/appraisals/${appraisalId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiPropertiesIdAppraisalsAppraisalIdResponse.parse(data)\n    };\nexport const useGetApiPropertiesIdAppraisalsAppraisalId = ({id, appraisalId}: GetApiPropertiesIdAppraisalsAppraisalIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Properties', id, appraisalId],\n        queryFn: () => getApiPropertiesIdAppraisalsAppraisalIdFn({id, appraisalId})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Properties/services/usePatchApiPropertiesIdAppraisalsAppraisalId.generated.ts": "import { UpdatePropertyAppraisalModel } from '@/schemas/updatePropertyAppraisalModel.generated.tsx'\nimport { patchApiPropertiesIdAppraisalsAppraisalIdResponse } from '@/sections/Properties/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type PatchApiPropertiesIdAppraisalsAppraisalIdFnArgs = {'If-Match'?: string, id: string, appraisalId: string, body: UpdatePropertyAppraisalModel};\nexport const patchApiPropertiesIdAppraisalsAppraisalIdFn = async ({'If-Match': ifMatch, id, appraisalId, body}: PatchApiPropertiesIdAppraisalsAppraisalIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({'If-Match': ifMatch})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/properties/${id}/appraisals/${appraisalId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PATCH',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return patchApiPropertiesIdAppraisalsAppraisalIdResponse.parse(data)\n    };\nexport const usePatchApiPropertiesIdAppraisalsAppraisalId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: patchApiPropertiesIdAppraisalsAppraisalIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Properties']})\n        }\n      })\n    };",
  "src/schemas/updatePropertyAppraisalModel.generated.tsx": "import { PropertyCommissionFeeModel, propertyCommissionFeeModel } from '@/schemas/propertyCommissionFeeModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type UpdatePropertyAppraisalModel = /** Model for the creation of a new property appraisal */\n{companyId?: (/** Unique identifier of the appraising company */\nstring) | null | undefined, date?: (/** The date of the appraisal */\nDate) | null | undefined, price?: (/** The appraisal value */\nnumber) | null | undefined, fee?: (PropertyCommissionFeeModel) | null | undefined, notes?: (/** Free-text notes associated with the appraisal */\nstring) | null | undefined};\nexport const updatePropertyAppraisalModel = /** Model for the creation of a new property appraisal */\nz.object({companyId: /** Unique identifier of the appraising company */\nz.string().optional().nullable(), date: /** The date of the appraisal */\nz.string().pipe( z.coerce.date() ).optional().nullable(), price: /** The appraisal value */\nz.number().int().optional().nullable(), fee: propertyCommissionFeeModel.optional().nullable(), notes: /** Free-text notes associated with the appraisal */\nz.string().optional().nullable()});",
  "src/sections/PropertyImages/services/useGetApiPropertyImagesId.generated.ts": "import { getApiPropertyImagesIdResponse } from '@/sections/PropertyImages/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiPropertyImagesIdFnArgs = {id: string, embed?: (Array<'property'>) | null | undefined};\nexport const getApiPropertyImagesIdFn = async ({id, embed}: GetApiPropertyImagesIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/propertyImages/${id}${querySerialiser({args:{embed}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiPropertyImagesIdResponse.parse(data)\n    };\nexport const useGetApiPropertyImagesId = ({id, embed}: GetApiPropertyImagesIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['PropertyImages', id, embed],\n        queryFn: () => getApiPropertyImagesIdFn({id, embed})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/PropertyImages/services/useDeleteApiPropertyImagesId.generated.ts": "import { deleteApiPropertyImagesIdResponse } from '@/sections/PropertyImages/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type DeleteApiPropertyImagesIdFnArgs = {id: string};\nexport const deleteApiPropertyImagesIdFn = async ({id}: DeleteApiPropertyImagesIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/propertyImages/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'DELETE',\n          \n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return deleteApiPropertyImagesIdResponse.parse(data)\n    };\nexport const useDeleteApiPropertyImagesId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: deleteApiPropertyImagesIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['PropertyImages']})\n        }\n      })\n    };",
  "src/sections/PropertyImages/services/usePatchApiPropertyImagesId.generated.ts": "import { UpdatePropertyImageModel } from '@/schemas/updatePropertyImageModel.generated.tsx'\nimport { patchApiPropertyImagesIdResponse } from '@/sections/PropertyImages/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type PatchApiPropertyImagesIdFnArgs = {'If-Match'?: string, id: string, body: UpdatePropertyImageModel};\nexport const patchApiPropertyImagesIdFn = async ({'If-Match': ifMatch, id, body}: PatchApiPropertyImagesIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({'If-Match': ifMatch})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/propertyImages/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PATCH',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return patchApiPropertyImagesIdResponse.parse(data)\n    };\nexport const usePatchApiPropertyImagesId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: patchApiPropertyImagesIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['PropertyImages']})\n        }\n      })\n    };",
  "src/schemas/updatePropertyImageModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdatePropertyImageModel = /** Request body used to update an existing property image */\n{caption?: (/** The image caption */\nstring) | null | undefined, type?: (/** The type of image (photograph/floorPlan/epc/map) */\nstring) | null | undefined};\nexport const updatePropertyImageModel = /** Request body used to update an existing property image */\nz.object({caption: /** The image caption */\nz.string().optional().nullable(), type: /** The type of image (photograph/floorPlan/epc/map) */\nz.string().optional().nullable()});",
  "src/sections/Referrals/services/useGetApiReferralsId.generated.ts": "import { getApiReferralsIdResponse } from '@/sections/Referrals/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiReferralsIdFnArgs = {id: string, embed?: (Array<'applicant' | 'contact' | 'negotiator' | 'property' | 'type'>) | null | undefined};\nexport const getApiReferralsIdFn = async ({id, embed}: GetApiReferralsIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/referrals/${id}${querySerialiser({args:{embed}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiReferralsIdResponse.parse(data)\n    };\nexport const useGetApiReferralsId = ({id, embed}: GetApiReferralsIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Referrals', id, embed],\n        queryFn: () => getApiReferralsIdFn({id, embed})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Referrals/services/usePatchApiReferralsId.generated.ts": "import { UpdateReferralModel } from '@/schemas/updateReferralModel.generated.tsx'\nimport { patchApiReferralsIdResponse } from '@/sections/Referrals/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type PatchApiReferralsIdFnArgs = {'If-Match'?: string, id: string, body: UpdateReferralModel};\nexport const patchApiReferralsIdFn = async ({'If-Match': ifMatch, id, body}: PatchApiReferralsIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({'If-Match': ifMatch})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/referrals/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PATCH',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return patchApiReferralsIdResponse.parse(data)\n    };\nexport const usePatchApiReferralsId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: patchApiReferralsIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Referrals']})\n        }\n      })\n    };",
  "src/schemas/updateReferralModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateReferralModel = /** Update Referral Model */\n{status?: (/** The status of the referral (sent/succeeded/cancelled/failed/paid/declined/inProgress) */\nstring) | null | undefined, amount?: (/** The amount paid to the agent for the referral */\nnumber) | null | undefined, metadata?: (/** App specific metadata to set against the referral */\nRecord<string, Record<string, never>>) | null | undefined};\nexport const updateReferralModel = /** Update Referral Model */\nz.object({status: /** The status of the referral (sent/succeeded/cancelled/failed/paid/declined/inProgress) */\nz.string().optional().nullable(), amount: /** The amount paid to the agent for the referral */\nz.number().optional().nullable(), metadata: /** App specific metadata to set against the referral */\nz.record(z.string(), z.object({})).optional().nullable()});",
  "src/sections/Referrals/services/useGetApiReferralsTypesId.generated.ts": "import { getApiReferralsTypesIdResponse } from '@/sections/Referrals/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiReferralsTypesIdFnArgs = {id: string};\nexport const getApiReferralsTypesIdFn = async ({id}: GetApiReferralsTypesIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/referrals/types/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiReferralsTypesIdResponse.parse(data)\n    };\nexport const useGetApiReferralsTypesId = ({id}: GetApiReferralsTypesIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Referrals', id],\n        queryFn: () => getApiReferralsTypesIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/RestHooks/services/useGetApiResthooksId.generated.ts": "import { getApiResthooksIdResponse } from '@/sections/RestHooks/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiResthooksIdFnArgs = {id: string};\nexport const getApiResthooksIdFn = async ({id}: GetApiResthooksIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/resthooks/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiResthooksIdResponse.parse(data)\n    };\nexport const useGetApiResthooksId = ({id}: GetApiResthooksIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['RestHooks', id],\n        queryFn: () => getApiResthooksIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/RestHooks/services/useUpdateApiResthooksId.generated.ts": "import { UpdateWebhookModel } from '@/schemas/updateWebhookModel.generated.tsx'\nimport { updateApiResthooksIdResponse } from '@/sections/RestHooks/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type UpdateApiResthooksIdFnArgs = {id: string, body: UpdateWebhookModel};\nexport const updateApiResthooksIdFn = async ({id, body}: UpdateApiResthooksIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/resthooks/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PUT',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return updateApiResthooksIdResponse.parse(data)\n    };\nexport const useUpdateApiResthooksId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: updateApiResthooksIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['RestHooks']})\n        }\n      })\n    };",
  "src/schemas/updateWebhookModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateWebhookModel = /** Request body used to update a webhook subscription */\n{url: /** The url where the payload associated with the webhook should be sent to */\nstring, description?: (/** A short description associated with the webhook (ie a friendly name or label) */\nstring) | null | undefined, topicIds?: (/** The identifiers of the topics the subscription is associated with */\nArray<string>) | null | undefined, active?: (/** Flag denoting whether or not the webhook is active and ready to receive data */\nboolean) | null | undefined, ignoreEtagOnlyChanges?: (/** Flag denoting whether or events that only contain changes to etags and/or modified dates are emitted\r\nPass true to disable emitting of these events */\nboolean) | null | undefined};\nexport const updateWebhookModel = /** Request body used to update a webhook subscription */\nz.object({url: /** The url where the payload associated with the webhook should be sent to */\nz.string().min(1), description: /** A short description associated with the webhook (ie a friendly name or label) */\nz.string().optional().nullable(), topicIds: /** The identifiers of the topics the subscription is associated with */\nz.array(z.string().min(1)).optional().nullable(), active: /** Flag denoting whether or not the webhook is active and ready to receive data */\nz.boolean().optional().nullable(), ignoreEtagOnlyChanges: /** Flag denoting whether or events that only contain changes to etags and/or modified dates are emitted\r\nPass true to disable emitting of these events */\nz.boolean().optional().nullable()});",
  "src/sections/RestHooks/services/useDeleteApiResthooksId.generated.ts": "import { deleteApiResthooksIdResponse } from '@/sections/RestHooks/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type DeleteApiResthooksIdFnArgs = {id: string};\nexport const deleteApiResthooksIdFn = async ({id}: DeleteApiResthooksIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/resthooks/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'DELETE',\n          \n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return deleteApiResthooksIdResponse.parse(data)\n    };\nexport const useDeleteApiResthooksId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: deleteApiResthooksIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['RestHooks']})\n        }\n      })\n    };",
  "src/sections/Sources/services/useGetApiSourcesId.generated.ts": "import { getApiSourcesIdResponse } from '@/sections/Sources/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiSourcesIdFnArgs = {id: string};\nexport const getApiSourcesIdFn = async ({id}: GetApiSourcesIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/sources/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiSourcesIdResponse.parse(data)\n    };\nexport const useGetApiSourcesId = ({id}: GetApiSourcesIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Sources', id],\n        queryFn: () => getApiSourcesIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Sources/services/usePatchApiSourcesId.generated.ts": "import { UpdateSourceModel } from '@/schemas/updateSourceModel.generated.tsx'\nimport { patchApiSourcesIdResponse } from '@/sections/Sources/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type PatchApiSourcesIdFnArgs = {'If-Match'?: string, id: string, body: UpdateSourceModel};\nexport const patchApiSourcesIdFn = async ({'If-Match': ifMatch, id, body}: PatchApiSourcesIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({'If-Match': ifMatch})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/sources/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PATCH',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return patchApiSourcesIdResponse.parse(data)\n    };\nexport const usePatchApiSourcesId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: patchApiSourcesIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Sources']})\n        }\n      })\n    };",
  "src/schemas/updateSourceModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateSourceModel = /** Request body used to update an existing source of business */\n{name?: (/** The name of the source or advertising publication */\nstring) | null | undefined, type?: (/** The type of the source (source/advertisement) */\nstring) | null | undefined, officeIds?: (/** A collection of the unique identifiers of offices that regularly get business from the source */\nArray<string>) | null | undefined, departmentIds?: (/** A collection of unique identifiers of departments that regularly get business from the source */\nArray<string>) | null | undefined};\nexport const updateSourceModel = /** Request body used to update an existing source of business */\nz.object({name: /** The name of the source or advertising publication */\nz.string().optional().nullable(), type: /** The type of the source (source/advertisement) */\nz.string().optional().nullable(), officeIds: /** A collection of the unique identifiers of offices that regularly get business from the source */\nz.array(z.string().min(1)).optional().nullable(), departmentIds: /** A collection of unique identifiers of departments that regularly get business from the source */\nz.array(z.string().min(1)).optional().nullable()});",
  "src/sections/Tasks/services/useGetApiTasksId.generated.ts": "import { getApiTasksIdResponse } from '@/sections/Tasks/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiTasksIdFnArgs = {id: string, embed?: (Array<'applicant' | 'contact' | 'landlord' | 'property' | 'tenancy' | 'type'>) | null | undefined};\nexport const getApiTasksIdFn = async ({id, embed}: GetApiTasksIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/tasks/${id}${querySerialiser({args:{embed}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiTasksIdResponse.parse(data)\n    };\nexport const useGetApiTasksId = ({id, embed}: GetApiTasksIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Tasks', id, embed],\n        queryFn: () => getApiTasksIdFn({id, embed})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Tasks/services/usePatchApiTasksId.generated.ts": "import { UpdateTaskModel } from '@/schemas/updateTaskModel.generated.tsx'\nimport { patchApiTasksIdResponse } from '@/sections/Tasks/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type PatchApiTasksIdFnArgs = {'If-Match'?: string, id: string, body: UpdateTaskModel};\nexport const patchApiTasksIdFn = async ({'If-Match': ifMatch, id, body}: PatchApiTasksIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({'If-Match': ifMatch})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/tasks/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PATCH',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return patchApiTasksIdResponse.parse(data)\n    };\nexport const usePatchApiTasksId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: patchApiTasksIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Tasks']})\n        }\n      })\n    };",
  "src/schemas/updateTaskModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateTaskModel = /** Request body used to update an existing task, which can also be an internal message */\n{activates?: (/** The date the task becomes active (Required when 'TypeId' is given) */\nstring) | null | undefined, completed?: (/** The date the task was completed */\nstring) | null | undefined, typeId?: (/** The unique identifier of the task type */\nstring) | null | undefined, senderId?: (/** The unique identifer of the negotiator that created the task */\nstring) | null | undefined, text?: (/** The textual contents of the task or message */\nstring) | null | undefined, landlordId?: (/** The unique identifier of the landlord the task is associated to */\nstring) | null | undefined, propertyId?: (/** The unique identifier of the property the task is associated to */\nstring) | null | undefined, applicantId?: (/** The unique identifier of the applicant the task is associated to */\nstring) | null | undefined, tenancyId?: (/** The unique identifier of the tenancy the task is associated to */\nstring) | null | undefined, contactId?: (/** The unique identifier of the contact the task is associated to */\nstring) | null | undefined, recipientId?: (/** The unique identifier of the negotiator or office the task is being sent to */\nstring) | null | undefined, recipientType?: (/** The type of the recipient (office/negotiator) */\nstring) | null | undefined, metadata?: (/** App specific metadata that has been set against the task */\nRecord<string, Record<string, never>>) | null | undefined};\nexport const updateTaskModel = /** Request body used to update an existing task, which can also be an internal message */\nz.object({activates: /** The date the task becomes active (Required when 'TypeId' is given) */\nz.string().optional().nullable(), completed: /** The date the task was completed */\nz.string().optional().nullable(), typeId: /** The unique identifier of the task type */\nz.string().optional().nullable(), senderId: /** The unique identifer of the negotiator that created the task */\nz.string().optional().nullable(), text: /** The textual contents of the task or message */\nz.string().optional().nullable(), landlordId: /** The unique identifier of the landlord the task is associated to */\nz.string().optional().nullable(), propertyId: /** The unique identifier of the property the task is associated to */\nz.string().optional().nullable(), applicantId: /** The unique identifier of the applicant the task is associated to */\nz.string().optional().nullable(), tenancyId: /** The unique identifier of the tenancy the task is associated to */\nz.string().optional().nullable(), contactId: /** The unique identifier of the contact the task is associated to */\nz.string().optional().nullable(), recipientId: /** The unique identifier of the negotiator or office the task is being sent to */\nz.string().optional().nullable(), recipientType: /** The type of the recipient (office/negotiator) */\nz.string().optional().nullable(), metadata: /** App specific metadata that has been set against the task */\nz.record(z.string(), z.object({})).optional().nullable()});",
  "src/sections/Tenancies/services/useGetApiTenanciesId.generated.ts": "import { getApiTenanciesIdResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiTenanciesIdFnArgs = {id: string, embed?: (Array<'appointments' | 'applicant' | 'extensions' | 'documents' | 'negotiator' | 'property' | 'source' | 'tasks' | 'type'>) | null | undefined};\nexport const getApiTenanciesIdFn = async ({id, embed}: GetApiTenanciesIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${id}${querySerialiser({args:{embed}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiTenanciesIdResponse.parse(data)\n    };\nexport const useGetApiTenanciesId = ({id, embed}: GetApiTenanciesIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Tenancies', id, embed],\n        queryFn: () => getApiTenanciesIdFn({id, embed})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Tenancies/services/usePatchApiTenanciesId.generated.ts": "import { UpdateTenancyModel } from '@/schemas/updateTenancyModel.generated.tsx'\nimport { patchApiTenanciesIdResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type PatchApiTenanciesIdFnArgs = {'If-Match'?: string, id: string, body: UpdateTenancyModel};\nexport const patchApiTenanciesIdFn = async ({'If-Match': ifMatch, id, body}: PatchApiTenanciesIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({'If-Match': ifMatch})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PATCH',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return patchApiTenanciesIdResponse.parse(data)\n    };\nexport const usePatchApiTenanciesId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: patchApiTenanciesIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Tenancies']})\n        }\n      })\n    };",
  "src/schemas/updateTenancyModel.generated.tsx": "import { UpdateTenancySourceModel, updateTenancySourceModel } from '@/schemas/updateTenancySourceModel.generated.tsx'\nimport { UpdateTenancyDepositModel, updateTenancyDepositModel } from '@/schemas/updateTenancyDepositModel.generated.tsx'\nimport { UpdateTenancyLettingFeeModel, updateTenancyLettingFeeModel } from '@/schemas/updateTenancyLettingFeeModel.generated.tsx'\nimport { UpdateTenancyManagementFeeModel, updateTenancyManagementFeeModel } from '@/schemas/updateTenancyManagementFeeModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type UpdateTenancyModel = /** Request body used to update an existing Tenancy */\n{startDate?: (/** The start date of the tenancy */\nstring) | null | undefined, endDate?: (/** The end date of the tenancy */\nstring) | null | undefined, status?: (/** The current status of the tenancy (offerPending/offerWithdrawn/offerRejected/arranging/current/finished/cancelled) */\nstring) | null | undefined, agentRole?: (/** The role that the agent is performing for the tenancy (managed/rentCollection/collectFirstPayment/collectRentToDate/lettingOnly/introducingTenant) */\nstring) | null | undefined, rent?: (/** The amount of rent required, returned in relation to the collection frequency */\nnumber) | null | undefined, rentFrequency?: (/** The rent collection frequency (weekly/monthly/annually) */\nstring) | null | undefined, endDateConfirmed?: (/** Flag for end date confirmation */\nboolean) | null | undefined, isPeriodic?: (/** A flag determining whether or not the tenancy has been extended indefinitely */\nboolean) | null | undefined, typeId?: (/** The unique identifier of the type of tenancy */\nstring) | null | undefined, negotiatorId?: (/** The unique identifier of the negotiator who is managing the tenancy */\nstring) | null | undefined, source?: (UpdateTenancySourceModel) | null | undefined, rentInstalmentsFrequency?: (/** The frequency of rental instalment payments (weekly/fortnightly/monthly/quarterly/halfYearly/yearly/every28Days/other) */\nstring) | null | undefined, rentInstalmentsAmount?: (/** The amount due for each rent instalment (where specified) */\nnumber) | null | undefined, rentInstalmentsStart?: (/** The date that the first instalment is due */\nstring) | null | undefined, meterReadingGas?: (/** The recorded utility reading for the gas meter */\nstring) | null | undefined, meterReadingGasLastRead?: (/** Date of when the reading of gas utility was last recorded */\nstring) | null | undefined, meterReadingElectricity?: (/** The recorded utility reading for the electricity meter */\nstring) | null | undefined, meterReadingElectricityLastRead?: (/** Date of when the reading of electricity utility was last recorded */\nstring) | null | undefined, meterReadingWater?: (/** The recorded utility reading for the water meter */\nstring) | null | undefined, meterReadingWaterLastRead?: (/** Date of when the reading of water utility was last recorded */\nstring) | null | undefined, feeNotes?: (/** Financial notes set against the tenancy */\nstring) | null | undefined, legalStatusId?: (/** The identifier of the legal status to set against the tenancy */\nstring) | null | undefined, deposit?: (UpdateTenancyDepositModel) | null | undefined, lettingFee?: (UpdateTenancyLettingFeeModel) | null | undefined, managementFee?: (UpdateTenancyManagementFeeModel) | null | undefined, metadata?: (/** App specific metadata to set against the tenancy */\nRecord<string, Record<string, never>>) | null | undefined};\nexport const updateTenancyModel = /** Request body used to update an existing Tenancy */\nz.object({startDate: /** The start date of the tenancy */\nz.string().optional().nullable(), endDate: /** The end date of the tenancy */\nz.string().optional().nullable(), status: /** The current status of the tenancy (offerPending/offerWithdrawn/offerRejected/arranging/current/finished/cancelled) */\nz.string().optional().nullable(), agentRole: /** The role that the agent is performing for the tenancy (managed/rentCollection/collectFirstPayment/collectRentToDate/lettingOnly/introducingTenant) */\nz.string().optional().nullable(), rent: /** The amount of rent required, returned in relation to the collection frequency */\nz.number().optional().nullable(), rentFrequency: /** The rent collection frequency (weekly/monthly/annually) */\nz.string().optional().nullable(), endDateConfirmed: /** Flag for end date confirmation */\nz.boolean().optional().nullable(), isPeriodic: /** A flag determining whether or not the tenancy has been extended indefinitely */\nz.boolean().optional().nullable(), typeId: /** The unique identifier of the type of tenancy */\nz.string().optional().nullable(), negotiatorId: /** The unique identifier of the negotiator who is managing the tenancy */\nz.string().optional().nullable(), source: updateTenancySourceModel.optional().nullable(), rentInstalmentsFrequency: /** The frequency of rental instalment payments (weekly/fortnightly/monthly/quarterly/halfYearly/yearly/every28Days/other) */\nz.string().optional().nullable(), rentInstalmentsAmount: /** The amount due for each rent instalment (where specified) */\nz.number().optional().nullable(), rentInstalmentsStart: /** The date that the first instalment is due */\nz.string().optional().nullable(), meterReadingGas: /** The recorded utility reading for the gas meter */\nz.string().optional().nullable(), meterReadingGasLastRead: /** Date of when the reading of gas utility was last recorded */\nz.string().optional().nullable(), meterReadingElectricity: /** The recorded utility reading for the electricity meter */\nz.string().optional().nullable(), meterReadingElectricityLastRead: /** Date of when the reading of electricity utility was last recorded */\nz.string().optional().nullable(), meterReadingWater: /** The recorded utility reading for the water meter */\nz.string().optional().nullable(), meterReadingWaterLastRead: /** Date of when the reading of water utility was last recorded */\nz.string().optional().nullable(), feeNotes: /** Financial notes set against the tenancy */\nz.string().optional().nullable(), legalStatusId: /** The identifier of the legal status to set against the tenancy */\nz.string().optional().nullable(), deposit: updateTenancyDepositModel.optional().nullable(), lettingFee: updateTenancyLettingFeeModel.optional().nullable(), managementFee: updateTenancyManagementFeeModel.optional().nullable(), metadata: /** App specific metadata to set against the tenancy */\nz.record(z.string(), z.object({})).optional().nullable()});",
  "src/schemas/updateTenancySourceModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateTenancySourceModel = /** Request body used to set the source of a new tenancy */\n{id?: (/** The unique identifier of the source for the tenancy */\nstring) | null | undefined, type?: (/** The source type (office/source) */\nstring) | null | undefined};\nexport const updateTenancySourceModel = /** Request body used to set the source of a new tenancy */\nz.object({id: /** The unique identifier of the source for the tenancy */\nz.string().optional().nullable(), type: /** The source type (office/source) */\nz.string().optional().nullable()});",
  "src/schemas/updateTenancyDepositModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateTenancyDepositModel = /** Request body used to set the deposit of a tenancy */\n{heldBy?: (/** The deposit holder (depositProtectionScheme/stakeholder/landlordsAgent/landlord/notApplicable) */\nstring) | null | undefined, period?: (/** The number of weeks or months rent collected as the deposit on the tenancy */\nnumber) | null | undefined, type?: (/** The type of deposit (weeksRent/monthsRent/fixedSum/guarantee) */\nstring) | null | undefined, sum?: (/** The amount of deposit held */\nnumber) | null | undefined};\nexport const updateTenancyDepositModel = /** Request body used to set the deposit of a tenancy */\nz.object({heldBy: /** The deposit holder (depositProtectionScheme/stakeholder/landlordsAgent/landlord/notApplicable) */\nz.string().optional().nullable(), period: /** The number of weeks or months rent collected as the deposit on the tenancy */\nz.number().int().optional().nullable(), type: /** The type of deposit (weeksRent/monthsRent/fixedSum/guarantee) */\nz.string().optional().nullable(), sum: /** The amount of deposit held */\nz.number().optional().nullable()});",
  "src/schemas/updateTenancyLettingFeeModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateTenancyLettingFeeModel = /** Request body used to update letting fees on an existing tenancy */\n{type?: (/** The letting fee type (percentage/fixed) */\nstring) | null | undefined, amount?: (/** The fee amount */\nnumber) | null | undefined, frequency?: (/** The frequency of when the fee is to be collected (upfront/upfrontOver2Months/monthly/quarterly/halfYearly/yearly/28days/other/notApplicable) */\nstring) | null | undefined};\nexport const updateTenancyLettingFeeModel = /** Request body used to update letting fees on an existing tenancy */\nz.object({type: /** The letting fee type (percentage/fixed) */\nz.string().optional().nullable(), amount: /** The fee amount */\nz.number().optional().nullable(), frequency: /** The frequency of when the fee is to be collected (upfront/upfrontOver2Months/monthly/quarterly/halfYearly/yearly/28days/other/notApplicable) */\nz.string().optional().nullable()});",
  "src/schemas/updateTenancyManagementFeeModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateTenancyManagementFeeModel = /** Request body used to update management fees on an existing tenancy */\n{type?: (/** The management fee type (percentage/fixed) */\nstring) | null | undefined, amount?: (/** The fee amount */\nnumber) | null | undefined, frequency?: (/** The frequency of when the fee is to be collected (monthly/quarterly/halfYearly/yearly/28days/sameAsLettingFee) */\nstring) | null | undefined};\nexport const updateTenancyManagementFeeModel = /** Request body used to update management fees on an existing tenancy */\nz.object({type: /** The management fee type (percentage/fixed) */\nz.string().optional().nullable(), amount: /** The fee amount */\nz.number().optional().nullable(), frequency: /** The frequency of when the fee is to be collected (monthly/quarterly/halfYearly/yearly/28days/sameAsLettingFee) */\nz.string().optional().nullable()});",
  "src/sections/Tenancies/services/useGetApiTenanciesIdRelationshipsRelationshipId.generated.ts": "import { getApiTenanciesIdRelationshipsRelationshipIdResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiTenanciesIdRelationshipsRelationshipIdFnArgs = {id: string, relationshipId: string};\nexport const getApiTenanciesIdRelationshipsRelationshipIdFn = async ({id, relationshipId}: GetApiTenanciesIdRelationshipsRelationshipIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${id}/relationships/${relationshipId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiTenanciesIdRelationshipsRelationshipIdResponse.parse(data)\n    };\nexport const useGetApiTenanciesIdRelationshipsRelationshipId = ({id, relationshipId}: GetApiTenanciesIdRelationshipsRelationshipIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Tenancies', id, relationshipId],\n        queryFn: () => getApiTenanciesIdRelationshipsRelationshipIdFn({id, relationshipId})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Tenancies/services/useGetApiTenanciesIdChecksCheckId.generated.ts": "import { getApiTenanciesIdChecksCheckIdResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiTenanciesIdChecksCheckIdFnArgs = {id: string, checkId: string};\nexport const getApiTenanciesIdChecksCheckIdFn = async ({id, checkId}: GetApiTenanciesIdChecksCheckIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${id}/checks/${checkId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiTenanciesIdChecksCheckIdResponse.parse(data)\n    };\nexport const useGetApiTenanciesIdChecksCheckId = ({id, checkId}: GetApiTenanciesIdChecksCheckIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Tenancies', id, checkId],\n        queryFn: () => getApiTenanciesIdChecksCheckIdFn({id, checkId})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Tenancies/services/useDeleteApiTenanciesIdChecksCheckId.generated.ts": "import { deleteApiTenanciesIdChecksCheckIdResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type DeleteApiTenanciesIdChecksCheckIdFnArgs = {id: string, checkId: string};\nexport const deleteApiTenanciesIdChecksCheckIdFn = async ({id, checkId}: DeleteApiTenanciesIdChecksCheckIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${id}/checks/${checkId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'DELETE',\n          \n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return deleteApiTenanciesIdChecksCheckIdResponse.parse(data)\n    };\nexport const useDeleteApiTenanciesIdChecksCheckId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: deleteApiTenanciesIdChecksCheckIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Tenancies']})\n        }\n      })\n    };",
  "src/sections/Tenancies/services/usePatchApiTenanciesIdChecksCheckId.generated.ts": "import { UpdateTenancyCheckModel } from '@/schemas/updateTenancyCheckModel.generated.tsx'\nimport { patchApiTenanciesIdChecksCheckIdResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type PatchApiTenanciesIdChecksCheckIdFnArgs = {'If-Match'?: string, id: string, checkId: string, body: UpdateTenancyCheckModel};\nexport const patchApiTenanciesIdChecksCheckIdFn = async ({'If-Match': ifMatch, id, checkId, body}: PatchApiTenanciesIdChecksCheckIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({'If-Match': ifMatch})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${id}/checks/${checkId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PATCH',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return patchApiTenanciesIdChecksCheckIdResponse.parse(data)\n    };\nexport const usePatchApiTenanciesIdChecksCheckId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: patchApiTenanciesIdChecksCheckIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Tenancies']})\n        }\n      })\n    };",
  "src/schemas/updateTenancyCheckModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateTenancyCheckModel = /** Model for updat of an existing tenancy check */\n{status?: (/** The status of the tenancy check (needed/notNeeded/arranging/completed) */\nstring) | null | undefined, metadata?: (/** App specific metadata to set against the tenancy check */\nRecord<string, Record<string, never>>) | null | undefined};\nexport const updateTenancyCheckModel = /** Model for updat of an existing tenancy check */\nz.object({status: /** The status of the tenancy check (needed/notNeeded/arranging/completed) */\nz.string().optional().nullable(), metadata: /** App specific metadata to set against the tenancy check */\nz.record(z.string(), z.object({})).optional().nullable()});",
  "src/sections/Tenancies/services/useGetApiTenanciesIdBreakClausesClauseId.generated.ts": "import { getApiTenanciesIdBreakClausesClauseIdResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiTenanciesIdBreakClausesClauseIdFnArgs = {id: string, clauseId: string};\nexport const getApiTenanciesIdBreakClausesClauseIdFn = async ({id, clauseId}: GetApiTenanciesIdBreakClausesClauseIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${id}/breakClauses/${clauseId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiTenanciesIdBreakClausesClauseIdResponse.parse(data)\n    };\nexport const useGetApiTenanciesIdBreakClausesClauseId = ({id, clauseId}: GetApiTenanciesIdBreakClausesClauseIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Tenancies', id, clauseId],\n        queryFn: () => getApiTenanciesIdBreakClausesClauseIdFn({id, clauseId})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Tenancies/services/useDeleteApiTenanciesIdBreakClausesClauseId.generated.ts": "import { deleteApiTenanciesIdBreakClausesClauseIdResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type DeleteApiTenanciesIdBreakClausesClauseIdFnArgs = {id: string, clauseId: string};\nexport const deleteApiTenanciesIdBreakClausesClauseIdFn = async ({id, clauseId}: DeleteApiTenanciesIdBreakClausesClauseIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${id}/breakClauses/${clauseId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'DELETE',\n          \n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return deleteApiTenanciesIdBreakClausesClauseIdResponse.parse(data)\n    };\nexport const useDeleteApiTenanciesIdBreakClausesClauseId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: deleteApiTenanciesIdBreakClausesClauseIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Tenancies']})\n        }\n      })\n    };",
  "src/sections/Tenancies/services/usePatchApiTenanciesIdBreakClausesClauseId.generated.ts": "import { UpdateTenancyBreakClauseModel } from '@/schemas/updateTenancyBreakClauseModel.generated.tsx'\nimport { patchApiTenanciesIdBreakClausesClauseIdResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type PatchApiTenanciesIdBreakClausesClauseIdFnArgs = {'If-Match'?: string, id: string, clauseId: string, body: UpdateTenancyBreakClauseModel};\nexport const patchApiTenanciesIdBreakClausesClauseIdFn = async ({'If-Match': ifMatch, id, clauseId, body}: PatchApiTenanciesIdBreakClausesClauseIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({'If-Match': ifMatch})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${id}/breakClauses/${clauseId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PATCH',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return patchApiTenanciesIdBreakClausesClauseIdResponse.parse(data)\n    };\nexport const usePatchApiTenanciesIdBreakClausesClauseId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: patchApiTenanciesIdBreakClausesClauseIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Tenancies']})\n        }\n      })\n    };",
  "src/schemas/updateTenancyBreakClauseModel.generated.tsx": "import { UpdateTenancyAgreementModel, updateTenancyAgreementModel } from '@/schemas/updateTenancyAgreementModel.generated.tsx'\nimport { UpdateTenancyBreakFromModel, updateTenancyBreakFromModel } from '@/schemas/updateTenancyBreakFromModel.generated.tsx'\nimport { UpdateTenancyNoticeRequiredModel, updateTenancyNoticeRequiredModel } from '@/schemas/updateTenancyNoticeRequiredModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type UpdateTenancyBreakClauseModel = /** Request body used to update tenancy break clause */\n{active?: (/** The date the break clause becomes/became active */\nstring) | null | undefined, appliesTo?: (/** The responsible party (landlord/tenant/mutual) */\nstring) | null | undefined, agreements?: (UpdateTenancyAgreementModel) | null | undefined, breakFrom?: (UpdateTenancyBreakFromModel) | null | undefined, noticeRequired?: (UpdateTenancyNoticeRequiredModel) | null | undefined};\nexport const updateTenancyBreakClauseModel = /** Request body used to update tenancy break clause */\nz.object({active: /** The date the break clause becomes/became active */\nz.string().optional().nullable(), appliesTo: /** The responsible party (landlord/tenant/mutual) */\nz.string().optional().nullable(), agreements: updateTenancyAgreementModel.optional().nullable(), breakFrom: updateTenancyBreakFromModel.optional().nullable(), noticeRequired: updateTenancyNoticeRequiredModel.optional().nullable()});",
  "src/schemas/updateTenancyAgreementModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateTenancyAgreementModel = /** Request body used to set party agreements to a specific clause in a tenancy agreement */\n{landlord?: (/** A flag to determine if the landlord has agreed */\nboolean) | null | undefined, tenant?: (/** A flag to determine if the tenant has agreed */\nboolean) | null | undefined};\nexport const updateTenancyAgreementModel = /** Request body used to set party agreements to a specific clause in a tenancy agreement */\nz.object({landlord: /** A flag to determine if the landlord has agreed */\nz.boolean().optional().nullable(), tenant: /** A flag to determine if the tenant has agreed */\nz.boolean().optional().nullable()});",
  "src/schemas/updateTenancyBreakFromModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateTenancyBreakFromModel = /** Request body used to set a break clauses break from details */\n{date?: (/** The date the break from clause can be used */\nstring) | null | undefined, minTermMonths?: (/** The minimum number of months until the break clause can be used */\nnumber) | null | undefined};\nexport const updateTenancyBreakFromModel = /** Request body used to set a break clauses break from details */\nz.object({date: /** The date the break from clause can be used */\nz.string().optional().nullable(), minTermMonths: /** The minimum number of months until the break clause can be used */\nz.number().int().optional().nullable()});",
  "src/schemas/updateTenancyNoticeRequiredModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateTenancyNoticeRequiredModel = /** Request body used to set a break clauses notice required details */\n{date?: (/** The date a break clauses notice is required by */\nstring) | null | undefined, beforeBreakMonths?: (/** The number of months the notice is required before the break clause */\nnumber) | null | undefined};\nexport const updateTenancyNoticeRequiredModel = /** Request body used to set a break clauses notice required details */\nz.object({date: /** The date a break clauses notice is required by */\nz.string().optional().nullable(), beforeBreakMonths: /** The number of months the notice is required before the break clause */\nz.number().int().optional().nullable()});",
  "src/sections/Tenancies/services/useGetApiTenanciesIdAllowancesAllowanceId.generated.ts": "import { getApiTenanciesIdAllowancesAllowanceIdResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiTenanciesIdAllowancesAllowanceIdFnArgs = {id: string, allowanceId: string};\nexport const getApiTenanciesIdAllowancesAllowanceIdFn = async ({id, allowanceId}: GetApiTenanciesIdAllowancesAllowanceIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${id}/allowances/${allowanceId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiTenanciesIdAllowancesAllowanceIdResponse.parse(data)\n    };\nexport const useGetApiTenanciesIdAllowancesAllowanceId = ({id, allowanceId}: GetApiTenanciesIdAllowancesAllowanceIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Tenancies', id, allowanceId],\n        queryFn: () => getApiTenanciesIdAllowancesAllowanceIdFn({id, allowanceId})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Tenancies/services/useDeleteApiTenanciesIdAllowancesAllowanceId.generated.ts": "import { deleteApiTenanciesIdAllowancesAllowanceIdResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type DeleteApiTenanciesIdAllowancesAllowanceIdFnArgs = {id: string, allowanceId: string};\nexport const deleteApiTenanciesIdAllowancesAllowanceIdFn = async ({id, allowanceId}: DeleteApiTenanciesIdAllowancesAllowanceIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${id}/allowances/${allowanceId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'DELETE',\n          \n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return deleteApiTenanciesIdAllowancesAllowanceIdResponse.parse(data)\n    };\nexport const useDeleteApiTenanciesIdAllowancesAllowanceId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: deleteApiTenanciesIdAllowancesAllowanceIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Tenancies']})\n        }\n      })\n    };",
  "src/sections/Tenancies/services/usePatchApiTenanciesIdAllowancesAllowanceId.generated.ts": "import { UpdateTenancyAllowanceModel } from '@/schemas/updateTenancyAllowanceModel.generated.tsx'\nimport { patchApiTenanciesIdAllowancesAllowanceIdResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type PatchApiTenanciesIdAllowancesAllowanceIdFnArgs = {'If-Match'?: string, id: string, allowanceId: string, body: UpdateTenancyAllowanceModel};\nexport const patchApiTenanciesIdAllowancesAllowanceIdFn = async ({'If-Match': ifMatch, id, allowanceId, body}: PatchApiTenanciesIdAllowancesAllowanceIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({'If-Match': ifMatch})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${id}/allowances/${allowanceId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PATCH',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return patchApiTenanciesIdAllowancesAllowanceIdResponse.parse(data)\n    };\nexport const usePatchApiTenanciesIdAllowancesAllowanceId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: patchApiTenanciesIdAllowancesAllowanceIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Tenancies']})\n        }\n      })\n    };",
  "src/schemas/updateTenancyAllowanceModel.generated.tsx": "import { UpdateTenancyAgreementModel, updateTenancyAgreementModel } from '@/schemas/updateTenancyAgreementModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type UpdateTenancyAllowanceModel = /** Request body used to update tenancy allowance */\n{state?: (/** The state of the allowance (allowed/notAllowed) */\nstring) | null | undefined, agreements?: (UpdateTenancyAgreementModel) | null | undefined};\nexport const updateTenancyAllowanceModel = /** Request body used to update tenancy allowance */\nz.object({state: /** The state of the allowance (allowed/notAllowed) */\nz.string().optional().nullable(), agreements: updateTenancyAgreementModel.optional().nullable()});",
  "src/sections/Tenancies/services/useGetApiTenanciesIdResponsibilitiesResponsibilityId.generated.ts": "import { getApiTenanciesIdResponsibilitiesResponsibilityIdResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiTenanciesIdResponsibilitiesResponsibilityIdFnArgs = {id: string, responsibilityId: string};\nexport const getApiTenanciesIdResponsibilitiesResponsibilityIdFn = async ({id, responsibilityId}: GetApiTenanciesIdResponsibilitiesResponsibilityIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${id}/responsibilities/${responsibilityId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiTenanciesIdResponsibilitiesResponsibilityIdResponse.parse(data)\n    };\nexport const useGetApiTenanciesIdResponsibilitiesResponsibilityId = ({id, responsibilityId}: GetApiTenanciesIdResponsibilitiesResponsibilityIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Tenancies', id, responsibilityId],\n        queryFn: () => getApiTenanciesIdResponsibilitiesResponsibilityIdFn({id, responsibilityId})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Tenancies/services/useDeleteApiTenanciesIdResponsibilitiesResponsibilityId.generated.ts": "import { deleteApiTenanciesIdResponsibilitiesResponsibilityIdResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type DeleteApiTenanciesIdResponsibilitiesResponsibilityIdFnArgs = {id: string, responsibilityId: string};\nexport const deleteApiTenanciesIdResponsibilitiesResponsibilityIdFn = async ({id, responsibilityId}: DeleteApiTenanciesIdResponsibilitiesResponsibilityIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${id}/responsibilities/${responsibilityId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'DELETE',\n          \n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return deleteApiTenanciesIdResponsibilitiesResponsibilityIdResponse.parse(data)\n    };\nexport const useDeleteApiTenanciesIdResponsibilitiesResponsibilityId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: deleteApiTenanciesIdResponsibilitiesResponsibilityIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Tenancies']})\n        }\n      })\n    };",
  "src/sections/Tenancies/services/usePatchApiTenanciesIdResponsibilitiesResponsibilityId.generated.ts": "import { UpdateTenancyResponsibilityModel } from '@/schemas/updateTenancyResponsibilityModel.generated.tsx'\nimport { patchApiTenanciesIdResponsibilitiesResponsibilityIdResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type PatchApiTenanciesIdResponsibilitiesResponsibilityIdFnArgs = {'If-Match'?: string, id: string, responsibilityId: string, body: UpdateTenancyResponsibilityModel};\nexport const patchApiTenanciesIdResponsibilitiesResponsibilityIdFn = async ({'If-Match': ifMatch, id, responsibilityId, body}: PatchApiTenanciesIdResponsibilitiesResponsibilityIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({'If-Match': ifMatch})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${id}/responsibilities/${responsibilityId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PATCH',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return patchApiTenanciesIdResponsibilitiesResponsibilityIdResponse.parse(data)\n    };\nexport const usePatchApiTenanciesIdResponsibilitiesResponsibilityId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: patchApiTenanciesIdResponsibilitiesResponsibilityIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Tenancies']})\n        }\n      })\n    };",
  "src/schemas/updateTenancyResponsibilityModel.generated.tsx": "import { UpdateTenancyAgreementModel, updateTenancyAgreementModel } from '@/schemas/updateTenancyAgreementModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type UpdateTenancyResponsibilityModel = /** Request body used to update tenancy responsibility */\n{appliesTo?: (/** The responsible party (landlord/tenant) */\nstring) | null | undefined, agreements?: (UpdateTenancyAgreementModel) | null | undefined};\nexport const updateTenancyResponsibilityModel = /** Request body used to update tenancy responsibility */\nz.object({appliesTo: /** The responsible party (landlord/tenant) */\nz.string().optional().nullable(), agreements: updateTenancyAgreementModel.optional().nullable()});",
  "src/sections/Tenancies/services/useGetApiTenanciesIdRenewalNegotiationsRenewalId.generated.ts": "import { getApiTenanciesIdRenewalNegotiationsRenewalIdResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiTenanciesIdRenewalNegotiationsRenewalIdFnArgs = {id: string, renewalId: string};\nexport const getApiTenanciesIdRenewalNegotiationsRenewalIdFn = async ({id, renewalId}: GetApiTenanciesIdRenewalNegotiationsRenewalIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${id}/renewalNegotiations/${renewalId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiTenanciesIdRenewalNegotiationsRenewalIdResponse.parse(data)\n    };\nexport const useGetApiTenanciesIdRenewalNegotiationsRenewalId = ({id, renewalId}: GetApiTenanciesIdRenewalNegotiationsRenewalIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Tenancies', id, renewalId],\n        queryFn: () => getApiTenanciesIdRenewalNegotiationsRenewalIdFn({id, renewalId})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Tenancies/services/usePatchApiTenanciesIdRenewalNegotiationsRenewalId.generated.ts": "import { UpdateTenancyRenewalModel } from '@/schemas/updateTenancyRenewalModel.generated.tsx'\nimport { patchApiTenanciesIdRenewalNegotiationsRenewalIdResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type PatchApiTenanciesIdRenewalNegotiationsRenewalIdFnArgs = {'If-Match'?: string, id: string, renewalId: string, body: UpdateTenancyRenewalModel};\nexport const patchApiTenanciesIdRenewalNegotiationsRenewalIdFn = async ({'If-Match': ifMatch, id, renewalId, body}: PatchApiTenanciesIdRenewalNegotiationsRenewalIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({'If-Match': ifMatch})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${id}/renewalNegotiations/${renewalId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PATCH',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return patchApiTenanciesIdRenewalNegotiationsRenewalIdResponse.parse(data)\n    };\nexport const usePatchApiTenanciesIdRenewalNegotiationsRenewalId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: patchApiTenanciesIdRenewalNegotiationsRenewalIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Tenancies']})\n        }\n      })\n    };",
  "src/schemas/updateTenancyRenewalModel.generated.tsx": "import { UpdateLettingFeeRenewalModel, updateLettingFeeRenewalModel } from '@/schemas/updateLettingFeeRenewalModel.generated.tsx'\nimport { UpdateManagementFeeRenewalModel, updateManagementFeeRenewalModel } from '@/schemas/updateManagementFeeRenewalModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type UpdateTenancyRenewalModel = /** Request body used to update a tenancy renewal negotiation */\n{startDate?: (/** The proposed start date of the tenancy renewal */\nDate) | null | undefined, endDate?: (/** The proposed end date of the tenancy renewal */\nDate) | null | undefined, negotiatorId?: (/** The unique identifier of the negotiator who is managing this tenancy renewal */\nstring) | null | undefined, rent?: (/** The amount of rent required, returned in relation to the collection frequency */\nnumber) | null | undefined, rentFrequency?: (/** The rent collection frequency (weekly/monthly/annually) */\nstring) | null | undefined, lettingFee?: (UpdateLettingFeeRenewalModel) | null | undefined, managementFee?: (UpdateManagementFeeRenewalModel) | null | undefined};\nexport const updateTenancyRenewalModel = /** Request body used to update a tenancy renewal negotiation */\nz.object({startDate: /** The proposed start date of the tenancy renewal */\nz.string().pipe( z.coerce.date() ).optional().nullable(), endDate: /** The proposed end date of the tenancy renewal */\nz.string().pipe( z.coerce.date() ).optional().nullable(), negotiatorId: /** The unique identifier of the negotiator who is managing this tenancy renewal */\nz.string().optional().nullable(), rent: /** The amount of rent required, returned in relation to the collection frequency */\nz.number().optional().nullable(), rentFrequency: /** The rent collection frequency (weekly/monthly/annually) */\nz.string().optional().nullable(), lettingFee: updateLettingFeeRenewalModel.optional().nullable(), managementFee: updateManagementFeeRenewalModel.optional().nullable()});",
  "src/schemas/updateLettingFeeRenewalModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateLettingFeeRenewalModel = /** Request body used to update a tenancy renewals letting fee */\n{type?: (/** The letting fee type (fixed/perentage) */\nstring) | null | undefined, amount?: (/** The letting fee amount as a fixed price or percentage based on the `type` */\nnumber) | null | undefined, frequency?: (/** The frequency at which the letting fee is required (monthly/quarterly/halfYearly/yearly/28days/upfront/upfrontOver2Months/other/notApplicable) */\nstring) | null | undefined};\nexport const updateLettingFeeRenewalModel = /** Request body used to update a tenancy renewals letting fee */\nz.object({type: /** The letting fee type (fixed/perentage) */\nz.string().optional().nullable(), amount: /** The letting fee amount as a fixed price or percentage based on the `type` */\nz.number().optional().nullable(), frequency: /** The frequency at which the letting fee is required (monthly/quarterly/halfYearly/yearly/28days/upfront/upfrontOver2Months/other/notApplicable) */\nz.string().optional().nullable()});",
  "src/schemas/updateManagementFeeRenewalModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateManagementFeeRenewalModel = /** Request body used to update a tenancy renewals management fee */\n{type?: (/** The mangement fee type (fixed/perentage) */\nstring) | null | undefined, amount?: (/** The mangement fee amount as a fixed price or percentage based on the `type` */\nnumber) | null | undefined, frequency?: (/** The frequency at which the mangement fee is required (monthly/quarterly/halfYearly/yearly/28days/sameAsLettingFee) */\nstring) | null | undefined};\nexport const updateManagementFeeRenewalModel = /** Request body used to update a tenancy renewals management fee */\nz.object({type: /** The mangement fee type (fixed/perentage) */\nz.string().optional().nullable(), amount: /** The mangement fee amount as a fixed price or percentage based on the `type` */\nz.number().optional().nullable(), frequency: /** The frequency at which the mangement fee is required (monthly/quarterly/halfYearly/yearly/28days/sameAsLettingFee) */\nz.string().optional().nullable()});",
  "src/sections/Tenancies/services/useGetApiTenanciesIdExtensionsExtensionId.generated.ts": "import { getApiTenanciesIdExtensionsExtensionIdResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiTenanciesIdExtensionsExtensionIdFnArgs = {id: string, extensionId: string};\nexport const getApiTenanciesIdExtensionsExtensionIdFn = async ({id, extensionId}: GetApiTenanciesIdExtensionsExtensionIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${id}/extensions/${extensionId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiTenanciesIdExtensionsExtensionIdResponse.parse(data)\n    };\nexport const useGetApiTenanciesIdExtensionsExtensionId = ({id, extensionId}: GetApiTenanciesIdExtensionsExtensionIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Tenancies', id, extensionId],\n        queryFn: () => getApiTenanciesIdExtensionsExtensionIdFn({id, extensionId})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Tenancies/services/useGetApiTenanciesIdRenewalNegotiationsRenewalIdChecksCheckId.generated.ts": "import { getApiTenanciesIdRenewalNegotiationsRenewalIdChecksCheckIdResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiTenanciesIdRenewalNegotiationsRenewalIdChecksCheckIdFnArgs = {id: string, renewalId: string, checkId: string};\nexport const getApiTenanciesIdRenewalNegotiationsRenewalIdChecksCheckIdFn = async ({id, renewalId, checkId}: GetApiTenanciesIdRenewalNegotiationsRenewalIdChecksCheckIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${id}/renewalNegotiations/${renewalId}/checks/${checkId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiTenanciesIdRenewalNegotiationsRenewalIdChecksCheckIdResponse.parse(data)\n    };\nexport const useGetApiTenanciesIdRenewalNegotiationsRenewalIdChecksCheckId = ({id, renewalId, checkId}: GetApiTenanciesIdRenewalNegotiationsRenewalIdChecksCheckIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Tenancies', id, renewalId, checkId],\n        queryFn: () => getApiTenanciesIdRenewalNegotiationsRenewalIdChecksCheckIdFn({id, renewalId, checkId})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Tenancies/services/useDeleteApiTenanciesIdRenewalNegotiationsRenewalIdChecksCheckId.generated.ts": "import { deleteApiTenanciesIdRenewalNegotiationsRenewalIdChecksCheckIdResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type DeleteApiTenanciesIdRenewalNegotiationsRenewalIdChecksCheckIdFnArgs = {'If-Match'?: string, id: string, renewalId: string, checkId: string};\nexport const deleteApiTenanciesIdRenewalNegotiationsRenewalIdChecksCheckIdFn = async ({'If-Match': ifMatch, id, renewalId, checkId}: DeleteApiTenanciesIdRenewalNegotiationsRenewalIdChecksCheckIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({'If-Match': ifMatch})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${id}/renewalNegotiations/${renewalId}/checks/${checkId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'DELETE',\n          \n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return deleteApiTenanciesIdRenewalNegotiationsRenewalIdChecksCheckIdResponse.parse(data)\n    };\nexport const useDeleteApiTenanciesIdRenewalNegotiationsRenewalIdChecksCheckId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: deleteApiTenanciesIdRenewalNegotiationsRenewalIdChecksCheckIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Tenancies']})\n        }\n      })\n    };",
  "src/sections/Tenancies/services/usePatchApiTenanciesIdRenewalNegotiationsRenewalIdChecksCheckId.generated.ts": "import { UpdateTenancyRenewalCheckModel } from '@/schemas/updateTenancyRenewalCheckModel.generated.tsx'\nimport { patchApiTenanciesIdRenewalNegotiationsRenewalIdChecksCheckIdResponse } from '@/sections/Tenancies/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type PatchApiTenanciesIdRenewalNegotiationsRenewalIdChecksCheckIdFnArgs = {'If-Match'?: string, id: string, renewalId: string, checkId: string, body: UpdateTenancyRenewalCheckModel};\nexport const patchApiTenanciesIdRenewalNegotiationsRenewalIdChecksCheckIdFn = async ({'If-Match': ifMatch, id, renewalId, checkId, body}: PatchApiTenanciesIdRenewalNegotiationsRenewalIdChecksCheckIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({'If-Match': ifMatch})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/tenancies/${id}/renewalNegotiations/${renewalId}/checks/${checkId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PATCH',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return patchApiTenanciesIdRenewalNegotiationsRenewalIdChecksCheckIdResponse.parse(data)\n    };\nexport const usePatchApiTenanciesIdRenewalNegotiationsRenewalIdChecksCheckId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: patchApiTenanciesIdRenewalNegotiationsRenewalIdChecksCheckIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Tenancies']})\n        }\n      })\n    };",
  "src/schemas/updateTenancyRenewalCheckModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateTenancyRenewalCheckModel = /** Request body used to update a tenancy renewal check */\n{status?: (/** The status of the tenancy check (needed/notNeeded/arranging/completed) */\nstring) | null | undefined, metadata?: (/** App specific metadata to set against the tenancy renewal check */\nRecord<string, Record<string, never>>) | null | undefined};\nexport const updateTenancyRenewalCheckModel = /** Request body used to update a tenancy renewal check */\nz.object({status: /** The status of the tenancy check (needed/notNeeded/arranging/completed) */\nz.string().optional().nullable(), metadata: /** App specific metadata to set against the tenancy renewal check */\nz.record(z.string(), z.object({})).optional().nullable()});",
  "src/sections/Transactions/services/useGetApiTransactionsId.generated.ts": "import { getApiTransactionsIdResponse } from '@/sections/Transactions/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiTransactionsIdFnArgs = {id: string};\nexport const getApiTransactionsIdFn = async ({id}: GetApiTransactionsIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/transactions/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiTransactionsIdResponse.parse(data)\n    };\nexport const useGetApiTransactionsId = ({id}: GetApiTransactionsIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Transactions', id],\n        queryFn: () => getApiTransactionsIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Transactions/services/useGetApiTransactionsNominalAccountsId.generated.ts": "import { getApiTransactionsNominalAccountsIdResponse } from '@/sections/Transactions/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiTransactionsNominalAccountsIdFnArgs = {id: string};\nexport const getApiTransactionsNominalAccountsIdFn = async ({id}: GetApiTransactionsNominalAccountsIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/transactions/nominalAccounts/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiTransactionsNominalAccountsIdResponse.parse(data)\n    };\nexport const useGetApiTransactionsNominalAccountsId = ({id}: GetApiTransactionsNominalAccountsIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Transactions', id],\n        queryFn: () => getApiTransactionsNominalAccountsIdFn({id})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Vendors/services/useGetApiVendorsId.generated.ts": "import { getApiVendorsIdResponse } from '@/sections/Vendors/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiVendorsIdFnArgs = {id: string, embed?: (Array<'negotiator' | 'offices' | 'property' | 'sellingReason' | 'solicitor' | 'source' | 'type'>) | null | undefined};\nexport const getApiVendorsIdFn = async ({id, embed}: GetApiVendorsIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/vendors/${id}${querySerialiser({args:{embed}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiVendorsIdResponse.parse(data)\n    };\nexport const useGetApiVendorsId = ({id, embed}: GetApiVendorsIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Vendors', id, embed],\n        queryFn: () => getApiVendorsIdFn({id, embed})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Vendors/services/usePatchApiVendorsId.generated.ts": "import { UpdateVendorModel } from '@/schemas/updateVendorModel.generated.tsx'\nimport { patchApiVendorsIdResponse } from '@/sections/Vendors/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type PatchApiVendorsIdFnArgs = {'If-Match'?: string, id: string, body: UpdateVendorModel};\nexport const patchApiVendorsIdFn = async ({'If-Match': ifMatch, id, body}: PatchApiVendorsIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({'If-Match': ifMatch})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/vendors/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PATCH',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return patchApiVendorsIdResponse.parse(data)\n    };\nexport const usePatchApiVendorsId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: patchApiVendorsIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Vendors']})\n        }\n      })\n    };",
  "src/schemas/updateVendorModel.generated.tsx": "import { VendorUpdateSourceModel, vendorUpdateSourceModel } from '@/schemas/vendorUpdateSourceModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type UpdateVendorModel = /** Request body used to update an existing vendor */\n{lastCall?: (/** The date the vendor was last called */\nstring) | null | undefined, nextCall?: (/** The date the vendor is next due to be called */\nstring) | null | undefined, typeId?: (/** The unique identifier of the type of vendor */\nstring) | null | undefined, sellingReasonId?: (/** The unique identifier of the reason the vendor is selling */\nstring) | null | undefined, solicitorId?: (/** The unique identifier of the vendor's solicitor */\nstring) | null | undefined, correspondenceAddressType?: (/** Value indicating where hard copies of correspondence should be sent for the primary contact (property/contact) */\nstring) | null | undefined, source?: (VendorUpdateSourceModel) | null | undefined, metadata?: (/** App specific metadata that has been set against the vendor */\nRecord<string, Record<string, never>>) | null | undefined};\nexport const updateVendorModel = /** Request body used to update an existing vendor */\nz.object({lastCall: /** The date the vendor was last called */\nz.string().optional().nullable(), nextCall: /** The date the vendor is next due to be called */\nz.string().optional().nullable(), typeId: /** The unique identifier of the type of vendor */\nz.string().optional().nullable(), sellingReasonId: /** The unique identifier of the reason the vendor is selling */\nz.string().optional().nullable(), solicitorId: /** The unique identifier of the vendor's solicitor */\nz.string().optional().nullable(), correspondenceAddressType: /** Value indicating where hard copies of correspondence should be sent for the primary contact (property/contact) */\nz.string().optional().nullable(), source: vendorUpdateSourceModel.optional().nullable(), metadata: /** App specific metadata that has been set against the vendor */\nz.record(z.string(), z.object({})).optional().nullable()});",
  "src/schemas/vendorUpdateSourceModel.generated.tsx": "import { z } from 'zod'\n\nexport type VendorUpdateSourceModel = /** Representation of a vendor's source */\n{id?: (/** The unique identifier of the source of the vendor */\nstring) | null | undefined, type?: (/** The source type (office/source) */\nstring) | null | undefined};\nexport const vendorUpdateSourceModel = /** Representation of a vendor's source */\nz.object({id: /** The unique identifier of the source of the vendor */\nz.string().optional().nullable(), type: /** The source type (office/source) */\nz.string().optional().nullable()});",
  "src/sections/Vendors/services/useGetApiVendorsIdRelationshipsRelationshipId.generated.ts": "import { getApiVendorsIdRelationshipsRelationshipIdResponse } from '@/sections/Vendors/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiVendorsIdRelationshipsRelationshipIdFnArgs = {id: string, relationshipId: string};\nexport const getApiVendorsIdRelationshipsRelationshipIdFn = async ({id, relationshipId}: GetApiVendorsIdRelationshipsRelationshipIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/vendors/${id}/relationships/${relationshipId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiVendorsIdRelationshipsRelationshipIdResponse.parse(data)\n    };\nexport const useGetApiVendorsIdRelationshipsRelationshipId = ({id, relationshipId}: GetApiVendorsIdRelationshipsRelationshipIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['Vendors', id, relationshipId],\n        queryFn: () => getApiVendorsIdRelationshipsRelationshipIdFn({id, relationshipId})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/Vendors/services/useDeleteApiVendorsIdRelationshipsRelationshipId.generated.ts": "import { deleteApiVendorsIdRelationshipsRelationshipIdResponse } from '@/sections/Vendors/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type DeleteApiVendorsIdRelationshipsRelationshipIdFnArgs = {id: string, relationshipId: string};\nexport const deleteApiVendorsIdRelationshipsRelationshipIdFn = async ({id, relationshipId}: DeleteApiVendorsIdRelationshipsRelationshipIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/vendors/${id}/relationships/${relationshipId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'DELETE',\n          \n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return deleteApiVendorsIdRelationshipsRelationshipIdResponse.parse(data)\n    };\nexport const useDeleteApiVendorsIdRelationshipsRelationshipId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: deleteApiVendorsIdRelationshipsRelationshipIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['Vendors']})\n        }\n      })\n    };",
  "src/sections/WorksOrders/services/useGetApiWorksOrdersId.generated.ts": "import { getApiWorksOrdersIdResponse } from '@/sections/WorksOrders/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiWorksOrdersIdFnArgs = {id: string, embed?: (Array<'company' | 'documents' | 'negotiator' | 'property' | 'tenancy' | 'type'>) | null | undefined, extrasField?: (Array<string>) | null | undefined};\nexport const getApiWorksOrdersIdFn = async ({id, embed, extrasField}: GetApiWorksOrdersIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/worksOrders/${id}${querySerialiser({args:{embed, extrasField}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiWorksOrdersIdResponse.parse(data)\n    };\nexport const useGetApiWorksOrdersId = ({id, embed, extrasField}: GetApiWorksOrdersIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['WorksOrders', id, embed, extrasField],\n        queryFn: () => getApiWorksOrdersIdFn({id, embed, extrasField})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/WorksOrders/services/usePatchApiWorksOrdersId.generated.ts": "import { UpdateWorksOrderModel } from '@/schemas/updateWorksOrderModel.generated.tsx'\nimport { patchApiWorksOrdersIdResponse } from '@/sections/WorksOrders/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type PatchApiWorksOrdersIdFnArgs = {'If-Match'?: string, id: string, body: UpdateWorksOrderModel};\nexport const patchApiWorksOrdersIdFn = async ({'If-Match': ifMatch, id, body}: PatchApiWorksOrdersIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({'If-Match': ifMatch})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/worksOrders/${id}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PATCH',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return patchApiWorksOrdersIdResponse.parse(data)\n    };\nexport const usePatchApiWorksOrdersId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: patchApiWorksOrdersIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['WorksOrders']})\n        }\n      })\n    };",
  "src/schemas/updateWorksOrderModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateWorksOrderModel = /** Request body used to update an existing works order */\n{companyId?: (/** The unique identifier of the company that has been selected to perform the work */\nstring) | null | undefined, propertyId?: (/** The unique identifier of the property where the work is to be carried out */\nstring) | null | undefined, tenancyId?: (/** The unique identifier of the tenancy that the works order originated from */\nstring) | null | undefined, negotiatorId?: (/** The unique identifier of the negotiator that booked the works order */\nstring) | null | undefined, typeId?: (/** The unique id of the type of work that needs to be carried out */\nstring) | null | undefined, status?: (/** The current status of the works order (pendingApproval/pendingQuote/raised/raisedToChase/landlordToComplete/complete/cancelled/quoteAccepted) */\nstring) | null | undefined, description?: (/** A free text description of the work required */\nstring) | null | undefined, reporter?: (/** The party requesting the work to be carried out (landlord/tenant/other) */\nstring) | null | undefined, priority?: (/** The priority level of the works order (low/medium/high) */\nstring) | null | undefined, booked?: (/** The date when the works order was booked */\nstring) | null | undefined, required?: (/** The date when the work is required to be completed by */\nstring) | null | undefined, completed?: (/** The date when the work was completed */\nstring) | null | undefined, metadata?: (/** App specific metadata to set against the works order */\nRecord<string, Record<string, never>>) | null | undefined};\nexport const updateWorksOrderModel = /** Request body used to update an existing works order */\nz.object({companyId: /** The unique identifier of the company that has been selected to perform the work */\nz.string().optional().nullable(), propertyId: /** The unique identifier of the property where the work is to be carried out */\nz.string().optional().nullable(), tenancyId: /** The unique identifier of the tenancy that the works order originated from */\nz.string().optional().nullable(), negotiatorId: /** The unique identifier of the negotiator that booked the works order */\nz.string().optional().nullable(), typeId: /** The unique id of the type of work that needs to be carried out */\nz.string().optional().nullable(), status: /** The current status of the works order (pendingApproval/pendingQuote/raised/raisedToChase/landlordToComplete/complete/cancelled/quoteAccepted) */\nz.string().optional().nullable(), description: /** A free text description of the work required */\nz.string().optional().nullable(), reporter: /** The party requesting the work to be carried out (landlord/tenant/other) */\nz.string().optional().nullable(), priority: /** The priority level of the works order (low/medium/high) */\nz.string().optional().nullable(), booked: /** The date when the works order was booked */\nz.string().optional().nullable(), required: /** The date when the work is required to be completed by */\nz.string().optional().nullable(), completed: /** The date when the work was completed */\nz.string().optional().nullable(), metadata: /** App specific metadata to set against the works order */\nz.record(z.string(), z.object({})).optional().nullable()});",
  "src/sections/WorksOrders/services/useGetApiWorksOrdersIdItemsItemId.generated.ts": "import { getApiWorksOrdersIdItemsItemIdResponse } from '@/sections/WorksOrders/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useEffect } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { useSnack } from '@reapit/elements'\nimport { handleReapitError } from '@/lib/api.ts'\n\nexport type GetApiWorksOrdersIdItemsItemIdFnArgs = {id: string, itemId: string};\nexport const getApiWorksOrdersIdItemsItemIdFn = async ({id, itemId}: GetApiWorksOrdersIdItemsItemIdFnArgs) => {\n      const mergedHeaders = await getMergedHeaders()\n      const res = await fetch(\n        `${import.meta.env.VITE_PLATFORM_API_URL}/worksOrders/${id}/items/${itemId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'GET',\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return getApiWorksOrdersIdItemsItemIdResponse.parse(data)\n    };\nexport const useGetApiWorksOrdersIdItemsItemId = ({id, itemId}: GetApiWorksOrdersIdItemsItemIdFnArgs) => {\n      const { error: errorSnack } = useSnack()\n\n      const result = useQuery({\n        queryKey: ['WorksOrders', id, itemId],\n        queryFn: () => getApiWorksOrdersIdItemsItemIdFn({id, itemId})\n      })\n\n      useEffect(() => {\n        if(result.isError) {\n          const errorMessage = handleReapitError(result.error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        }\n      }, [])\n\n      return result\n    };",
  "src/sections/WorksOrders/services/useDeleteApiWorksOrdersIdItemsItemId.generated.ts": "import { deleteApiWorksOrdersIdItemsItemIdResponse } from '@/sections/WorksOrders/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type DeleteApiWorksOrdersIdItemsItemIdFnArgs = {id: string, itemId: string};\nexport const deleteApiWorksOrdersIdItemsItemIdFn = async ({id, itemId}: DeleteApiWorksOrdersIdItemsItemIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/worksOrders/${id}/items/${itemId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'DELETE',\n          \n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return deleteApiWorksOrdersIdItemsItemIdResponse.parse(data)\n    };\nexport const useDeleteApiWorksOrdersIdItemsItemId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: deleteApiWorksOrdersIdItemsItemIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['WorksOrders']})\n        }\n      })\n    };",
  "src/sections/WorksOrders/services/usePatchApiWorksOrdersIdItemsItemId.generated.ts": "import { UpdateWorksOrderItemModel } from '@/schemas/updateWorksOrderItemModel.generated.tsx'\nimport { patchApiWorksOrdersIdItemsItemIdResponse } from '@/sections/WorksOrders/services/apiTypes.generated.ts'\nimport { getMergedHeaders } from '@/lib/api'\nimport { querySerialiser, defaultQuerySerialiserOptions } from '@/lib/querySerialiser'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { ReapitError, handleReapitError } from '@/lib/api.ts'\nimport { useSnack } from '@reapit/elements'\n\nexport type PatchApiWorksOrdersIdItemsItemIdFnArgs = {'If-Match'?: string, id: string, itemId: string, body: UpdateWorksOrderItemModel};\nexport const patchApiWorksOrdersIdItemsItemIdFn = async ({'If-Match': ifMatch, id, itemId, body}: PatchApiWorksOrdersIdItemsItemIdFnArgs) => {\n        const mergedHeaders = await getMergedHeaders({'If-Match': ifMatch})\n        const res = await fetch(\n          `${import.meta.env.VITE_PLATFORM_API_URL}/worksOrders/${id}/items/${itemId}${querySerialiser({args:{}, options: defaultQuerySerialiserOptions })}`,\n        {\n          method: 'PATCH',\n          body: JSON.stringify(body),\n          headers: mergedHeaders\n        }\n      )\n\n      if(res.headers.get(\"content-length\") === \"0\") {\n        return\n      }\n\n      const data = await res.json()\n\n      if (!res.ok) {\n        throw data\n      }\n    \n      return patchApiWorksOrdersIdItemsItemIdResponse.parse(data)\n    };\nexport const usePatchApiWorksOrdersIdItemsItemId = () => {\n      const queryClient = useQueryClient()\n      const { error: errorSnack } = useSnack()\n    \n      return useMutation({\n        mutationFn: patchApiWorksOrdersIdItemsItemIdFn,\n        onError: (error: ReapitError) => {          \n          const errorMessage = handleReapitError(error)\n          if(errorMessage) {\n            errorSnack(errorMessage)\n          }\n        },\n        onSuccess: () => {\n          // Invalidate and refetch\n          void queryClient.invalidateQueries({ queryKey: ['WorksOrders']})\n        }\n      })\n    };",
  "src/schemas/updateWorksOrderItemModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateWorksOrderItemModel = /** Representation of a works order item */\n{notes?: (/** The notes attached to the works order item */\nstring) | null | undefined, chargeTo?: (/** The party to be charged for the work being carried out (landlord/tenant) */\nstring) | null | undefined, estimate?: (/** The estimate of any costs associated with the work being carried out given to the party to be charged for the work */\nnumber) | null | undefined, estimateType?: (/** The type of estimate supplied (agent/verbal/written) */\nstring) | null | undefined, netAmount?: (/** The net cost of the work to be carried out */\nnumber) | null | undefined, vatAmount?: (/** The cost of the vat associated with the work */\nnumber) | null | undefined, reserveAmount?: (/** The amount of funds to be held back by the agent in landlord payment runs to cover the cost of any works required by the works order item */\nnumber) | null | undefined};\nexport const updateWorksOrderItemModel = /** Representation of a works order item */\nz.object({notes: /** The notes attached to the works order item */\nz.string().optional().nullable(), chargeTo: /** The party to be charged for the work being carried out (landlord/tenant) */\nz.string().optional().nullable(), estimate: /** The estimate of any costs associated with the work being carried out given to the party to be charged for the work */\nz.number().optional().nullable(), estimateType: /** The type of estimate supplied (agent/verbal/written) */\nz.string().optional().nullable(), netAmount: /** The net cost of the work to be carried out */\nz.number().optional().nullable(), vatAmount: /** The cost of the vat associated with the work */\nz.number().optional().nullable(), reserveAmount: /** The amount of funds to be held back by the agent in landlord payment runs to cover the cost of any works required by the works order item */\nz.number().optional().nullable()});",
  "src/schemas/httpStatusCode.generated.tsx": "import { z } from 'zod'\n\nexport type HttpStatusCode = 100 | 101 | 102 | 103 | 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 226 | 300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308 | 400 | 401 | 402 | 403 | 404 | 405 | 406 | 407 | 408 | 409 | 410 | 411 | 412 | 413 | 414 | 415 | 416 | 417 | 421 | 422 | 423 | 424 | 426 | 428 | 429 | 431 | 451 | 500 | 501 | 502 | 503 | 504 | 505 | 506 | 507 | 508 | 510 | 511;\nexport const httpStatusCode = z.union([z.literal(100), z.literal(101), z.literal(102), z.literal(103), z.literal(200), z.literal(201), z.literal(202), z.literal(203), z.literal(204), z.literal(205), z.literal(206), z.literal(207), z.literal(208), z.literal(226), z.literal(300), z.literal(301), z.literal(302), z.literal(303), z.literal(304), z.literal(305), z.literal(306), z.literal(307), z.literal(308), z.literal(400), z.literal(401), z.literal(402), z.literal(403), z.literal(404), z.literal(405), z.literal(406), z.literal(407), z.literal(408), z.literal(409), z.literal(410), z.literal(411), z.literal(412), z.literal(413), z.literal(414), z.literal(415), z.literal(416), z.literal(417), z.literal(421), z.literal(422), z.literal(423), z.literal(424), z.literal(426), z.literal(428), z.literal(429), z.literal(431), z.literal(451), z.literal(500), z.literal(501), z.literal(502), z.literal(503), z.literal(504), z.literal(505), z.literal(506), z.literal(507), z.literal(508), z.literal(510), z.literal(511)]);",
  "src/schemas/apiErrorModel.generated.tsx": "import { HttpStatusCode, httpStatusCode } from '@/schemas/httpStatusCode.generated.tsx'\nimport { z } from 'zod'\n\nexport type ApiErrorModel = /** Model for exposing error details to API consumers */\n{statusCode?: (HttpStatusCode) | null | undefined, dateTime?: (/** The date and time that this error event occurred */\nDate) | null | undefined, description?: (/** The detailed information regarding this error event */\nstring) | null | undefined};\nexport const apiErrorModel = /** Model for exposing error details to API consumers */\nz.object({statusCode: httpStatusCode.optional().nullable(), dateTime: /** The date and time that this error event occurred */\nz.string().pipe( z.coerce.date() ).optional().nullable(), description: /** The detailed information regarding this error event */\nz.string().optional().nullable()});",
  "src/schemas/createApplicantLeaseRemaining.generated.tsx": "import { z } from 'zod'\n\nexport type CreateApplicantLeaseRemaining = /** The details specific to the applicant's lease term requirements where they are interested in properties with a leasehold tenure */\n{min?: (/** The minimum number of years that must remain on the lease of a leasehold property */\nnumber) | null | undefined, max?: (/** The maximum number of years that must remain on the lease of a leasehold property */\nnumber) | null | undefined};\nexport const createApplicantLeaseRemaining = /** The details specific to the applicant's lease term requirements where they are interested in properties with a leasehold tenure */\nz.object({min: /** The minimum number of years that must remain on the lease of a leasehold property */\nz.number().int().optional().nullable(), max: /** The maximum number of years that must remain on the lease of a leasehold property */\nz.number().int().optional().nullable()});",
  "src/schemas/createApplicantExternalAreaModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateApplicantExternalAreaModel = /** The applicant's outdoor space requirements */\n{type?: (/** The unit of area that each amount corresponds to (acres/hectares) */\nstring) | null | undefined, amountFrom?: (/** The minimum unit value of outside space that the applicant is looking for */\nnumber) | null | undefined, amountTo?: (/** The maximum unit value of outside space that the applicant is looking for */\nnumber) | null | undefined};\nexport const createApplicantExternalAreaModel = /** The applicant's outdoor space requirements */\nz.object({type: /** The unit of area that each amount corresponds to (acres/hectares) */\nz.string().optional().nullable(), amountFrom: /** The minimum unit value of outside space that the applicant is looking for */\nz.number().optional().nullable(), amountTo: /** The maximum unit value of outside space that the applicant is looking for */\nz.number().optional().nullable()});",
  "src/schemas/createApplicantInternalAreaModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateApplicantInternalAreaModel = /** The applicant's indoor space requirements */\n{type?: (/** The unit of area that each amount corresponds to (squareFeet/squareMetres) */\nstring) | null | undefined, amount?: (/** The unit value of inside space that the applicant is looking for */\nnumber) | null | undefined};\nexport const createApplicantInternalAreaModel = /** The applicant's indoor space requirements */\nz.object({type: /** The unit of area that each amount corresponds to (squareFeet/squareMetres) */\nz.string().optional().nullable(), amount: /** The unit value of inside space that the applicant is looking for */\nz.number().optional().nullable()});",
  "src/schemas/createApplicantSourceModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateApplicantSourceModel = /** An applicant's source of enquiry */\n{id?: (/** The unique identifier of the applicant's source */\nstring) | null | undefined, type?: (/** The source type (office/source) */\nstring) | null | undefined};\nexport const createApplicantSourceModel = /** An applicant's source of enquiry */\nz.object({id: /** The unique identifier of the applicant's source */\nz.string().optional().nullable(), type: /** The source type (office/source) */\nz.string().optional().nullable()});",
  "src/schemas/createApplicantGuernseyModel.generated.tsx": "import { z } from 'zod'\n\nexport type CreateApplicantGuernseyModel = /** Details of regional information specific to Guernsey */\n{market?: (/** Requirements describing which markets the applicant is looking for properties in (local/openA/openB/openC/openD) */\nArray<string>) | null | undefined};\nexport const createApplicantGuernseyModel = /** Details of regional information specific to Guernsey */\nz.object({market: /** Requirements describing which markets the applicant is looking for properties in (local/openA/openB/openC/openD) */\nz.array(z.string().min(1)).optional().nullable()});",
  "src/schemas/createApplicantRegionalModel.generated.tsx": "import { ApplicantGuernseyModel, applicantGuernseyModel } from '@/schemas/applicantGuernseyModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type CreateApplicantRegionalModel = /** Details relating to the real estate market in specific countries. Child models are named based on the ISO3166 country code that the data inside the model relates to */\n{ggy?: (ApplicantGuernseyModel) | null | undefined};\nexport const createApplicantRegionalModel = /** Details relating to the real estate market in specific countries. Child models are named based on the ISO3166 country code that the data inside the model relates to */\nz.object({ggy: applicantGuernseyModel.optional().nullable()});",
  "src/schemas/validationMessageModel.generated.tsx": "import { z } from 'zod'\n\nexport type ValidationMessageModel = /** Model for validation failure */\n{field?: (/** Gets the field that the message applies to */\nstring) | null | undefined, message?: (/** Gets the validation failure message to issue to the client */\nstring) | null | undefined};\nexport const validationMessageModel = /** Model for validation failure */\nz.object({field: /** Gets the field that the message applies to */\nz.string().optional().nullable(), message: /** Gets the validation failure message to issue to the client */\nz.string().optional().nullable()});",
  "src/schemas/validationErrorModel.generated.tsx": "import { HttpStatusCode, httpStatusCode } from '@/schemas/httpStatusCode.generated.tsx'\nimport { ValidationMessageModel, validationMessageModel } from '@/schemas/validationMessageModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type ValidationErrorModel = /** Represents a one or more messages for fields that have failed a given validation action */\n{statusCode?: (HttpStatusCode) | null | undefined, dateTime?: (/** The date and time that this error event occurred */\nDate) | null | undefined, description?: (/** The detailed information regarding this error event */\nstring) | null | undefined, errors?: (/** Gets or sets the list of validation errors. */\nArray<ValidationMessageModel>) | null | undefined};\nexport const validationErrorModel = /** Represents a one or more messages for fields that have failed a given validation action */\nz.object({statusCode: httpStatusCode.optional().nullable(), dateTime: /** The date and time that this error event occurred */\nz.string().pipe( z.coerce.date() ).optional().nullable(), description: /** The detailed information regarding this error event */\nz.string().optional().nullable(), errors: /** Gets or sets the list of validation errors. */\nz.array(validationMessageModel).optional().nullable()});",
  "src/schemas/updateApplicantLeaseRemaining.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateApplicantLeaseRemaining = /** The details specific to the applicant's lease term requirements where they are interested in properties with a leasehold tenure */\n{min?: (/** The minimum number of years that must remain on the lease of a leasehold property */\nnumber) | null | undefined, max?: (/** The maximum number of years that must remain on the lease of a leasehold property */\nnumber) | null | undefined};\nexport const updateApplicantLeaseRemaining = /** The details specific to the applicant's lease term requirements where they are interested in properties with a leasehold tenure */\nz.object({min: /** The minimum number of years that must remain on the lease of a leasehold property */\nz.number().int().optional().nullable(), max: /** The maximum number of years that must remain on the lease of a leasehold property */\nz.number().int().optional().nullable()});",
  "src/schemas/updateApplicantBuyingModel.generated.tsx": "import { ApplicantLeaseRemaining, applicantLeaseRemaining } from '@/schemas/applicantLeaseRemaining.generated.tsx'\nimport { z } from 'zod'\n\nexport type UpdateApplicantBuyingModel = /** The details specific to applicants with a marketingMode of buying */\n{priceFrom?: (/** The lower bound of the applicant's budget */\nnumber) | null | undefined, priceTo?: (/** The upper bound of the applicant's budget */\nnumber) | null | undefined, decoration?: (/** A list of property decoration requirements taken from the full listing of the associated department (unmodernised/fair/good/veryGood) */\nArray<string>) | null | undefined, reasonId?: (/** The identifier of the applicant's buying reason */\nstring) | null | undefined, positionId?: (/** The identifier of the applicant's selling position */\nstring) | null | undefined, tenure?: (/** A list of tenure requirements taken from the full listing of the associated department (freehold/leasehold/shareOfFreehold) */\nArray<string>) | null | undefined, mortgageExpiry?: (/** The date when the applicant's current mortgage expires/is due for renewal */\nstring) | null | undefined, leaseRemaining?: (ApplicantLeaseRemaining) | null | undefined};\nexport const updateApplicantBuyingModel = /** The details specific to applicants with a marketingMode of buying */\nz.object({priceFrom: /** The lower bound of the applicant's budget */\nz.number().int().optional().nullable(), priceTo: /** The upper bound of the applicant's budget */\nz.number().int().optional().nullable(), decoration: /** A list of property decoration requirements taken from the full listing of the associated department (unmodernised/fair/good/veryGood) */\nz.array(z.string().min(1)).optional().nullable(), reasonId: /** The identifier of the applicant's buying reason */\nz.string().optional().nullable(), positionId: /** The identifier of the applicant's selling position */\nz.string().optional().nullable(), tenure: /** A list of tenure requirements taken from the full listing of the associated department (freehold/leasehold/shareOfFreehold) */\nz.array(z.string().min(1)).optional().nullable(), mortgageExpiry: /** The date when the applicant's current mortgage expires/is due for renewal */\nz.string().optional().nullable(), leaseRemaining: applicantLeaseRemaining.optional().nullable()});",
  "src/schemas/updateApplicantExternalAreaModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateApplicantExternalAreaModel = /** The applicant's outdoor space requirements */\n{type?: (/** The unit of area that each amount corresponds to (acres/hectares) */\nstring) | null | undefined, amountFrom?: (/** The minimum unit value of outside space that the applicant is looking for */\nnumber) | null | undefined, amountTo?: (/** The maximum unit value of outside space that the applicant is looking for */\nnumber) | null | undefined};\nexport const updateApplicantExternalAreaModel = /** The applicant's outdoor space requirements */\nz.object({type: /** The unit of area that each amount corresponds to (acres/hectares) */\nz.string().optional().nullable(), amountFrom: /** The minimum unit value of outside space that the applicant is looking for */\nz.number().optional().nullable(), amountTo: /** The maximum unit value of outside space that the applicant is looking for */\nz.number().optional().nullable()});",
  "src/schemas/updateApplicantInternalAreaModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateApplicantInternalAreaModel = /** The applicant's indoor space requirements */\n{type?: (/** The unit of area that each amount corresponds to (squareFeet/squareMetres) */\nstring) | null | undefined, amount?: (/** The unit value of inside space that the applicant is looking for */\nnumber) | null | undefined};\nexport const updateApplicantInternalAreaModel = /** The applicant's indoor space requirements */\nz.object({type: /** The unit of area that each amount corresponds to (squareFeet/squareMetres) */\nz.string().optional().nullable(), amount: /** The unit value of inside space that the applicant is looking for */\nz.number().optional().nullable()});",
  "src/schemas/updateApplicantSourceModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateApplicantSourceModel = /** An applicant's source of enquiry */\n{id?: (/** The unique identifier of the applicant's source */\nstring) | null | undefined, type?: (/** The source type (office/source) */\nstring) | null | undefined};\nexport const updateApplicantSourceModel = /** An applicant's source of enquiry */\nz.object({id: /** The unique identifier of the applicant's source */\nz.string().optional().nullable(), type: /** The source type (office/source) */\nz.string().optional().nullable()});",
  "src/schemas/updateApplicantGuernseyModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateApplicantGuernseyModel = /** Details of regional information specific to Guernsey */\n{market?: (/** Requirements describing which markets the applicant is looking for properties in (local/openA/openB/openC/openD) */\nArray<string>) | null | undefined};\nexport const updateApplicantGuernseyModel = /** Details of regional information specific to Guernsey */\nz.object({market: /** Requirements describing which markets the applicant is looking for properties in (local/openA/openB/openC/openD) */\nz.array(z.string().min(1)).optional().nullable()});",
  "src/schemas/updateApplicantRegionalModel.generated.tsx": "import { ApplicantGuernseyModel, applicantGuernseyModel } from '@/schemas/applicantGuernseyModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type UpdateApplicantRegionalModel = /** Details relating to the real estate market in specific countries. Child models are named based on the ISO3166 country code that the data inside the model relates to */\n{ggy?: (ApplicantGuernseyModel) | null | undefined};\nexport const updateApplicantRegionalModel = /** Details relating to the real estate market in specific countries. Child models are named based on the ISO3166 country code that the data inside the model relates to */\nz.object({ggy: applicantGuernseyModel.optional().nullable()});",
  "src/schemas/additionalCompanyContactDetailsModel.generated.tsx": "import { z } from 'zod'\n\nexport type AdditionalCompanyContactDetailsModel = /** Representation of additional contact details */\n{type?: (/** The type of contact detail */\nstring) | null | undefined, value?: (/** The contact detail */\nstring) | null | undefined};\nexport const additionalCompanyContactDetailsModel = /** Representation of additional contact details */\nz.object({type: /** The type of contact detail */\nz.string().optional().nullable(), value: /** The contact detail */\nz.string().optional().nullable()});",
  "src/schemas/operationType.generated.tsx": "import { z } from 'zod'\n\nexport type OperationType = 0 | 1 | 2 | 3 | 4 | 5 | 6;\nexport const operationType = z.union([z.literal(0), z.literal(1), z.literal(2), z.literal(3), z.literal(4), z.literal(5), z.literal(6)]);",
  "src/schemas/operationBase.generated.tsx": "import { OperationType, operationType } from '@/schemas/operationType.generated.tsx'\nimport { z } from 'zod'\n\nexport type OperationBase = {operationType?: (OperationType) | null | undefined, path?: (string) | null | undefined, op?: (string) | null | undefined, from?: (string) | null | undefined};\nexport const operationBase = z.object({operationType: operationType.optional().nullable(), path: z.string().optional().nullable(), op: z.string().optional().nullable(), from: z.string().optional().nullable()});",
  "src/schemas/operation.generated.tsx": "import { OperationBase, operationBase } from '@/schemas/operationBase.generated.tsx'\nimport { z } from 'zod'\n\nexport type Operation = OperationBase;\nexport const operation = operationBase;",
  "src/schemas/updateIrelandPropertyBERModel.generated.tsx": "import { z } from 'zod'\n\nexport type UpdateIrelandPropertyBERModel = /** Request body used to set the energy performance rating information for properties in Ireland */\n{exempt?: (/** A flag denoting whether or not this property is exempt from requiring a Building Energy Rating (BER) certificate */\nboolean) | null | undefined, rating?: (/** The BER rating of the property */\nstring) | null | undefined, refNumber?: (/** The BER certificate reference number */\nstring) | null | undefined, epi?: (/** The energy performance indicator for the property */\nstring) | null | undefined};\nexport const updateIrelandPropertyBERModel = /** Request body used to set the energy performance rating information for properties in Ireland */\nz.object({exempt: /** A flag denoting whether or not this property is exempt from requiring a Building Energy Rating (BER) certificate */\nz.boolean().optional().nullable(), rating: /** The BER rating of the property */\nz.string().optional().nullable(), refNumber: /** The BER certificate reference number */\nz.string().optional().nullable(), epi: /** The energy performance indicator for the property */\nz.string().optional().nullable()});",
  "src/schemas/updateIrelandPropertyModel.generated.tsx": "import { CreateIrelandPropertyBERModel, createIrelandPropertyBERModel } from '@/schemas/createIrelandPropertyBERModel.generated.tsx'\nimport { z } from 'zod'\n\nexport type UpdateIrelandPropertyModel = /** Request body used to set the data specific to properties in Ireland */\n{buildingEnergyRating?: (CreateIrelandPropertyBERModel) | null | undefined};\nexport const updateIrelandPropertyModel = /** Request body used to set the data specific to properties in Ireland */\nz.object({buildingEnergyRating: createIrelandPropertyBERModel.optional().nullable()});",
  "src/schemas/vendorContactAddressModel.generated.tsx": "import { z } from 'zod'\n\nexport type VendorContactAddressModel = /** Representation of the physical address of a building or premise */\n{buildingName?: (/** The building name */\nstring) | null | undefined, buildingNumber?: (/** The building number */\nstring) | null | undefined, line1?: (/** The first line of the address */\nstring) | null | undefined, line2?: (/** The second line of the address */\nstring) | null | undefined, line3?: (/** The third line of the address */\nstring) | null | undefined, line4?: (/** The fourth line of the address */\nstring) | null | undefined, postcode?: (/** The postcode */\nstring) | null | undefined, countryId?: (/** The ISO-3166 country code that the address resides within */\nstring) | null | undefined};\nexport const vendorContactAddressModel = /** Representation of the physical address of a building or premise */\nz.object({buildingName: /** The building name */\nz.string().optional().nullable(), buildingNumber: /** The building number */\nz.string().optional().nullable(), line1: /** The first line of the address */\nz.string().optional().nullable(), line2: /** The second line of the address */\nz.string().optional().nullable(), line3: /** The third line of the address */\nz.string().optional().nullable(), line4: /** The fourth line of the address */\nz.string().optional().nullable(), postcode: /** The postcode */\nz.string().optional().nullable(), countryId: /** The ISO-3166 country code that the address resides within */\nz.string().optional().nullable()});"
}