---
title: "FunctionParameter"
description: "Generates TypeScript function parameters with advanced handling for different parameter patterns."
kind: "class"
filename: "skmtc/deno/core/typescript/FunctionParameter.ts"
line: 206
---

# FunctionParameter

Generates TypeScript function parameters with advanced handling for different parameter patterns.

`FunctionParameter` is a sophisticated utility for generating TypeScript function parameter
syntax that handles multiple parameter patterns including named parameters, destructured
object parameters, and void parameters. It provides intelligent type handling and can
generate both the parameter declaration and the parameter usage patterns.

This class is essential for generating type-safe function signatures in API clients,
utility functions, and other generated code where parameters need to be handled
consistently and safely.

## Supported Parameter Patterns

- **Named Parameters**: Traditional `paramName: Type` syntax
- **Destructured Parameters**: `{ prop1, prop2 }: ObjectType` syntax  
- **Void Parameters**: No parameters when dealing with void types
- **Optional Parameters**: Automatic handling of optional parameter markers
- **Empty Filtering**: Option to skip empty properties in destructured objects


## Example

Named parameter generation
```typescript
import { FunctionParameter, Definition, Identifier } from '@skmtc/core';

const userIdParam = new FunctionParameter({
  name: 'userId',
  typeDefinition: new Definition({
    context: generateContext,
    identifier: Identifier.createType('string'),
    value: { type: 'string' }
  }),
  required: true
});

console.log(userIdParam.toString()); // 'userId: string'
console.log(userIdParam.toInbound()); // 'userId'
```


## Example

Destructured parameter generation
```typescript
const destructuredParam = new FunctionParameter({
  typeDefinition: new Definition({
    context: generateContext,
    identifier: Identifier.createType('UserParams'),
    value: {
      type: 'object',
      objectProperties: {
        properties: {
          name: { type: 'string' },
          email: { type: 'string' },
          age: { type: 'number' }
        }
      }
    }
  }),
  destructure: true,
  required: true
});

console.log(destructuredParam.toString());
// '{ name, email, age }: UserParams'

console.log(destructuredParam.toInbound());
// '{ name, email, age }'
```


## Example

Optional parameter handling
```typescript
const optionalParam = new FunctionParameter({
  name: 'options',
  typeDefinition: optionsTypeDefinition,
  required: false
});

console.log(optionalParam.toString()); // 'options?: OptionsType'
```


## Example

Void parameter handling
```typescript
const voidParam = new FunctionParameter({
  typeDefinition: new Definition({
    context: generateContext,
    identifier: Identifier.createType('void'),
    value: { type: 'void' }
  })
});

console.log(voidParam.toString()); // ''
console.log(voidParam.toInbound()); // ''
```


## Example

Property checking
```typescript
const objectParam = new FunctionParameter({
  typeDefinition: userTypeDefinition,
  destructure: true,
  required: true
});

if (objectParam.hasProperty('email')) {
  // Handle email property access
  console.log('Parameter includes email property');
}

const propertyList = objectParam.toPropertyList();
console.log(propertyList.toString()); // 'name, email, age'
```


## Example

API method generation with parameters
```typescript
class ApiMethodGenerator {
  generateMethod(
    methodName: string,
    pathParams?: FunctionParameter,
    bodyParam?: FunctionParameter
  ) {
    const parameters = [pathParams, bodyParam]
      .filter(p => p && p.toString())
      .map(p => p!.toString())
      .join(', ');

    const pathInbound = pathParams?.toInbound() || '';
    const bodyInbound = bodyParam?.toInbound() || '';

    return `
async ${methodName}(${parameters}) {
  const path = this.buildPath(${pathInbound});
  return this.request('POST', path, ${bodyInbound});
}`;
  }
}
```


## Example

Empty property filtering
```typescript
const filteredParam = new FunctionParameter({
  typeDefinition: sparseObjectDefinition,
  destructure: true,
  required: true,
  skipEmpty: true // Skip properties with empty types
});

// Only non-empty properties will be included in destructuring
console.log(filteredParam.toString());
// '{ validProp1, validProp2 }: FilteredType' (empty props omitted)
```

## Class Definition

### Constructors

- `constructor(args: FunctionParameterArgs)`

### Properties

- `properties: ParameterProperties`
- `skipEmpty?: boolean`

### Methods

- `hasProperty(name: string): boolean`
- `toPropertyList(): List`
- `toInbound(): string`
- `toString(): string`

## Source

Located at `skmtc/deno/core/typescript/FunctionParameter.ts:206:0`
